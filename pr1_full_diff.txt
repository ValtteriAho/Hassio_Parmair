From 910a557e9e8ac07b7cae894d2defb3cef3f6ee4f Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 20:15:22 +0200
Subject: [PATCH 01/15] docs: Add V2 register map documentation

---
 v2_register.md | 150 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 150 insertions(+)
 create mode 100644 v2_register.md

diff --git a/v2_register.md b/v2_register.md
new file mode 100644
index 0000000..34e5f15
--- /dev/null
+++ b/v2_register.md
@@ -0,0 +1,150 @@
+# Parmair V2 Registers
+
+Rekisterityyppi: Holding Regs (Funktiokoodit 03, 06, 16)
+Rekisterin arvo: Single = int16, Double = uint32 (LSW löytyy seuraavasta rekisteristä)
+
+MinLimit ja MaxLimit arvot esitetty skaalattuna
+
+## 1 SYSTEM SETTINGS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 3 | ACK_ALARMS | Hälytysten kuittaus (0=ODOTETAAN KUITTAUSTA, 1=OK/KUITTAA) | 1 SYSTEM SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 4 | ALARM_COUNT | Aktiivisten hälytysten määrä | 1 SYSTEM SETTINGS | 0 | 1 | 0 | 100 | | ReadOnly | FALSE |
+| 9 | TIME_YEAR | Vuosi | 1 SYSTEM SETTINGS | 2023 | 1 | 2000 | 3000 | | ReadWrite | FALSE |
+| 10 | TIME_MONTH | Kuukausi | 1 SYSTEM SETTINGS | 8 | 1 | 1 | 12 | | ReadWrite | FALSE |
+| 11 | TIME_DAY | Päivä | 1 SYSTEM SETTINGS | 1 | 1 | 1 | 31 | | ReadWrite | FALSE |
+| 12 | TIME_HOUR | Tunnit | 1 SYSTEM SETTINGS | 1 | 1 | 0 | 23 | | ReadWrite | FALSE |
+| 13 | TIME_MIN | Minuutit | 1 SYSTEM SETTINGS | 1 | 1 | 0 | 59 | | ReadWrite | FALSE |
+| 14 | MULTI_FW_VER | Multi24 firmware versio | 1 SYSTEM SETTINGS | 2.00 | 100 | 0.00 | 100.00 | | ReadOnly | FALSE |
+| 15 | MULTI_SW_VER | Multi24 sovelluksen ohjelmaversio | 1 SYSTEM SETTINGS | 2.00 | 100 | 0.00 | 100.00 | | ReadOnly | FALSE |
+| 16 | MULTI_BL_VER | Multi24 bootloaderin ohjelmaversio | 1 SYSTEM SETTINGS | 2.00 | 100 | 0.00 | 100.00 | | ReadOnly | FALSE |
+
+## 2 PHYSICAL INPUTS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 20 | TE01_M | Lämpötilamittaus, raitisilma | 2 PHYSICAL INPUTS | 0.0 | 10 | -50.0 | 120.0 | °C | ReadWrite | FALSE |
+| 21 | TE05_M | Lämpötilamittaus, LTO kylmäpiste | 2 PHYSICAL INPUTS | 0.0 | 10 | -50.0 | 120.0 | °C | ReadOnly | FALSE |
+| 22 | TE10_M | Lämpötilamittaus, tuloilma | 2 PHYSICAL INPUTS | 0.0 | 10 | -50.0 | 120.0 | °C | ReadOnly | FALSE |
+| 23 | TE31_M | Lämpötilamittaus, jäteilma | 2 PHYSICAL INPUTS | 0.0 | 10 | -50.0 | 120.0 | °C | ReadOnly | FALSE |
+| 24 | TE30_M | Lämpötilamittaus, poistoilma | 2 PHYSICAL INPUTS | 0.0 | 10 | -50.0 | 120.0 | °C | ReadOnly | FALSE |
+| 25 | ME05_M | Kosteusmittaus, LTO-laite | 2 PHYSICAL INPUTS | 0 | 1 | 0 | 100 | % | ReadOnly | FALSE |
+| 26 | QE05_M | Hiilidioksidimittaus, poistoilma | 2 PHYSICAL INPUTS | 0 | 1 | -1 | 2000 | ppm | ReadOnly | FALSE |
+| 27 | TF10_I | Indikointi, tulopuhallin | 2 PHYSICAL INPUTS | 0 | 1 | 0 | 1 | | ReadOnly | FALSE |
+| 28 | PF30_I | Indikointi, poistopuhallin | 2 PHYSICAL INPUTS | 0 | 1 | 0 | 1 | | ReadOnly | FALSE |
+| 29 | ME20_M | Kosteusmittaus, kosteata tila | 2 PHYSICAL INPUTS | 0 | 1 | -1 | 100 | % | ReadOnly | FALSE |
+| 30 | QE20_M | Hiilidioksidimittaus, sisäilma | 2 PHYSICAL INPUTS | 0 | 1 | -1 | 2000 | ppm | ReadOnly | FALSE |
+| 31 | EXTERNAL_M | Ulkoinen ohjaussignaali (0-10V) | 2 PHYSICAL INPUTS | 0.0 | 10 | -1.0 | 100.0 | % | ReadOnly | FALSE |
+| 35 | EXTERNAL_BOOST_M | Ulkoinen tehostussignaali (1-10V) | 2 PHYSICAL INPUTS | 0.0 | 10 | -1.0 | 100.0 | % | ReadOnly | FALSE |
+| 36 | TE10_DEFECTION_M | Tulolämpötilan poikkeutus (+/- 3 astetta), (-9.9=EI käytössä) | 2 PHYSICAL INPUTS | 0.0 | 10 | -9.9 | 3.0 | °C | ReadOnly | FALSE |
+
+## 3 PHYSICAL OUTPUTS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 40 | TF10_Y | Säätö, tulopuhallin | 3 PHYSICAL OUTPUTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 42 | PF30_Y | Säätö, poistopuhallin | 3 PHYSICAL OUTPUTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 44 | TV45_Y | Säätö, jälkilämmityspatteri | 3 PHYSICAL OUTPUTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 46 | FG50_Y | Säätö, LTO | 3 PHYSICAL OUTPUTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 48 | EC05_Y | Säätö, esilämmityspatteri | 3 PHYSICAL OUTPUTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 50 | HP_RAD_O | Ohjaus, maalämpömoduli | 3 PHYSICAL OUTPUTS | 0 | 1 | 0 | 1 | | ReadOnly | FALSE |
+
+## 4 SETTINGS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 60 | HOME_SPEED_S | Asetusarvo, Ilmanvaihtoasetus kotona-tilassa | 4 SETTINGS | 3 | 1 | 1 | 5 | | ReadWrite | FALSE |
+| 61 | TE10_MIN_HOME_S | Asetusarvo, Tulolämpötilan minimiarvo kotona-tilassa | 4 SETTINGS | 17.0 | 10 | 10.0 | 28.0 | °C | ReadWrite | FALSE |
+| 62 | TE10_CONTROL_MODE_S | Asetusarvo, lämpötilan säätö (ECO, Vakio) | 4 SETTINGS | 0 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 63 | AWAY_SPEED_S | Asetusarvo, Ilmanvaihtoasetus poissatilassa | 4 SETTINGS | 1 | 1 | 1 | 5 | | ReadWrite | FALSE |
+| 64 | TE10_MIN_AWAY_S | Asetusarvo, Tulolämpötilan minimiarvo poissa-tilassa | 4 SETTINGS | 15.0 | 10 | 10.0 | 28.0 | °C | ReadWrite | FALSE |
+| 65 | BOOST_SETTING_S | Asetusarvo, Tehostuksen nopeusasetus (nopeus 3-5) | 4 SETTINGS | 4 | 1 | 3 | 5 | | ReadWrite | FALSE |
+| 68 | OVERP_AMOUNT_S | Asetusarvo, Puhaltimien ylipainetilanteen ylipaineen määrä | 4 SETTINGS | 20 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 70 | TP_ENABLE_S | Asetusarvo, Aikaohjelmakäyttö (0=ei käytössä, 1=käytössä) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 71 | AUTO_SUMMER_COOL_S | Asetus, Kesäviilennystoiminto (0=ei käytössä, 1=on, 2=automaatti) | 4 SETTINGS | 2 | 1 | 0 | 2 | | ReadWrite | FALSE |
+| 72 | AUTO_SUMMER_POWER_S | Asetus, Kesäkäytön tehomuutokset (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 73 | TE30_S | Asetusarvo, Poistolämpötila (Tavoiteltava huonelämpötila kesäkaudella) | 4 SETTINGS | 18.0 | 10 | 15.0 | 25.0 | °C | ReadWrite | FALSE |
+| 74 | AUTO_HEATER_ENABLE_S | Asetus, Jälkilämmitysvastus (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 75 | AUTO_COLD_LOWSPEED_S | Asetus, Automaattinen tehonpudotus kylmissä olosuhteissa (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 76 | COLD_LOWSPEED_S | Asetus, Tehonpudostus pakkasella, pakkasraja | 4 SETTINGS | -15.0 | 10 | -25.0 | 10.0 | °C | ReadWrite | FALSE |
+| 77 | AUTO_HUMIDITY_BOOST_S | Asetus, Automaattinen kosteustehostus (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 78 | ME05_BOOST_SENSITIVITY | Asetusarvo, kosteustehostuksen herkkyys | 4 SETTINGS | 1 | 1 | 0 | 2 | | ReadWrite | FALSE |
+| 79 | ME_BST_TE01_LIMIT | Asetusarvo, Kosteustehostuksen ulkolämpötilaraja | 4 SETTINGS | -10.0 | 10 | -15.0 | 15.0 | °C | ReadWrite | FALSE |
+| 80 | AUTO_CO2_BOOST_S | Asetus, Automaattinen hiilidioksiditehostus (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 81 | AUTO_HOMEAWAY_S | Asetus, Automaattinen kotona/poissa (CO2) (0=ei käytössä, 1=automaatti) | 4 SETTINGS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 82 | QE_HOME_S | Asetusarvo, CO2 kotona-raja | 4 SETTINGS | 500 | 1 | 100 | 2000 | ppm | ReadWrite | FALSE |
+| 83 | QE_BOOST_S | Asetusarvo, CO2 tehostusraja (tehostuksen aloitus) | 4 SETTINGS | 800 | 1 | 100 | 2000 | ppm | ReadWrite | FALSE |
+| 90 | FILTER_INTERVAL_S | Asetusarvo, Suodattimien vaihtoväli (0=3kk, 1=4kk, 2=6kk) | 4 SETTINGS | 0 | 1 | 0 | 2 | | ReadWrite | FALSE |
+| 91 | HP_RAD_MODE | Asetusarvo, maalämpömoduulin toiminta (0=Off, 1=On, 2=Auto) | 4 SETTINGS | 2 | 1 | 0 | 2 | | ReadWrite | FALSE |
+| 92 | HP_RAD_WINTER | Asetusarvo, maalämpömoduulin käyttöraja talvi | 4 SETTINGS | 0.0 | 10 | -30.0 | 15.0 | °C | ReadWrite | FALSE |
+| 93 | HP_RAD_SUMMER | Asetusarvo, maalämpömoduulin käyttöraja kesä | 4 SETTINGS | 15.0 | 10 | 0.0 | 40.0 | °C | ReadWrite | FALSE |
+| 94 | HEATING_SEASON_AVERAGE | Asetusarvo, Lämmityskausi (24h raitis lämpötila) | 4 SETTINGS | 14.0 | 10 | 6.0 | 50.0 | °C | ReadWrite | FALSE |
+| 95 | HEATING_SEASON_MOMENT | Asetusarvo, Lämmityskausi (hetkellinen raitis lämpötila) | 4 SETTINGS | 8.0 | 10 | -5.0 | 50.0 | °C | ReadWrite | FALSE |
+| 96 | TE10_MIN_SUMMER_S | Asetusarvo, Tulolämpötilan kesä-tilassa | 4 SETTINGS | 12.0 | 10 | 10.0 | 25.0 | °C | ReadWrite | FALSE |
+| 97 | TE10_MAX_S | Asetusarvo, Tulolämpötilan maksimiarvo | 4 SETTINGS | 25.0 | 10 | 10.0 | 35.0 | °C | ReadWrite | FALSE |
+| 98 | BST_TE01_LIMIT | Asetusarvo, Tehostuksen ulkolämpötilaraja / CO2, 0-10V | 4 SETTINGS | -10.0 | 10 | -15.0 | 0.0 | °C | ReadWrite | FALSE |
+
+## 10 CONFIGURATION PARAMETERS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 105 | M10_TYPE | Mittauspaikan 10 tyyppi. 0=Ei käytössä. | 10 CONFIGURATION PARAMETERS | 0 | 1 | 0 | 27 | | ReadWrite | FALSE |
+| 106 | M11_TYPE | Mittauspaikan 11 tyyppi. 0=Ei käytössä. | 10 CONFIGURATION PARAMETERS | 0 | 1 | 0 | 27 | | ReadWrite | FALSE |
+| 107 | M12_TYPE | Mittauspaikan 12 tyyppi. 0=Ei käytössä. | 10 CONFIGURATION PARAMETERS | 0 | 1 | 0 | 27 | | ReadWrite | FALSE |
+| 108 | SF_SPEED1_S | Asetusarvo, Tulopuhaltimen nopeusasetus 1 | 10 CONFIGURATION PARAMETERS | 20 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 109 | SF_SPEED2_S | Asetusarvo, Tulopuhaltimen nopeusasetus 2 | 10 CONFIGURATION PARAMETERS | 35 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 110 | SF_SPEED3_S | Asetusarvo, Tulopuhaltimen nopeusasetus 3 | 10 CONFIGURATION PARAMETERS | 60 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 111 | SF_SPEED4_S | Asetusarvo, Tulopuhaltimen nopeusasetus 4 | 10 CONFIGURATION PARAMETERS | 75 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 112 | SF_SPEED5_S | Asetusarvo, Tulopuhaltimen nopeusasetus 5 | 10 CONFIGURATION PARAMETERS | 90 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 113 | EF_SPEED1_S | Asetusarvo, Poistopuhaltimen nopeusasetus 1 | 10 CONFIGURATION PARAMETERS | 20 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 114 | EF_SPEED2_S | Asetusarvo, Poistopuhaltimen nopeusasetus 2 | 10 CONFIGURATION PARAMETERS | 35 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 115 | EF_SPEED3_S | Asetusarvo, Poistopuhaltimen nopeusasetus 3 | 10 CONFIGURATION PARAMETERS | 60 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 116 | EF_SPEED4_S | Asetusarvo, Poistopuhaltimen nopeusasetus 4 | 10 CONFIGURATION PARAMETERS | 75 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 117 | EF_SPEED5_S | Asetusarvo, Poistopuhaltimen nopeusasetus 5 | 10 CONFIGURATION PARAMETERS | 90 | 1 | 0 | 100 | % | ReadWrite | FALSE |
+| 120 | SENSOR_TE_COR | Lämpötilan korjaus | 10 CONFIGURATION PARAMETERS | 0.0 | 10 | -5.0 | 5.0 | °C | ReadWrite | FALSE |
+| 121 | SENSOR_ME_COR | Kosteuden korjaus | 10 CONFIGURATION PARAMETERS | 0 | 1 | -20 | 20 | % | ReadWrite | FALSE |
+| 122 | SENSOR_CO2_COR | Hiilidioksidin korjaus | 10 CONFIGURATION PARAMETERS | 0 | 1 | -500 | 500 | ppm | ReadWrite | FALSE |
+| 124 | HEATPUMP_RADIATOR_ENABLE | Maalämpöpatteri (0=Ei asennettu, 1=Asennettu) | 10 CONFIGURATION PARAMETERS | 0 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 125 | VENT_MACHINE | IV-koneen tyyppikoodi | 10 CONFIGURATION PARAMETERS | 1 | 1 | -1000 | 1000 | | ReadOnly | FALSE |
+| 129 | TE10_MIN_S | Asetusarvo, Tulolämpötilan minimiarvo jonka käyttäjä voi asettaa | 10 CONFIGURATION PARAMETERS | 10.0 | 10 | 10.0 | 25.0 | °C | ReadWrite | FALSE |
+| 137 | TE10_BASE_S | Asetusarvo, Tulolämpötilan perusasetusarvo, josta voidaan potikalla poikkeuttaa | 10 CONFIGURATION PARAMETERS | 17.0 | 10 | 15.0 | 25.0 | °C | ReadWrite | FALSE |
+| 140 | BST_MINTIME | Asetusarvo, Tehostuksen minimiaika (min) / LTO, CO2, 0-10V | 10 CONFIGURATION PARAMETERS | 5 | 1 | 1 | 60 | min | ReadWrite | FALSE |
+| 141 | CO2_MINTIME | Asetusarvo, Automaattinen kotona-poissa minimiaika | 10 CONFIGURATION PARAMETERS | 15 | 1 | 1 | 600 | min | ReadWrite | FALSE |
+| 144 | BST_TIME_LIMIT | Asetusarvo, Kosteus ja CO2-tehostusten maksimiaika | 10 CONFIGURATION PARAMETERS | 1440 | 1 | 15 | 1440 | min | ReadWrite | FALSE |
+
+
+## 6 SOFT MEASUREMENTS AND CONTROL POINTS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 180 | UNIT_CONTROL_FO | IV-koneen ohjaus (0=Off, 1=On) | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 1 | 1 | 0 | 1 | | ReadWrite | FALSE |
+| 181 | USERSTATECONTROL_FO | MAC 2 User state control from screen. 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 2 | 1 | 0 | 5 | | ReadWrite | FALSE |
+| 182 | DFRST_FI | Fiktiivinen indikointi, LTO:n sulatus päällä/pois | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0 | 1 | 0 | 1 | | ReadOnly | FALSE |
+| 183 | FG50_EA_M | Fiktiivinen mittaus, LTO:n hyötysuhde | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 184 | FILTER_STATE_FI | Fiktiivinen asetus, Suodattimen kunto (0=Idle, 1=Kuittaa vaihto, 2=Muistutushälytys) | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0 | 1 | 0 | 2 | | ReadWrite | FALSE |
+| 185 | SENSOR_STATUS | Yhdistelmäanturin tila (1=Ok, 0=Initoimatta, -1=Modbuskommunikaatiovirhe, -2=Data puuttuu) | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0 | 1 | -2 | 1 | | ReadOnly | FALSE |
+| 189 | SUMMER_MODE_I | Tilatieto, Kausi. 0=Talvi, 1=Väli, 2=Kesä | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0 | 1 | 0 | 2 | | ReadOnly | FALSE |
+| 190 | SUMMER_POWER_CHANGE_F | Kesätilanteen tehonsäätö | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0 | 1 | -1 | 1 | | ReadOnly | FALSE |
+| 191 | HUMIDITY_FM | Laskettu kosteus | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0.00 | 100 | 0.00 | 100.00 | g/kg | ReadOnly | FALSE |
+| 192 | ME05_AVG_FM | Fiktiivinen mittaus, LTO:n kosteusmittauksen 24h keskiarvo | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 199 | PWR_LIMIT_FY | Fiktiivinen säätö, puhaltimien tehonrajoitus | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0.0 | 10 | 0.0 | 100.0 | % | ReadOnly | FALSE |
+| 213 | TE01_AVG_FM | Ulkolämpötilan vrk keskiarvo | 6 SOFT MEASUREMENTS AND CONTROL POINTS | 0.0 | 10 | -50.0 | 50.0 | °C | ReadWrite | FALSE |
+
+## 7 ALARMS
+
+| Rekisteri | ID | Kommentti | Ryhmä | Tehdasasetus | Kerroin | MinLimit | MaxLimit | Yksikkö | Käyttöoikeus | Double |
+|-----------|-----|-----------|-------|--------------|---------|----------|----------|---------|--------------|--------|
+| 220 | TE01_FA | Vikahälytys, raitisilman lämpötila / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 221 | TE10_FA | Vikahälytys, tulolämpötila / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 222 | TE05_FA | Vikahälytys, tulolämpötila LTO:n jälkeen / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 223 | TE30_FA | Vikahälytys, poistolämpötila / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 224 | TE31_FA | Vikahälytys, jäteilman lämpötila / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 225 | ME05_FA | Vikahälytys, LTO:n kosteus / anturivika | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 226 | TF10_CA | Ristiriitahälytys, tulopuhallin | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 227 | PF30_CA | Ristiriitahälytys, poistopuhallin | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 228 | TE10_HA | Ylärajahälytys, tulolämpötila | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 229 | TE30_HA | Ylärajahälytys, poistolämpötila | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 230 | TE10_LA | Alarajahälytys, tulolämpötila | 7 ALARMS | 0 | 1 | 0 | 11 | | ReadOnly | FALSE |
+| 240 | FILTER_FA | Suodattimen hälytys | 7 ALARMS | 0 | 1 | 0 | 1 | | ReadOnly | FALSE |
+

From 0da59bee3aca75a5a4df09a48d2fdb6722bd222c Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 20:42:08 +0200
Subject: [PATCH 02/15] Add register dump, discovery, and interpretation tools

---
 tools/README.md                    | 141 +++++
 tools/discover_registers.py        | 240 +++++++++
 tools/dump_registers.py            | 362 +++++++++++++
 tools/mock_coordinator.py          | 251 +++++++++
 tools/test_fixtures/README.md      |  78 +++
 tools/test_fixtures/mac120_v2.json | 411 +++++++++++++++
 tools/test_interpretation.py       | 816 +++++++++++++++++++++++++++++
 7 files changed, 2299 insertions(+)
 create mode 100644 tools/README.md
 create mode 100644 tools/discover_registers.py
 create mode 100644 tools/dump_registers.py
 create mode 100644 tools/mock_coordinator.py
 create mode 100644 tools/test_fixtures/README.md
 create mode 100644 tools/test_fixtures/mac120_v2.json
 create mode 100644 tools/test_interpretation.py

diff --git a/tools/README.md b/tools/README.md
new file mode 100644
index 0000000..0d5346e
--- /dev/null
+++ b/tools/README.md
@@ -0,0 +1,141 @@
+# Parmair Test Tools
+
+This directory contains standalone tools for testing the Parmair integration
+without requiring Home Assistant.
+
+## Overview
+
+```
+tools/
+├── dump_registers.py      # Dump device registers to JSON
+├── mock_coordinator.py    # Mock coordinator for testing
+├── test_interpretation.py # Test data interpretation
+├── dumps/                 # Your device dumps (gitignored)
+└── test_fixtures/         # Sample test data
+```
+
+## Quick Start
+
+### 1. Dump Your Device Data
+
+Connect to your Parmair ventilation unit and dump all register values:
+
+```bash
+# Basic usage
+python dump_registers.py 192.168.1.100
+
+# With options
+python dump_registers.py 192.168.1.100 --port 502 --slave-id 1 --version 1.x
+
+# Save to specific file
+python dump_registers.py 192.168.1.100 --output my_device.json
+
+# Verbose output
+python dump_registers.py 192.168.1.100 --verbose
+```
+
+The output is a JSON file containing:
+- Device metadata (timestamp, detected version, hardware type)
+- All register values (raw and scaled)
+
+### 2. Test Interpretation
+
+Verify the integration correctly interprets your device data:
+
+```bash
+# Test a specific dump file
+python test_interpretation.py dumps/my_device.json
+
+# Show raw values
+python test_interpretation.py dumps/my_device.json --verbose
+
+# Test all fixtures
+python test_interpretation.py --all
+```
+
+### 3. Share Test Data
+
+If you want to contribute test data:
+
+1. Dump your device: `python dump_registers.py <ip> --output test_fixtures/macXXX_vX.json`
+2. Optionally anonymize the host IP in the JSON
+3. Run tests: `python test_interpretation.py test_fixtures/macXXX_vX.json`
+4. Submit a PR with your fixture
+
+## Requirements
+
+- Python 3.9+
+- pymodbus (same as the integration)
+
+Install dependencies:
+```bash
+pip install pymodbus
+```
+
+## Tools Reference
+
+### dump_registers.py
+
+Reads all Modbus registers from a Parmair device and saves them to JSON.
+
+```
+Usage: dump_registers.py <host> [options]
+
+Arguments:
+  host                 IP address of the Parmair device
+
+Options:
+  --port, -p          Modbus TCP port (default: 502)
+  --slave-id, -s      Modbus slave ID (default: 1)
+  --version, -V       Register map version: 1.x or 2.x (default: 1.x)
+  --output, -o        Output file path
+  --verbose, -v       Show detailed output
+```
+
+### test_interpretation.py
+
+Tests that register values are correctly interpreted.
+
+```
+Usage: test_interpretation.py [file] [options]
+
+Arguments:
+  file                JSON dump file to test
+
+Options:
+  --all, -a           Test all files in test_fixtures/ and dumps/
+  --verbose, -v       Show raw register values
+```
+
+### mock_coordinator.py
+
+A standalone mock of `ParmairCoordinator` for use in custom tests.
+
+```python
+from mock_coordinator import MockCoordinator, load_dump
+
+# Load from file
+coord = load_dump("dumps/my_device.json")
+
+# Access data
+print(coord.data)  # Scaled values
+print(coord.get_raw_value("fresh_air_temp"))  # Raw value
+print(coord.device_info)  # Device info dict
+
+# Or create from dict for unit tests
+coord = MockCoordinator.from_dict({
+    "power": 3,
+    "control_state": 2,
+    "fresh_air_temp": -5.0,
+})
+```
+
+## Firmware Versions
+
+The integration supports two firmware versions with different register maps:
+
+- **1.x** - Original firmware, uses registers like `POWER_BTN_FI`, `IV01_CONTROLSTATE_FO`
+- **2.x** - Newer firmware, uses `UNIT_CONTROL_FO`, `USERSTATECONTROL_FO`
+
+The dump tool will detect the firmware version automatically from the
+`software_version` register and record it in the metadata.
diff --git a/tools/discover_registers.py b/tools/discover_registers.py
new file mode 100644
index 0000000..f27b2ae
--- /dev/null
+++ b/tools/discover_registers.py
@@ -0,0 +1,240 @@
+#!/usr/bin/env python3
+"""Discover all readable Modbus registers on a Parmair device.
+
+This tool scans a range of register addresses and reports which ones
+return valid data. Use this to discover undocumented registers.
+
+Usage:
+    python discover_registers.py <host> [--start 1000] [--end 1300]
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import sys
+from datetime import datetime
+from pathlib import Path
+
+from pymodbus.client import ModbusTcpClient
+
+# Known V2 documented registers (from v2_register.md)
+V2_DOCUMENTED = {
+    1003: "ACK_ALARMS",
+    1004: "ALARM_COUNT",
+    1009: "TIME_YEAR",
+    1010: "TIME_MONTH",
+    1011: "TIME_DAY",
+    1012: "TIME_HOUR",
+    1013: "TIME_MIN",
+    1014: "MULTI_FW_VER",
+    1015: "MULTI_SW_VER",
+    1016: "MULTI_BL_VER",
+    1020: "TE01_M",
+    1021: "TE05_M",
+    1022: "TE10_M",
+    1023: "TE31_M",
+    1024: "TE30_M",
+    1025: "ME05_M",
+    1026: "QE05_M",
+    1027: "TF10_I",
+    1028: "PF30_I",
+    1029: "ME20_M",
+    1030: "QE20_M",
+    1031: "EXTERNAL_M",
+    1035: "EXTERNAL_BOOST_M",
+    1036: "TE10_DEFECTION_M",
+    1040: "TF10_Y",
+    1042: "PF30_Y",
+    1044: "TV45_Y",
+    1046: "FG50_Y",
+    1048: "EC05_Y",
+    1050: "HP_RAD_O",
+    1060: "HOME_SPEED_S",
+    1061: "TE10_MIN_HOME_S",
+    1062: "TE10_CONTROL_MODE_S",
+    1063: "AWAY_SPEED_S",
+    1064: "TE10_MIN_AWAY_S",
+    1065: "BOOST_SETTING_S",
+    1068: "OVERP_AMOUNT_S",
+    1070: "TP_ENABLE_S",
+    1071: "AUTO_SUMMER_COOL_S",
+    1072: "AUTO_SUMMER_POWER_S",
+    1073: "TE30_S",
+    1074: "AUTO_HEATER_ENABLE_S",
+    1075: "AUTO_COLD_LOWSPEED_S",
+    1076: "COLD_LOWSPEED_S",
+    1077: "AUTO_HUMIDITY_BOOST_S",
+    1078: "ME05_BOOST_SENSITIVITY",
+    1079: "ME_BST_TE01_LIMIT",
+    1080: "AUTO_CO2_BOOST_S",
+    1081: "AUTO_HOMEAWAY_S",
+    1082: "QE_HOME_S",
+    1083: "QE_BOOST_S",
+    1090: "FILTER_INTERVAL_S",
+    1091: "HP_RAD_MODE",
+    1092: "HP_RAD_WINTER",
+    1093: "HP_RAD_SUMMER",
+    1094: "HEATING_SEASON_AVERAGE",
+    1095: "HEATING_SEASON_MOMENT",
+    1096: "TE10_MIN_SUMMER_S",
+    1097: "TE10_MAX_S",
+    1098: "BST_TE01_LIMIT",
+    1105: "M10_TYPE",
+    1106: "M11_TYPE",
+    1107: "M12_TYPE",
+    1108: "SF_SPEED1_S",
+    1109: "SF_SPEED2_S",
+    1110: "SF_SPEED3_S",
+    1111: "SF_SPEED4_S",
+    1112: "SF_SPEED5_S",
+    1113: "EF_SPEED1_S",
+    1114: "EF_SPEED2_S",
+    1115: "EF_SPEED3_S",
+    1116: "EF_SPEED4_S",
+    1117: "EF_SPEED5_S",
+    1120: "SENSOR_TE_COR",
+    1121: "SENSOR_ME_COR",
+    1122: "SENSOR_CO2_COR",
+    1124: "HEATPUMP_RADIATOR_ENABLE",
+    1125: "VENT_MACHINE",
+    1129: "TE10_MIN_S",
+    1137: "TE10_BASE_S",
+    1140: "BST_MINTIME",
+    1141: "CO2_MINTIME",
+    1144: "BST_TIME_LIMIT",
+    1180: "UNIT_CONTROL_FO",
+    1181: "USERSTATECONTROL_FO",
+    1182: "DFRST_FI",
+    1183: "FG50_EA_M",
+    1184: "FILTER_STATE_FI",
+    1185: "SENSOR_STATUS",
+    1189: "SUMMER_MODE_I",
+    1190: "SUMMER_POWER_CHANGE_F",
+    1191: "HUMIDITY_FM",
+    1192: "ME05_AVG_FM",
+    1199: "PWR_LIMIT_FY",
+    1213: "TE01_AVG_FM",
+    1220: "TE01_FA",
+    1221: "TE10_FA",
+    1222: "TE05_FA",
+    1223: "TE30_FA",
+    1224: "TE31_FA",
+    1225: "ME05_FA",
+    1226: "TF10_CA",
+    1227: "PF30_CA",
+    1228: "TE10_HA",
+    1229: "TE30_HA",
+    1230: "TE10_LA",
+    1240: "FILTER_FA",
+}
+
+
+def read_register(client: ModbusTcpClient, address: int, slave_id: int) -> int | None:
+    """Try to read a single register."""
+    try:
+        # pymodbus 3.11+ API
+        result = client.read_holding_registers(address, count=1, slave=slave_id)
+    except TypeError:
+        try:
+            # Try device_id instead of slave
+            result = client.read_holding_registers(address, count=1, device_id=slave_id)
+        except TypeError:
+            try:
+                # Older API with positional args
+                result = client.read_holding_registers(address, 1, unit=slave_id)
+            except TypeError:
+                return None
+    
+    try:
+        if hasattr(result, 'isError') and result.isError():
+            return None
+        if hasattr(result, 'registers') and result.registers:
+            return result.registers[0]
+        return None
+    except Exception:
+        return None
+
+
+def main():
+    parser = argparse.ArgumentParser(description="Discover Modbus registers on Parmair device")
+    parser.add_argument("host", help="Device IP address")
+    parser.add_argument("--port", type=int, default=502, help="Modbus port (default: 502)")
+    parser.add_argument("--slave", type=int, default=1, help="Slave ID (default: 1)")
+    parser.add_argument("--start", type=int, default=1000, help="Start address (default: 1000)")
+    parser.add_argument("--end", type=int, default=1300, help="End address (default: 1300)")
+    parser.add_argument("--output", type=str, help="Output JSON file")
+    
+    args = parser.parse_args()
+    
+    print(f"Connecting to {args.host}:{args.port}...")
+    client = ModbusTcpClient(args.host, port=args.port)
+    
+    if not client.connect():
+        print("Failed to connect!")
+        sys.exit(1)
+    
+    print(f"Scanning registers {args.start} to {args.end}...")
+    print()
+    
+    documented = []
+    undocumented = []
+    
+    for addr in range(args.start, args.end + 1):
+        value = read_register(client, addr, args.slave)
+        
+        if value is not None:
+            is_documented = addr in V2_DOCUMENTED
+            label = V2_DOCUMENTED.get(addr, "???")
+            status = "✓" if is_documented else "?"
+            
+            entry = {
+                "address": addr,
+                "value": value,
+                "label": label,
+                "documented": is_documented,
+            }
+            
+            if is_documented:
+                documented.append(entry)
+            else:
+                undocumented.append(entry)
+            
+            # Print progress
+            print(f"  {status} {addr:4d}: {value:6d}  {label}")
+    
+    client.close()
+    
+    print()
+    print("=" * 60)
+    print(f"SUMMARY")
+    print("=" * 60)
+    print(f"Documented registers found: {len(documented)}")
+    print(f"Undocumented registers found: {len(undocumented)}")
+    print()
+    
+    if undocumented:
+        print("UNDOCUMENTED REGISTERS (need investigation):")
+        print("-" * 60)
+        for entry in undocumented:
+            print(f"  Address {entry['address']:4d}: value={entry['value']:6d}")
+    
+    # Save to file if requested
+    if args.output:
+        output_data = {
+            "host": args.host,
+            "timestamp": datetime.now().isoformat(),
+            "scan_range": {"start": args.start, "end": args.end},
+            "documented": documented,
+            "undocumented": undocumented,
+        }
+        
+        output_path = Path(args.output)
+        with open(output_path, "w") as f:
+            json.dump(output_data, f, indent=2)
+        print(f"\nResults saved to: {output_path}")
+
+
+if __name__ == "__main__":
+    main()
+
diff --git a/tools/dump_registers.py b/tools/dump_registers.py
new file mode 100644
index 0000000..f616c08
--- /dev/null
+++ b/tools/dump_registers.py
@@ -0,0 +1,362 @@
+#!/usr/bin/env python3
+"""Dump all Modbus registers from a Parmair device to a JSON file.
+
+This tool reads all registers from a real Parmair ventilation unit
+and saves them to a JSON file for offline testing.
+
+Usage:
+    python dump_registers.py <host> [options]
+
+Examples:
+    python dump_registers.py 192.168.1.100
+    python dump_registers.py 192.168.1.100 --output dumps/my_device.json
+    python dump_registers.py 192.168.1.100 --port 502 --slave-id 1 --version 2.x
+"""
+
+from __future__ import annotations
+
+import argparse
+import json
+import sys
+import time
+from dataclasses import asdict, dataclass
+from datetime import datetime
+from pathlib import Path
+from typing import Any
+
+# Add parent directory to path to import from custom_components
+sys.path.insert(0, str(Path(__file__).parent.parent))
+import importlib.util
+
+from pymodbus.client import ModbusTcpClient
+from pymodbus.exceptions import ModbusException
+
+# Import const.py directly to avoid homeassistant dependency in __init__.py
+_const_path = Path(__file__).parent.parent / "custom_components" / "parmair" / "const.py"
+_spec = importlib.util.spec_from_file_location("parmair_const", _const_path)
+_const = importlib.util.module_from_spec(_spec)
+sys.modules["parmair_const"] = _const  # Register module to fix dataclass issues
+_spec.loader.exec_module(_const)
+
+POLLING_REGISTER_KEYS = _const.POLLING_REGISTER_KEYS
+SOFTWARE_VERSION_1 = _const.SOFTWARE_VERSION_1
+SOFTWARE_VERSION_2 = _const.SOFTWARE_VERSION_2
+RegisterDefinition = _const.RegisterDefinition
+get_registers_for_version = _const.get_registers_for_version
+
+
+@dataclass
+class RegisterDump:
+    """Container for a single register dump."""
+
+    key: str
+    address: int
+    label: str
+    raw: int | None
+    scaled: float | int | None
+    scale: float
+    optional: bool
+    writable: bool
+
+
+@dataclass
+class DeviceDump:
+    """Container for complete device dump."""
+
+    metadata: dict[str, Any]
+    registers: dict[str, dict[str, Any]]
+
+    def to_json(self) -> str:
+        """Convert to JSON string."""
+        return json.dumps(
+            {"metadata": self.metadata, "registers": self.registers},
+            indent=2,
+            ensure_ascii=False,
+        )
+
+    @classmethod
+    def from_json(cls, json_str: str) -> "DeviceDump":
+        """Create from JSON string."""
+        data = json.loads(json_str)
+        return cls(metadata=data["metadata"], registers=data["registers"])
+
+
+def read_single_register(
+    client: ModbusTcpClient,
+    definition: RegisterDefinition,
+    slave_id: int,
+) -> tuple[int | None, float | int | None]:
+    """Read a single register and return (raw, scaled) values."""
+    # pymodbus 3.11+ uses: address (positional), count= (keyword), device_id= (keyword)
+    try:
+        result = client.read_holding_registers(definition.address, count=1, device_id=slave_id)
+    except TypeError:
+        # Fallback for older pymodbus versions
+        try:
+            result = client.read_holding_registers(definition.address, 1, slave=slave_id)
+        except TypeError:
+            try:
+                result = client.read_holding_registers(definition.address, 1, unit=slave_id)
+            except TypeError:
+                client.slave = slave_id
+                result = client.read_holding_registers(definition.address, 1)
+
+    if not result or (hasattr(result, "isError") and result.isError()):
+        return None, None
+
+    if hasattr(result, "registers"):
+        raw = result.registers[0]
+    elif isinstance(result, (list, tuple)):
+        raw = result[0]
+    else:
+        raw = result
+
+    # Convert to signed int16 if value is > 32767 (handle negative temperatures)
+    if raw > 32767:
+        raw = raw - 65536
+
+    # Check if optional sensor is not installed
+    if definition.optional and raw < 0:
+        return raw, None
+
+    # Apply scaling
+    if definition.scale == 1:
+        scaled = raw
+    else:
+        scaled = raw * definition.scale
+
+    return raw, scaled
+
+
+def read_register_with_retry(
+    client: ModbusTcpClient,
+    definition: RegisterDefinition,
+    slave_id: int,
+    max_attempts: int = 3,
+    retry_delay: float = 0.5,
+) -> tuple[int | None, float | int | None]:
+    """Read a single register with retries on failure (e.g. transaction_id mismatch)."""
+    for attempt in range(max_attempts):
+        if attempt > 0:
+            time.sleep(retry_delay)
+        raw, scaled = read_single_register(client, definition, slave_id)
+        if raw is not None:
+            return raw, scaled
+    return None, None
+
+
+def dump_device(
+    host: str,
+    port: int = 502,
+    slave_id: int = 1,
+    software_version: str = SOFTWARE_VERSION_1,
+    verbose: bool = False,
+) -> DeviceDump:
+    """Connect to device and dump all registers."""
+    print(f"Connecting to Parmair device at {host}:{port} (slave ID: {slave_id})")
+    print(f"Using register map for software version: {software_version}")
+
+    client = ModbusTcpClient(host=host, port=port)
+
+    if not client.connect():
+        raise ModbusException(f"Failed to connect to {host}:{port}")
+
+    print("✓ Connected successfully\n")
+
+    # Longer delay after connect to allow device to stabilize and prevent transaction_id mismatch
+    time.sleep(0.3)
+
+    # Get version-specific register map
+    registers = get_registers_for_version(software_version)
+
+    # First, try to detect actual software version if we're on auto
+    detected_version = None
+    detected_hw_type = None
+
+    try:
+        # Read software version register
+        sw_def = registers.get("software_version")
+        if sw_def:
+            raw, scaled = read_register_with_retry(
+                client, sw_def, slave_id, max_attempts=3, retry_delay=0.5
+            )
+            if scaled is not None:
+                detected_version = scaled
+                print(f"Detected software version: {detected_version}")
+
+        # Read hardware type register
+        hw_def = registers.get("hardware_type")
+        if hw_def:
+            time.sleep(0.25)  # Delay between reads to prevent transaction ID conflicts
+            raw, scaled = read_register_with_retry(
+                client, hw_def, slave_id, max_attempts=3, retry_delay=0.5
+            )
+            if scaled is not None:
+                detected_hw_type = int(scaled)
+                print(f"Detected hardware type: MAC {detected_hw_type}")
+
+    except Exception as e:
+        print(f"Warning: Could not auto-detect device info: {e}")
+
+    print("\nReading registers...")
+
+    register_dumps: dict[str, dict[str, Any]] = {}
+    failed_count = 0
+    success_count = 0
+
+    for key in POLLING_REGISTER_KEYS:
+        if key not in registers:
+            if verbose:
+                print(f"  [SKIP] {key}: Not in register map for {software_version}")
+            continue
+
+        definition = registers[key]
+        time.sleep(0.25)  # Delay between reads to prevent transaction_id mismatch
+
+        raw, scaled = read_register_with_retry(
+            client, definition, slave_id, max_attempts=3, retry_delay=0.5
+        )
+
+        if raw is None:
+            failed_count += 1
+            if verbose:
+                print(f"  [FAIL] {key} (addr {definition.address}): Read failed")
+            register_dumps[key] = {
+                "address": definition.address,
+                "label": definition.label,
+                "raw": None,
+                "scaled": None,
+                "scale": definition.scale,
+                "optional": definition.optional,
+                "writable": definition.writable,
+                "error": "Read failed",
+            }
+        else:
+            success_count += 1
+            if verbose:
+                scaled_str = f"{scaled}" if scaled is not None else "N/A"
+                print(
+                    f"  [OK]   {key} (addr {definition.address}): "
+                    f"raw={raw}, scaled={scaled_str}"
+                )
+            register_dumps[key] = {
+                "address": definition.address,
+                "label": definition.label,
+                "raw": raw,
+                "scaled": scaled,
+                "scale": definition.scale,
+                "optional": definition.optional,
+                "writable": definition.writable,
+            }
+
+    client.close()
+
+    print(f"\n✓ Read {success_count} registers successfully")
+    if failed_count > 0:
+        print(f"✗ Failed to read {failed_count} registers")
+
+    # Build metadata
+    metadata = {
+        "timestamp": datetime.now().isoformat(),
+        "host": host,
+        "port": port,
+        "slave_id": slave_id,
+        "register_map_version": software_version,
+        "detected_software_version": detected_version,
+        "detected_hardware_type": detected_hw_type,
+        "registers_read": success_count,
+        "registers_failed": failed_count,
+    }
+
+    return DeviceDump(metadata=metadata, registers=register_dumps)
+
+
+def main():
+    """Main entry point."""
+    parser = argparse.ArgumentParser(
+        description="Dump Modbus registers from a Parmair device to JSON",
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+        epilog="""
+Examples:
+    %(prog)s 192.168.1.100
+    %(prog)s 192.168.1.100 --output dumps/my_device.json
+    %(prog)s 192.168.1.100 --version 2.x --verbose
+        """,
+    )
+    parser.add_argument("host", help="IP address or hostname of the Parmair device")
+    parser.add_argument(
+        "--port", "-p", type=int, default=502, help="Modbus TCP port (default: 502)"
+    )
+    parser.add_argument(
+        "--slave-id", "-s", type=int, default=1, help="Modbus slave ID (default: 1)"
+    )
+    parser.add_argument(
+        "--version",
+        "-V",
+        choices=["1.x", "2.x"],
+        default="1.x",
+        help="Register map version to use (default: 1.x)",
+    )
+    parser.add_argument(
+        "--output",
+        "-o",
+        type=Path,
+        help="Output JSON file path (default: dumps/<host>_<timestamp>.json)",
+    )
+    parser.add_argument(
+        "--verbose", "-v", action="store_true", help="Show detailed register readings"
+    )
+
+    args = parser.parse_args()
+
+    # Determine output path
+    if args.output:
+        output_path = args.output
+    else:
+        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
+        safe_host = args.host.replace(".", "_")
+        output_dir = Path(__file__).parent / "dumps"
+        output_dir.mkdir(exist_ok=True)
+        output_path = output_dir / f"{safe_host}_{timestamp}.json"
+
+    try:
+        dump = dump_device(
+            host=args.host,
+            port=args.port,
+            slave_id=args.slave_id,
+            software_version=args.version,
+            verbose=args.verbose,
+        )
+
+        # Ensure output directory exists
+        output_path.parent.mkdir(parents=True, exist_ok=True)
+
+        # Write JSON file
+        with open(output_path, "w", encoding="utf-8") as f:
+            f.write(dump.to_json())
+
+        print(f"\n✓ Dump saved to: {output_path}")
+
+        # Print summary
+        print("\n" + "=" * 50)
+        print("DUMP SUMMARY")
+        print("=" * 50)
+        print(f"Device: {args.host}:{args.port}")
+        if dump.metadata.get("detected_software_version"):
+            print(f"Software Version: {dump.metadata['detected_software_version']}")
+        if dump.metadata.get("detected_hardware_type"):
+            print(f"Hardware Type: MAC {dump.metadata['detected_hardware_type']}")
+        print(f"Registers: {dump.metadata['registers_read']} read, {dump.metadata['registers_failed']} failed")
+        print(f"Output: {output_path}")
+
+    except ModbusException as e:
+        print(f"\n✗ Modbus error: {e}", file=sys.stderr)
+        sys.exit(1)
+    except Exception as e:
+        print(f"\n✗ Error: {e}", file=sys.stderr)
+        sys.exit(1)
+
+
+if __name__ == "__main__":
+    main()
+
diff --git a/tools/mock_coordinator.py b/tools/mock_coordinator.py
new file mode 100644
index 0000000..af4d1ea
--- /dev/null
+++ b/tools/mock_coordinator.py
@@ -0,0 +1,251 @@
+"""Mock coordinator for testing Parmair integration without Home Assistant.
+
+This module provides a MockCoordinator that loads register data from JSON dumps
+and provides the same interface as the real ParmairCoordinator, allowing
+offline testing of entity interpretation logic.
+
+Usage:
+    from mock_coordinator import MockCoordinator
+    
+    coord = MockCoordinator.from_file("dumps/my_device.json")
+    print(coord.data)  # Access parsed register values
+"""
+
+from __future__ import annotations
+
+import json
+from dataclasses import dataclass
+from pathlib import Path
+from typing import Any
+
+import sys
+import importlib.util
+
+# Add parent directory to path to import from custom_components
+sys.path.insert(0, str(Path(__file__).parent.parent))
+
+# Import const.py directly to avoid homeassistant dependency in __init__.py
+_const_path = Path(__file__).parent.parent / "custom_components" / "parmair" / "const.py"
+_spec = importlib.util.spec_from_file_location("parmair_const", _const_path)
+_const = importlib.util.module_from_spec(_spec)
+sys.modules["parmair_const"] = _const  # Register module to fix dataclass issues
+_spec.loader.exec_module(_const)
+
+SOFTWARE_VERSION_1 = _const.SOFTWARE_VERSION_1
+SOFTWARE_VERSION_2 = _const.SOFTWARE_VERSION_2
+RegisterDefinition = _const.RegisterDefinition
+get_register_definition = _const.get_register_definition
+get_registers_for_version = _const.get_registers_for_version
+
+
+@dataclass
+class MockDeviceInfo:
+    """Mock device info matching HA's device_info structure."""
+
+    identifiers: set
+    name: str
+    manufacturer: str
+    model: str
+    sw_version: str | None = None
+
+
+class MockCoordinator:
+    """Mock coordinator that loads data from a JSON dump file.
+    
+    This provides the same interface as ParmairCoordinator but without
+    any Home Assistant dependencies, making it suitable for offline testing.
+    """
+
+    def __init__(
+        self,
+        data: dict[str, Any],
+        metadata: dict[str, Any],
+        registers: dict[str, dict[str, Any]],
+        software_version: str = SOFTWARE_VERSION_1,
+    ) -> None:
+        """Initialize the mock coordinator.
+        
+        Args:
+            data: The processed register data (key -> scaled value)
+            metadata: Dump metadata (timestamp, host, etc.)
+            registers: Raw register dump data
+            software_version: Software version for register map selection
+        """
+        self._data = data
+        self._metadata = metadata
+        self._raw_registers = registers
+        self._software_version = software_version
+        self._registers = get_registers_for_version(software_version)
+
+    @property
+    def data(self) -> dict[str, Any]:
+        """Return the processed register data."""
+        return self._data
+
+    @property
+    def metadata(self) -> dict[str, Any]:
+        """Return the dump metadata."""
+        return self._metadata
+
+    @property
+    def raw_registers(self) -> dict[str, dict[str, Any]]:
+        """Return the raw register data including addresses and labels."""
+        return self._raw_registers
+
+    @property
+    def software_version(self) -> str:
+        """Return the software version string."""
+        return self._software_version
+
+    @property
+    def device_info(self) -> dict[str, Any]:
+        """Return device information (compatible with HA device_info)."""
+        sw_version = self._data.get("software_version")
+        hw_type = self._data.get("hardware_type")
+
+        model = "MAC"
+        if hw_type is not None:
+            model = f"MAC {int(hw_type)}"
+
+        device_info = {
+            "identifiers": {("parmair", "mock_device")},
+            "name": f"Parmair {model} (Mock)",
+            "manufacturer": "Parmair",
+            "model": model,
+        }
+
+        if sw_version is not None:
+            if isinstance(sw_version, (int, float)):
+                device_info["sw_version"] = f"{sw_version:.2f}"
+            else:
+                device_info["sw_version"] = str(sw_version)
+
+        return device_info
+
+    def get_register_definition(self, key: str) -> RegisterDefinition:
+        """Get register definition for a key."""
+        return get_register_definition(key, self._registers)
+
+    def get_raw_value(self, key: str) -> int | None:
+        """Get the raw (unscaled) value for a register key."""
+        if key in self._raw_registers:
+            return self._raw_registers[key].get("raw")
+        return None
+
+    @classmethod
+    def from_file(cls, filepath: str | Path) -> "MockCoordinator":
+        """Create a MockCoordinator from a JSON dump file.
+        
+        Args:
+            filepath: Path to the JSON dump file
+            
+        Returns:
+            MockCoordinator instance with loaded data
+        """
+        filepath = Path(filepath)
+        if not filepath.exists():
+            raise FileNotFoundError(f"Dump file not found: {filepath}")
+
+        with open(filepath, "r", encoding="utf-8") as f:
+            dump = json.load(f)
+
+        metadata = dump.get("metadata", {})
+        registers = dump.get("registers", {})
+
+        # Determine software version from metadata or detect from version register
+        software_version = metadata.get("register_map_version", SOFTWARE_VERSION_1)
+        
+        # Override if we have detected version that suggests different map
+        detected_ver = metadata.get("detected_software_version")
+        if detected_ver is not None:
+            if detected_ver >= 2.0:
+                software_version = SOFTWARE_VERSION_2
+            else:
+                software_version = SOFTWARE_VERSION_1
+
+        # Build data dict from scaled values
+        data: dict[str, Any] = {}
+        for key, reg_data in registers.items():
+            if reg_data.get("scaled") is not None:
+                data[key] = reg_data["scaled"]
+            elif reg_data.get("raw") is not None:
+                # For registers without scaling, use raw value
+                data[key] = reg_data["raw"]
+
+        return cls(
+            data=data,
+            metadata=metadata,
+            registers=registers,
+            software_version=software_version,
+        )
+
+    @classmethod
+    def from_dict(
+        cls,
+        data: dict[str, Any],
+        software_version: str = SOFTWARE_VERSION_1,
+    ) -> "MockCoordinator":
+        """Create a MockCoordinator from a data dictionary.
+        
+        This is useful for creating test fixtures with specific values.
+        
+        Args:
+            data: Dictionary of register key -> scaled value
+            software_version: Software version for register map
+            
+        Returns:
+            MockCoordinator instance
+        """
+        # Build register dict from data
+        registers_map = get_registers_for_version(software_version)
+        registers: dict[str, dict[str, Any]] = {}
+        
+        for key, value in data.items():
+            if key in registers_map:
+                reg_def = registers_map[key]
+                # Calculate raw value from scaled
+                if reg_def.scale == 1:
+                    raw = int(value) if value is not None else None
+                else:
+                    raw = int(round(value / reg_def.scale)) if value is not None else None
+                    
+                registers[key] = {
+                    "address": reg_def.address,
+                    "label": reg_def.label,
+                    "raw": raw,
+                    "scaled": value,
+                    "scale": reg_def.scale,
+                    "optional": reg_def.optional,
+                    "writable": reg_def.writable,
+                }
+
+        metadata = {
+            "source": "from_dict",
+            "register_map_version": software_version,
+        }
+
+        return cls(
+            data=data,
+            metadata=metadata,
+            registers=registers,
+            software_version=software_version,
+        )
+
+    def __repr__(self) -> str:
+        """Return string representation."""
+        source = self._metadata.get("host", self._metadata.get("source", "unknown"))
+        return f"MockCoordinator(source={source}, registers={len(self._data)})"
+
+
+# Convenience function for quick loading
+def load_dump(filepath: str | Path) -> MockCoordinator:
+    """Load a dump file and return a MockCoordinator.
+    
+    Args:
+        filepath: Path to the JSON dump file
+        
+    Returns:
+        MockCoordinator instance
+    """
+    return MockCoordinator.from_file(filepath)
+
diff --git a/tools/test_fixtures/README.md b/tools/test_fixtures/README.md
new file mode 100644
index 0000000..3c4b9b0
--- /dev/null
+++ b/tools/test_fixtures/README.md
@@ -0,0 +1,78 @@
+# Parmair Test Fixtures
+
+This directory contains sample JSON dump files from Parmair ventilation units.
+These files are used to test the integration's data interpretation logic without
+requiring access to a real device.
+
+## File Naming Convention
+
+Files should be named to describe the device:
+- `mac80_v1.json` - MAC 80 with firmware 1.x
+- `mac100_v1.json` - MAC 100 with firmware 1.x
+- `mac150_v2.json` - MAC 150 with firmware 2.x
+
+## Contributing Fixtures
+
+If you have a Parmair device, you can contribute test data:
+
+1. **Dump your device data:**
+
+   ```bash
+   cd tools
+   python dump_registers.py <your_device_ip> --output test_fixtures/macXXX_vX.json
+   ```
+
+2. **Review the dump** to ensure it doesn't contain sensitive network info
+   (the host IP is recorded but can be anonymized)
+
+3. **Test the fixture:**
+
+   ```bash
+   python test_interpretation.py test_fixtures/macXXX_vX.json --verbose
+   ```
+
+4. Submit a pull request with your fixture file
+
+## JSON Format
+
+Each fixture file contains:
+
+```json
+{
+  "metadata": {
+    "timestamp": "2026-01-10T12:00:00",
+    "host": "192.168.1.100",
+    "port": 502,
+    "slave_id": 1,
+    "register_map_version": "1.x",
+    "detected_software_version": 1.83,
+    "detected_hardware_type": 100
+  },
+  "registers": {
+    "register_key": {
+      "address": 1020,
+      "label": "TE01_M",
+      "raw": -50,
+      "scaled": -5.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    }
+  }
+}
+```
+
+## Testing
+
+Run tests against all fixtures:
+
+```bash
+python test_interpretation.py --all
+```
+
+Or test a specific file:
+
+```bash
+python test_interpretation.py test_fixtures/mac100_v1.json
+```
+
diff --git a/tools/test_fixtures/mac120_v2.json b/tools/test_fixtures/mac120_v2.json
new file mode 100644
index 0000000..96f1b79
--- /dev/null
+++ b/tools/test_fixtures/mac120_v2.json
@@ -0,0 +1,411 @@
+{
+  "metadata": {
+    "timestamp": "2026-02-09T23:20:19.035476",
+    "host": "192.168.3.222",
+    "port": 502,
+    "slave_id": 0,
+    "register_map_version": "2.x",
+    "detected_software_version": 2.25,
+    "detected_hardware_type": 112,
+    "registers_read": 45,
+    "registers_failed": 0
+  },
+  "registers": {
+    "power": {
+      "address": 1180,
+      "label": "UNIT_CONTROL_FO",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "control_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "actual_speed": {
+      "address": 1187,
+      "label": "IV01_SPEED_FO",
+      "raw": 3,
+      "scaled": 3,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "speed_control": {
+      "address": 1187,
+      "label": "IV01_SPEED_FO",
+      "raw": 3,
+      "scaled": 3,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "fresh_air_temp": {
+      "address": 1020,
+      "label": "TE01_M",
+      "raw": -37,
+      "scaled": -3.7,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "supply_after_recovery_temp": {
+      "address": 1021,
+      "label": "TE05_M",
+      "raw": 136,
+      "scaled": 13.600000000000001,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "supply_temp": {
+      "address": 1022,
+      "label": "TE10_M",
+      "raw": 183,
+      "scaled": 18.3,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_temp": {
+      "address": 1024,
+      "label": "TE30_M",
+      "raw": 195,
+      "scaled": 19.5,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "waste_temp": {
+      "address": 1023,
+      "label": "TE31_M",
+      "raw": 42,
+      "scaled": 4.2,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_temp_setpoint": {
+      "address": 1073,
+      "label": "TE30_S",
+      "raw": 210,
+      "scaled": 21.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": true
+    },
+    "supply_temp_setpoint": {
+      "address": 1061,
+      "label": "TE10_MIN_HOME_S",
+      "raw": 170,
+      "scaled": 17.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": true
+    },
+    "home_speed": {
+      "address": 1060,
+      "label": "HOME_SPEED_S",
+      "raw": 3,
+      "scaled": 3,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "away_speed": {
+      "address": 1063,
+      "label": "AWAY_SPEED_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "home_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "boost_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "boost_timer": {
+      "address": 1200,
+      "label": "BOOST_TIMER_FM",
+      "raw": -1,
+      "scaled": -1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "overpressure_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "overpressure_timer": {
+      "address": 1201,
+      "label": "OVERP_TIMER_FM",
+      "raw": -1,
+      "scaled": -1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "humidity": {
+      "address": 1025,
+      "label": "ME05_M",
+      "raw": 24,
+      "scaled": 24,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "humidity_24h_avg": {
+      "address": 1192,
+      "label": "ME05_AVG_FM",
+      "raw": 256,
+      "scaled": 25.6,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "co2_exhaust": {
+      "address": 1026,
+      "label": "QE05_M",
+      "raw": 605,
+      "scaled": 605,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "lto_heat_recovery_control": {
+      "address": 1046,
+      "label": "FG50_Y",
+      "raw": 1000,
+      "scaled": 100.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "alarm_count": {
+      "address": 1004,
+      "label": "ALARM_COUNT",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "sum_alarm": {
+      "address": 1005,
+      "label": "SUM_ALARM",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "alarms_state": {
+      "address": 1204,
+      "label": "ALARMS_STATE_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "heat_recovery_efficiency": {
+      "address": 1183,
+      "label": "FG50_EA_M",
+      "raw": 659,
+      "scaled": 65.9,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "defrost_state": {
+      "address": 1182,
+      "label": "DFRST_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "supply_fan_speed": {
+      "address": 1040,
+      "label": "TF10_Y",
+      "raw": 500,
+      "scaled": 50.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_fan_speed": {
+      "address": 1042,
+      "label": "PF30_Y",
+      "raw": 640,
+      "scaled": 64.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "filter_state": {
+      "address": 1184,
+      "label": "FILTER_STATE_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "filter_day": {
+      "address": 1193,
+      "label": "FILTER_DAY",
+      "raw": 25,
+      "scaled": 25,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_month": {
+      "address": 1194,
+      "label": "FILTER_MONTH",
+      "raw": 12,
+      "scaled": 12,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_year": {
+      "address": 1195,
+      "label": "FILTER_YEAR",
+      "raw": 2025,
+      "scaled": 2025,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_day": {
+      "address": 1196,
+      "label": "FILTERNEXT_DAY",
+      "raw": 25,
+      "scaled": 25,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_month": {
+      "address": 1197,
+      "label": "FILTERNEXT_MONTH",
+      "raw": 4,
+      "scaled": 4,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_year": {
+      "address": 1198,
+      "label": "FILTERNEXT_YEAR",
+      "raw": 2026,
+      "scaled": 2026,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "summer_mode": {
+      "address": 1071,
+      "label": "AUTO_SUMMER_COOL_S",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "time_program_enable": {
+      "address": 1070,
+      "label": "TP_ENABLE_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "heater_enable": {
+      "address": 1074,
+      "label": "AUTO_HEATER_ENABLE_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "boost_time_setting": {
+      "address": 1066,
+      "label": "BOOST_TIME_S",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "overpressure_time_setting": {
+      "address": 1069,
+      "label": "OVERP_TIME_S",
+      "raw": 5,
+      "scaled": 5,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "summer_mode_temp_limit": {
+      "address": 1073,
+      "label": "TE30_S",
+      "raw": 210,
+      "scaled": 21.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": true
+    },
+    "boost_setting": {
+      "address": 1065,
+      "label": "BOOST_SETTING_S",
+      "raw": 4,
+      "scaled": 4,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_interval": {
+      "address": 1090,
+      "label": "FILTER_INTERVAL_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    }
+  }
+}
\ No newline at end of file
diff --git a/tools/test_interpretation.py b/tools/test_interpretation.py
new file mode 100644
index 0000000..fc8969b
--- /dev/null
+++ b/tools/test_interpretation.py
@@ -0,0 +1,816 @@
+#!/usr/bin/env python3
+"""Test Parmair integration data interpretation using dump files.
+
+This tool validates that the integration correctly interprets register values
+from Parmair devices. It loads JSON dump files and tests all sensor/entity
+interpretation logic without requiring Home Assistant.
+
+Usage:
+    python test_interpretation.py <dump_file>
+    python test_interpretation.py --all
+    python test_interpretation.py dumps/my_device.json --verbose
+
+Examples:
+    python test_interpretation.py dumps/192_168_1_100_20260110.json
+    python test_interpretation.py test_fixtures/mac100_v1.json
+    python test_interpretation.py --all  # Test all fixture files
+"""
+
+from __future__ import annotations
+
+import argparse
+import sys
+from dataclasses import dataclass
+from pathlib import Path
+from typing import Any, Callable
+
+# Add parent directory to path
+sys.path.insert(0, str(Path(__file__).parent.parent))
+import importlib.util
+
+from tools.mock_coordinator import MockCoordinator, load_dump
+
+# Import const.py directly to avoid homeassistant dependency in __init__.py
+_const_path = Path(__file__).parent.parent / "custom_components" / "parmair" / "const.py"
+_spec = importlib.util.spec_from_file_location("parmair_const", _const_path)
+_const = importlib.util.module_from_spec(_spec)
+sys.modules["parmair_const"] = _const  # Register module to fix dataclass issues
+_spec.loader.exec_module(_const)
+
+HARDWARE_TYPE_MAP_V2 = _const.HARDWARE_TYPE_MAP_V2
+HEATER_TYPE_ELECTRIC = _const.HEATER_TYPE_ELECTRIC
+HEATER_TYPE_NONE = _const.HEATER_TYPE_NONE
+HEATER_TYPE_WATER = _const.HEATER_TYPE_WATER
+MODE_AWAY = _const.MODE_AWAY
+MODE_BOOST = _const.MODE_BOOST
+MODE_HOME = _const.MODE_HOME
+MODE_MANUAL = _const.MODE_MANUAL
+MODE_OVERPRESSURE = _const.MODE_OVERPRESSURE
+MODE_STOP = _const.MODE_STOP
+POWER_OFF = _const.POWER_OFF
+POWER_RUNNING = _const.POWER_RUNNING
+POWER_SHUTTING_DOWN = _const.POWER_SHUTTING_DOWN
+POWER_STARTING = _const.POWER_STARTING
+SOFTWARE_VERSION_2 = _const.SOFTWARE_VERSION_2
+
+
+# ============================================================================
+# State Mappings (extracted from sensor.py)
+# ============================================================================
+
+# V1.x Power state (POWER_BTN_FI): 0=Off, 1=Shutting Down, 2=Starting, 3=Running
+POWER_STATE_MAP_V1 = {
+    POWER_OFF: "Off",
+    POWER_SHUTTING_DOWN: "Shutting Down",
+    POWER_STARTING: "Starting",
+    POWER_RUNNING: "Running",
+}
+
+# V2.x Power state (UNIT_CONTROL_FO): 0=Off, 1=On
+POWER_STATE_MAP_V2 = {
+    0: "Off",
+    1: "On",
+}
+
+# V1.x Control state (IV01_CONTROLSTATE_FO)
+CONTROL_STATE_MAP_V1 = {
+    MODE_STOP: "Stop",
+    MODE_AWAY: "Away",
+    MODE_HOME: "Home",
+    MODE_BOOST: "Boost",
+    MODE_OVERPRESSURE: "Overpressure",
+    5: "Away Timer",
+    6: "Home Timer",
+    7: "Boost Timer",
+    8: "Overpressure Timer",
+    MODE_MANUAL: "Manual",
+}
+
+# V2.x Control state (USERSTATECONTROL_FO): 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
+CONTROL_STATE_MAP_V2 = {
+    0: "Off",
+    1: "Away",
+    2: "Home",
+    3: "Boost",
+    4: "Sauna",
+    5: "Fireplace",
+}
+
+# V1.x Heater type (HEAT_RADIATOR_TYPE): 0=Water, 1=Electric, 2=None
+HEATER_TYPE_MAP_V1 = {
+    HEATER_TYPE_WATER: "Water",
+    HEATER_TYPE_ELECTRIC: "Electric",
+    HEATER_TYPE_NONE: "None",
+}
+
+# V2.x Heater type (HEATPUMP_RADIATOR_ENABLE): 0=Electric (default), 1=Water (heat pump)
+HEATER_TYPE_MAP_V2 = {
+    0: "Electric",
+    1: "Water",
+}
+
+HOME_STATE_MAP = {0: "Away", 1: "Home"}
+BINARY_STATE_MAP = {0: "Off", 1: "On"}
+
+# V1.x Filter state
+FILTER_STATE_MAP_V1 = {0: "Replace", 1: "OK"}
+
+# V2.x Filter state (FILTER_STATE_FI): 0=Idle/OK, 1=Ack change, 2=Reminder alarm
+FILTER_STATE_MAP_V2 = {0: "OK", 1: "Acknowledge Change", 2: "Replace Reminder"}
+
+# V2.x Summer mode (SUMMER_MODE_I): 0=Winter, 1=Transition, 2=Summer
+SUMMER_MODE_MAP_V2 = {0: "Winter", 1: "Transition", 2: "Summer"}
+
+
+# ============================================================================
+# Interpretation Functions
+# ============================================================================
+
+def interpret_power_state(value: int | None, is_v2: bool = False) -> str:
+    """Interpret power state register value."""
+    if value is None:
+        return "Unknown"
+    state_map = POWER_STATE_MAP_V2 if is_v2 else POWER_STATE_MAP_V1
+    return state_map.get(value, f"Unknown ({value})")
+
+
+def interpret_control_state(value: int | None, is_v2: bool = False) -> str:
+    """Interpret control state register value."""
+    if value is None:
+        return "Unknown"
+    state_map = CONTROL_STATE_MAP_V2 if is_v2 else CONTROL_STATE_MAP_V1
+    return state_map.get(value, f"Unknown ({value})")
+
+
+def interpret_heater_type(value: int | None, is_v2: bool = False) -> str:
+    """Interpret heater type register value."""
+    if value is None:
+        return "Unknown"
+    heater_map = HEATER_TYPE_MAP_V2 if is_v2 else HEATER_TYPE_MAP_V1
+    return heater_map.get(value, f"Unknown ({value})")
+
+
+def interpret_binary_state(value: int | None, state_map: dict[int, str]) -> str:
+    """Interpret a binary state register."""
+    if value is None:
+        return "Unknown"
+    return state_map.get(value, f"Unknown ({value})")
+
+
+def is_optional_sensor_installed(value: int | None) -> bool:
+    """Check if an optional sensor (humidity, CO2) is installed."""
+    if value is None:
+        return False
+    # 0, -1, or 65535 (0xFFFF) indicate sensor not installed
+    return value not in (0, -1, 65535)
+
+
+def format_temperature(value: float | None) -> str:
+    """Format a temperature value."""
+    if value is None:
+        return "N/A"
+    return f"{value:.1f}°C"
+
+
+def format_percentage(value: float | None) -> str:
+    """Format a percentage value."""
+    if value is None:
+        return "N/A"
+    return f"{value:.1f}%"
+
+
+def format_filter_date(day: int | None, month: int | None, year: int | None) -> str:
+    """Format filter change date."""
+    if day is None or month is None or year is None:
+        return "N/A"
+    try:
+        if not (1 <= day <= 31 and 1 <= month <= 12 and 2000 <= year <= 3000):
+            return "Invalid"
+        return f"{year:04d}-{month:02d}-{day:02d}"
+    except (ValueError, TypeError):
+        return "Invalid"
+
+
+# ============================================================================
+# Test Result Types
+# ============================================================================
+
+@dataclass
+class TestResult:
+    """Result of a single interpretation test."""
+
+    category: str
+    name: str
+    raw_value: Any
+    interpreted: str
+    status: str  # "ok", "warning", "error"
+    note: str = ""
+
+
+class InterpretationTester:
+    """Test runner for data interpretation."""
+
+    def __init__(self, coordinator: MockCoordinator, verbose: bool = False):
+        """Initialize the tester."""
+        self.coord = coordinator
+        self.verbose = verbose
+        self.results: list[TestResult] = []
+        
+        # Detect if this is a V2.x device
+        sw_ver = coordinator.data.get("software_version", 0)
+        self.is_v2 = sw_ver >= 2.0 if isinstance(sw_ver, (int, float)) else False
+
+    def test_all(self) -> list[TestResult]:
+        """Run all interpretation tests."""
+        self.results = []
+
+        self._test_system_info()
+        self._test_temperatures()
+        self._test_states()
+        self._test_speeds()
+        self._test_optional_sensors()
+        self._test_filter_info()
+        self._test_switch_states()
+        self._test_timers()
+
+        return self.results
+
+    def _add_result(
+        self,
+        category: str,
+        name: str,
+        raw_value: Any,
+        interpreted: str,
+        status: str = "ok",
+        note: str = "",
+    ):
+        """Add a test result."""
+        self.results.append(
+            TestResult(
+                category=category,
+                name=name,
+                raw_value=raw_value,
+                interpreted=interpreted,
+                status=status,
+                note=note,
+            )
+        )
+
+    def _test_system_info(self):
+        """Test system information interpretation."""
+        # Software version
+        sw_ver = self.coord.data.get("software_version")
+        raw = self.coord.get_raw_value("software_version")
+        if sw_ver is not None:
+            self._add_result(
+                "System", "Software Version", raw, f"{sw_ver:.2f}"
+            )
+        else:
+            self._add_result(
+                "System", "Software Version", raw, "N/A", "warning"
+            )
+
+        # Hardware type
+        hw_type = self.coord.data.get("hardware_type")
+        raw = self.coord.get_raw_value("hardware_type")
+        if hw_type is not None:
+            hw_type_int = int(hw_type)
+            # For V2, use mapping if available, otherwise use raw value
+            if self.coord.software_version == SOFTWARE_VERSION_2:
+                model_num = HARDWARE_TYPE_MAP_V2.get(hw_type_int, hw_type_int)
+                if model_num != hw_type_int:
+                    self._add_result(
+                        "System", "Hardware Type", raw, f"MAC {model_num} (type code {hw_type_int})"
+                    )
+                else:
+                    self._add_result(
+                        "System", "Hardware Type", raw, f"MAC {hw_type_int}"
+                    )
+            else:
+                self._add_result(
+                    "System", "Hardware Type", raw, f"MAC {hw_type_int}"
+                )
+        else:
+            self._add_result(
+                "System", "Hardware Type", raw, "N/A", "warning"
+            )
+
+        # Heater type
+        heater = self.coord.data.get("heater_type")
+        raw = self.coord.get_raw_value("heater_type")
+        self._add_result(
+            "System",
+            "Heater Type",
+            raw,
+            interpret_heater_type(int(heater) if heater is not None else None, self.is_v2),
+        )
+
+    def _test_temperatures(self):
+        """Test temperature interpretation."""
+        temp_keys = [
+            ("fresh_air_temp", "Fresh Air"),
+            ("supply_after_recovery_temp", "Supply (After Recovery)"),
+            ("supply_temp", "Supply"),
+            ("exhaust_temp", "Exhaust"),
+            ("waste_temp", "Waste"),
+            ("exhaust_temp_setpoint", "Exhaust Setpoint"),
+            ("supply_temp_setpoint", "Supply Setpoint"),
+        ]
+
+        for key, name in temp_keys:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+
+            # Check for reasonable temperature range
+            status = "ok"
+            note = ""
+            if value is not None:
+                if value < -50 or value > 80:
+                    status = "warning"
+                    note = "Unusual temperature"
+
+            self._add_result(
+                "Temperature",
+                name,
+                raw,
+                format_temperature(value),
+                status,
+                note,
+            )
+
+    def _test_states(self):
+        """Test state interpretation."""
+        # Power state
+        power = self.coord.data.get("power")
+        raw = self.coord.get_raw_value("power")
+        self._add_result(
+            "State",
+            "Power",
+            raw,
+            interpret_power_state(int(power) if power is not None else None, self.is_v2),
+        )
+
+        # Control state
+        control = self.coord.data.get("control_state")
+        raw = self.coord.get_raw_value("control_state")
+        self._add_result(
+            "State",
+            "Control",
+            raw,
+            interpret_control_state(int(control) if control is not None else None, self.is_v2),
+        )
+
+        # Home/Away state - V2 derives from control_state
+        if self.is_v2:
+            # V2: derive from USERSTATECONTROL_FO (2=Home, 1=Away)
+            home_val = "Home" if control == 2 else ("Away" if control == 1 else f"Mode {control}")
+            self._add_result("State", "Home/Away", raw, home_val)
+        else:
+            home = self.coord.data.get("home_state")
+            raw = self.coord.get_raw_value("home_state")
+            self._add_result(
+                "State",
+                "Home/Away",
+                raw,
+                interpret_binary_state(
+                    int(home) if home is not None else None, HOME_STATE_MAP
+                ),
+            )
+
+        # Boost state - V2 derives from control_state
+        if self.is_v2:
+            boost_val = "On" if control == 3 else "Off"
+            self._add_result("State", "Boost", control, boost_val)
+        else:
+            boost = self.coord.data.get("boost_state")
+            raw = self.coord.get_raw_value("boost_state")
+            self._add_result(
+                "State",
+                "Boost",
+                raw,
+                interpret_binary_state(
+                    int(boost) if boost is not None else None, BINARY_STATE_MAP
+                ),
+            )
+
+        # Overpressure/Sauna/Fireplace state - V2 has different modes
+        if self.is_v2:
+            if control == 4:
+                mode_val = "Sauna Active"
+            elif control == 5:
+                mode_val = "Fireplace Active"
+            else:
+                mode_val = "Off"
+            self._add_result("State", "Special Mode", control, mode_val)
+        else:
+            overp = self.coord.data.get("overpressure_state")
+            raw = self.coord.get_raw_value("overpressure_state")
+            self._add_result(
+                "State",
+                "Overpressure",
+                raw,
+                interpret_binary_state(
+                    int(overp) if overp is not None else None, BINARY_STATE_MAP
+                ),
+            )
+
+        # Defrost state
+        defrost = self.coord.data.get("defrost_state")
+        raw = self.coord.get_raw_value("defrost_state")
+        self._add_result(
+            "State",
+            "Defrost",
+            raw,
+            interpret_binary_state(
+                int(defrost) if defrost is not None else None, BINARY_STATE_MAP
+            ),
+        )
+
+    def _test_speeds(self):
+        """Test speed-related values."""
+        # Current speed
+        speed = self.coord.data.get("actual_speed")
+        raw = self.coord.get_raw_value("actual_speed")
+        if speed is not None:
+            self._add_result("Speed", "Current Speed", raw, f"Speed {int(speed)}")
+        else:
+            self._add_result("Speed", "Current Speed", raw, "N/A", "warning")
+
+        # Speed control
+        speed_ctrl = self.coord.data.get("speed_control")
+        raw = self.coord.get_raw_value("speed_control")
+        if speed_ctrl is not None:
+            speed_names = {0: "Auto", 1: "Stop", 2: "1", 3: "2", 4: "3", 5: "4", 6: "5"}
+            name = speed_names.get(int(speed_ctrl), f"Unknown ({speed_ctrl})")
+            self._add_result("Speed", "Speed Control", raw, name)
+        else:
+            self._add_result("Speed", "Speed Control", raw, "N/A")
+
+        # Preset speeds
+        for key, name in [
+            ("home_speed", "Home Preset"),
+            ("away_speed", "Away Preset"),
+            ("boost_setting", "Boost Preset"),
+        ]:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+            if value is not None:
+                self._add_result("Speed", name, raw, f"Speed {int(value)}")
+            else:
+                self._add_result("Speed", name, raw, "N/A")
+
+        # Fan speeds (percentage)
+        for key, name in [
+            ("supply_fan_speed", "Supply Fan"),
+            ("exhaust_fan_speed", "Exhaust Fan"),
+        ]:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+            self._add_result("Speed", name, raw, format_percentage(value))
+
+        # Heat recovery efficiency
+        efficiency = self.coord.data.get("heat_recovery_efficiency")
+        raw = self.coord.get_raw_value("heat_recovery_efficiency")
+        self._add_result("Performance", "Heat Recovery", raw, format_percentage(efficiency))
+
+    def _test_optional_sensors(self):
+        """Test optional sensor interpretation."""
+        # Humidity
+        humidity = self.coord.data.get("humidity")
+        raw = self.coord.get_raw_value("humidity")
+        if is_optional_sensor_installed(raw):
+            self._add_result("Optional", "Humidity", raw, f"{humidity}%")
+        else:
+            self._add_result(
+                "Optional", "Humidity", raw, "Not installed", "ok", "Sensor absent"
+            )
+
+        # Humidity 24h average
+        humidity_avg = self.coord.data.get("humidity_24h_avg")
+        raw = self.coord.get_raw_value("humidity_24h_avg")
+        if humidity_avg is not None and humidity_avg >= 0:
+            self._add_result("Optional", "Humidity 24h Avg", raw, f"{humidity_avg:.1f}%")
+        else:
+            self._add_result(
+                "Optional", "Humidity 24h Avg", raw, "Not available", "ok"
+            )
+
+        # CO2
+        co2 = self.coord.data.get("co2")
+        raw = self.coord.get_raw_value("co2")
+        if is_optional_sensor_installed(raw):
+            self._add_result("Optional", "CO2", raw, f"{co2} ppm")
+        else:
+            self._add_result(
+                "Optional", "CO2", raw, "Not installed", "ok", "Sensor absent"
+            )
+
+    def _test_filter_info(self):
+        """Test filter information."""
+        # Filter state - V2 uses different values
+        filter_state = self.coord.data.get("filter_state")
+        raw = self.coord.get_raw_value("filter_state")
+        filter_map = FILTER_STATE_MAP_V2 if self.is_v2 else FILTER_STATE_MAP_V1
+        self._add_result(
+            "Filter",
+            "Status",
+            raw,
+            interpret_binary_state(
+                int(filter_state) if filter_state is not None else None,
+                filter_map,
+            ),
+        )
+
+        # Filter change date
+        day = self.coord.data.get("filter_day")
+        month = self.coord.data.get("filter_month")
+        year = self.coord.data.get("filter_year")
+        self._add_result(
+            "Filter",
+            "Last Changed",
+            f"{day}/{month}/{year}",
+            format_filter_date(day, month, year),
+        )
+
+        # Next filter change
+        next_day = self.coord.data.get("filter_next_day")
+        next_month = self.coord.data.get("filter_next_month")
+        next_year = self.coord.data.get("filter_next_year")
+        self._add_result(
+            "Filter",
+            "Next Change",
+            f"{next_day}/{next_month}/{next_year}",
+            format_filter_date(next_day, next_month, next_year),
+        )
+
+        # Filter interval
+        # V2: 0=3 months, 1=4 months, 2=6 months
+        interval = self.coord.data.get("filter_interval")
+        raw = self.coord.get_raw_value("filter_interval")
+        if interval is not None:
+            interval_map = {0: "3 months", 1: "4 months", 2: "6 months"}
+            interval_str = interval_map.get(int(interval), f"{int(interval)} (unknown)")
+            self._add_result("Filter", "Interval", raw, interval_str)
+        else:
+            self._add_result("Filter", "Interval", raw, "N/A")
+
+    def _test_switch_states(self):
+        """Test switch state interpretation."""
+        # V2: Season is a separate read-only indicator (season_state)
+        # V2: Summer mode setting (summer_mode) is auto summer cooling enable
+        if self.is_v2:
+            # Actual season indicator
+            season = self.coord.data.get("season_state")
+            raw = self.coord.get_raw_value("season_state")
+            if season is not None:
+                season_val = SUMMER_MODE_MAP_V2.get(int(season), f"Unknown ({season})")
+                self._add_result("State", "Season", raw, season_val)
+            else:
+                self._add_result("State", "Season", raw, "N/A (register not read)")
+            
+            # Summer cooling setting (0=Off, 1=On, 2=Auto?)
+            summer = self.coord.data.get("summer_mode")
+            raw = self.coord.get_raw_value("summer_mode")
+            summer_cooling_map = {0: "Off", 1: "On", 2: "Auto"}
+            summer_val = summer_cooling_map.get(int(summer) if summer is not None else None, f"Unknown ({summer})")
+            self._add_result("Switch", "Summer Cooling", raw, summer_val)
+        else:
+            # V1: summer_mode is just on/off
+            summer = self.coord.data.get("summer_mode")
+            raw = self.coord.get_raw_value("summer_mode")
+            self._add_result(
+                "Switch", "Summer Mode", raw,
+                interpret_binary_state(int(summer) if summer is not None else None, BINARY_STATE_MAP),
+            )
+
+        # Other switches
+        switches = [
+            ("time_program_enable", "Time Program"),
+            ("heater_enable", "Heater Enable"),
+        ]
+
+        for key, name in switches:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+            self._add_result(
+                "Switch",
+                name,
+                raw,
+                interpret_binary_state(
+                    int(value) if value is not None else None, BINARY_STATE_MAP
+                ),
+            )
+
+    def _test_timers(self):
+        """Test timer values."""
+        timers = [
+            ("boost_timer", "Boost Timer"),
+            ("overpressure_timer", "Overpressure Timer"),
+        ]
+
+        for key, name in timers:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+            if value is not None and value > 0:
+                self._add_result("Timer", name, raw, f"{int(value)} min")
+            else:
+                self._add_result("Timer", name, raw, "Inactive")
+
+        # Preset durations
+        boost_time = self.coord.data.get("boost_time_setting")
+        raw = self.coord.get_raw_value("boost_time_setting")
+        boost_time_map = {0: "30 min", 1: "60 min", 2: "90 min", 3: "120 min", 4: "180 min"}
+        if boost_time is not None:
+            self._add_result(
+                "Timer",
+                "Boost Preset",
+                raw,
+                boost_time_map.get(int(boost_time), f"Unknown ({boost_time})"),
+            )
+        else:
+            self._add_result("Timer", "Boost Preset", raw, "N/A")
+
+        overp_time = self.coord.data.get("overpressure_time_setting")
+        raw = self.coord.get_raw_value("overpressure_time_setting")
+        overp_time_map = {0: "15 min", 1: "30 min", 2: "45 min", 3: "60 min", 4: "120 min"}
+        if overp_time is not None:
+            self._add_result(
+                "Timer",
+                "Overpressure Preset",
+                raw,
+                overp_time_map.get(int(overp_time), f"Unknown ({overp_time})"),
+            )
+        else:
+            self._add_result("Timer", "Overpressure Preset", raw, "N/A")
+
+
+def print_results(results: list[TestResult], verbose: bool = False):
+    """Print test results in a readable format."""
+    # Group by category
+    categories: dict[str, list[TestResult]] = {}
+    for r in results:
+        if r.category not in categories:
+            categories[r.category] = []
+        categories[r.category].append(r)
+
+    warnings = 0
+    errors = 0
+
+    for category, items in categories.items():
+        print(f"\n{category.upper()}")
+        print("-" * 40)
+
+        for item in items:
+            # Status indicator
+            if item.status == "warning":
+                indicator = "⚠"
+                warnings += 1
+            elif item.status == "error":
+                indicator = "✗"
+                errors += 1
+            else:
+                indicator = "✓"
+
+            # Format output
+            raw_str = f"(raw: {item.raw_value})" if verbose else ""
+            note_str = f" [{item.note}]" if item.note else ""
+
+            print(f"  {indicator} {item.name:25} {item.interpreted:20} {raw_str}{note_str}")
+
+    # Summary
+    print("\n" + "=" * 50)
+    total = len(results)
+    ok = total - warnings - errors
+    print(f"SUMMARY: {ok}/{total} OK", end="")
+    if warnings:
+        print(f", {warnings} warnings", end="")
+    if errors:
+        print(f", {errors} errors", end="")
+    print()
+
+    return errors == 0
+
+
+def test_file(filepath: Path, verbose: bool = False) -> bool:
+    """Test a single dump file."""
+    print("=" * 60)
+    print(f"Testing: {filepath}")
+    print("=" * 60)
+
+    try:
+        coord = load_dump(filepath)
+    except FileNotFoundError:
+        print(f"✗ File not found: {filepath}")
+        return False
+    except Exception as e:
+        print(f"✗ Error loading file: {e}")
+        return False
+
+    # Print metadata
+    print(f"\nSource: {coord.metadata.get('host', 'unknown')}")
+    if coord.metadata.get("detected_software_version"):
+        print(f"Software: {coord.metadata['detected_software_version']}")
+    if coord.metadata.get("detected_hardware_type"):
+        hw_type = coord.metadata['detected_hardware_type']
+        # For V2, use mapping if available, otherwise use raw value
+        if coord.software_version == SOFTWARE_VERSION_2:
+            model_num = HARDWARE_TYPE_MAP_V2.get(hw_type, hw_type)
+            if model_num != hw_type:
+                print(f"Detected hardware type: MAC {model_num} (type code {hw_type})")
+            else:
+                print(f"Detected hardware type: MAC {hw_type}")
+        else:
+            print(f"Detected hardware type: MAC {hw_type}")
+    print(f"Register map: {coord.software_version}")
+    print(f"Timestamp: {coord.metadata.get('timestamp', 'unknown')}")
+
+    # Run tests
+    tester = InterpretationTester(coord, verbose=verbose)
+    results = tester.test_all()
+
+    return print_results(results, verbose=verbose)
+
+
+def test_all_fixtures(verbose: bool = False) -> bool:
+    """Test all fixture files."""
+    fixtures_dir = Path(__file__).parent / "test_fixtures"
+    dumps_dir = Path(__file__).parent / "dumps"
+
+    all_passed = True
+    files_tested = 0
+
+    # Test fixtures
+    if fixtures_dir.exists():
+        for filepath in sorted(fixtures_dir.glob("*.json")):
+            if not test_file(filepath, verbose):
+                all_passed = False
+            files_tested += 1
+            print()
+
+    # Also test any dumps
+    if dumps_dir.exists():
+        for filepath in sorted(dumps_dir.glob("*.json")):
+            if not test_file(filepath, verbose):
+                all_passed = False
+            files_tested += 1
+            print()
+
+    if files_tested == 0:
+        print("No test files found in test_fixtures/ or dumps/")
+        print("Create a dump first with: python dump_registers.py <host>")
+        return False
+
+    print("=" * 60)
+    print(f"OVERALL: {'ALL PASSED' if all_passed else 'SOME FAILED'} ({files_tested} files tested)")
+    print("=" * 60)
+
+    return all_passed
+
+
+def main():
+    """Main entry point."""
+    parser = argparse.ArgumentParser(
+        description="Test Parmair data interpretation using dump files",
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+        epilog="""
+Examples:
+    %(prog)s dumps/my_device.json
+    %(prog)s test_fixtures/mac100_v1.json --verbose
+    %(prog)s --all
+        """,
+    )
+    parser.add_argument(
+        "file",
+        nargs="?",
+        type=Path,
+        help="JSON dump file to test",
+    )
+    parser.add_argument(
+        "--all",
+        "-a",
+        action="store_true",
+        help="Test all fixture files in test_fixtures/ and dumps/",
+    )
+    parser.add_argument(
+        "--verbose",
+        "-v",
+        action="store_true",
+        help="Show raw register values",
+    )
+
+    args = parser.parse_args()
+
+    if args.all:
+        success = test_all_fixtures(args.verbose)
+    elif args.file:
+        success = test_file(args.file, args.verbose)
+    else:
+        parser.print_help()
+        sys.exit(1)
+
+    sys.exit(0 if success else 1)
+
+
+if __name__ == "__main__":
+    main()
+

From 15d3b167f79df14ec10e99d9df7423cc9a4d9b35 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 20:58:44 +0200
Subject: [PATCH 03/15] Add project configuration and dependencies

---
 .gitignore            |   5 ++
 pyproject.toml        | 107 ++++++++++++++++++++++++++++++++++++++++++
 requirements-test.txt |  16 +++++++
 requirements.txt      |  12 +++++
 4 files changed, 140 insertions(+)
 create mode 100644 pyproject.toml
 create mode 100644 requirements-test.txt
 create mode 100644 requirements.txt

diff --git a/.gitignore b/.gitignore
index 96bd00f..3546567 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,7 @@
 # Python
 __pycache__/
+.venv/
+venv/
 *.py[cod]
 *$py.class
 *.so
@@ -35,3 +37,6 @@ MODBUS_REGISTERS_2XX.md
 *.xlsm
 *.xlsb
 *.csv
+
+# Tools
+tools/dumps/
diff --git a/pyproject.toml b/pyproject.toml
new file mode 100644
index 0000000..3f1c83b
--- /dev/null
+++ b/pyproject.toml
@@ -0,0 +1,107 @@
+[project]
+name = "parmair-ha"
+version = "0.9.0"
+description = "Home Assistant integration for Parmair MAC ventilation units"
+readme = "README.md"
+license = {text = "MIT"}
+requires-python = ">=3.12"
+authors = [
+    {name = "ValtteriAho"}
+]
+keywords = ["home-assistant", "parmair", "ventilation", "modbus"]
+classifiers = [
+    "Development Status :: 4 - Beta",
+    "Intended Audience :: Developers",
+    "License :: OSI Approved :: MIT License",
+    "Programming Language :: Python :: 3",
+    "Programming Language :: Python :: 3.12",
+    "Programming Language :: Python :: 3.13",
+]
+
+dependencies = [
+    "pymodbus>=3.7.4",
+]
+
+[project.optional-dependencies]
+dev = [
+    "pytest>=8.0.0",
+    "pytest-cov>=4.0.0",
+    "ruff>=0.4.0",
+    "mypy>=1.10.0",
+    "homeassistant-stubs>=2025.5.0",
+]
+
+[project.urls]
+Homepage = "https://github.com/ValtteriAho/Hassio_ParmAir"
+Repository = "https://github.com/ValtteriAho/Hassio_ParmAir"
+Issues = "https://github.com/ValtteriAho/Hassio_ParmAir/issues"
+
+[build-system]
+requires = ["setuptools>=61.0"]
+build-backend = "setuptools.build_meta"
+
+[tool.setuptools.packages.find]
+where = ["."]
+include = ["custom_components*", "tools*"]
+
+[tool.pytest.ini_options]
+testpaths = ["tests"]
+python_files = ["test_*.py"]
+python_functions = ["test_*"]
+addopts = "-v --tb=short"
+
+[tool.coverage.run]
+source = ["custom_components/parmair", "tools"]
+omit = ["*/__pycache__/*", "*/test_*"]
+
+[tool.coverage.report]
+exclude_lines = [
+    "pragma: no cover",
+    "if TYPE_CHECKING:",
+    "if __name__ == .__main__.:",
+]
+
+[tool.mypy]
+python_version = "3.13"
+warn_unused_configs = true
+disallow_untyped_defs = false
+check_untyped_defs = true
+warn_redundant_casts = true
+no_implicit_optional = true
+strict_equality = true
+show_error_codes = true
+
+# Disable checks that are too noisy for this codebase
+warn_return_any = true
+warn_unreachable = true
+
+[[tool.mypy.overrides]]
+module = [
+    "pymodbus.*",
+]
+ignore_missing_imports = true
+
+[tool.ruff]
+target-version = "py313"
+line-length = 100
+
+[tool.ruff.lint]
+select = [
+    "E",      # pycodestyle errors
+    "W",      # pycodestyle warnings
+    "F",      # pyflakes
+    "I",      # isort
+    "B",      # flake8-bugbear
+    "C4",     # flake8-comprehensions
+    "UP",     # pyupgrade
+    "ARG",    # flake8-unused-arguments
+    "SIM",    # flake8-simplify
+]
+ignore = [
+    "E501",   # line too long (handled by formatter)
+    "ARG002", # unused method argument - required by Home Assistant API signatures
+]
+
+[tool.ruff.lint.isort]
+known-first-party = ["custom_components.parmair"]
+
diff --git a/requirements-test.txt b/requirements-test.txt
new file mode 100644
index 0000000..d929ffd
--- /dev/null
+++ b/requirements-test.txt
@@ -0,0 +1,16 @@
+# CI test dependencies (lightweight, no Home Assistant needed)
+
+# Integration runtime dependency
+pymodbus>=3.11.2
+
+# Testing
+pytest>=8.0.0
+pytest-cov>=4.0.0
+
+# Linting
+ruff>=0.4.0
+
+# Type checking
+mypy>=1.10.0
+homeassistant-stubs>=2025.1.0  # Type stubs for Home Assistant
+
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..9c49338
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,12 @@
+# Local development dependencies for Parmair Home Assistant integration
+
+# Integration runtime dependency (matches manifest.json)
+pymodbus>=3.7.4
+
+# Home Assistant (for IDE support, type hints, local testing)
+homeassistant>=2025.1.0
+
+# Development tools
+ruff>=0.4.0
+pytest>=8.0.0
+pytest-cov>=4.0.0

From e28a3f680a01d82c23d4a04c8e77043ed08f8947 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 21:17:06 +0200
Subject: [PATCH 04/15] Add test suite and CI workflow

---
 .github/workflows/tests.yml        |  61 +++
 tests/__init__.py                  |   2 +
 tests/conftest.py                  | 104 +++++
 tests/fixtures/MAC120-full-v2.json | 583 +++++++++++++++++++++++++++++
 tests/test_interpretation.py       | 343 +++++++++++++++++
 5 files changed, 1093 insertions(+)
 create mode 100644 .github/workflows/tests.yml
 create mode 100644 tests/__init__.py
 create mode 100644 tests/conftest.py
 create mode 100644 tests/fixtures/MAC120-full-v2.json
 create mode 100644 tests/test_interpretation.py

diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
new file mode 100644
index 0000000..cec52a2
--- /dev/null
+++ b/.github/workflows/tests.yml
@@ -0,0 +1,61 @@
+name: Tests
+
+on:
+    push:
+        branches: [main, master]
+    pull_request:
+        branches: [main, master]
+
+jobs:
+    test:
+        runs-on: ubuntu-latest
+        steps:
+            - name: Checkout repository
+              uses: actions/checkout@v4
+
+            - name: Set up Python
+              uses: actions/setup-python@v5
+              with:
+                  python-version: "3.13"
+
+            - name: Install dependencies
+              run: |
+                  python -m pip install --upgrade pip
+                  pip install -r requirements-test.txt
+
+            - name: Run tests with coverage
+              run: |
+                  pytest tests/ -v --cov=custom_components/parmair --cov=tools --cov-report=xml --cov-report=term-missing
+
+            - name: Upload coverage reports
+              uses: codecov/codecov-action@v4
+              with:
+                  files: ./coverage.xml
+                  fail_ci_if_error: false
+              continue-on-error: true
+
+    lint:
+        runs-on: ubuntu-latest
+        steps:
+            - name: Checkout repository
+              uses: actions/checkout@v4
+
+            - name: Set up Python
+              uses: actions/setup-python@v5
+              with:
+                  python-version: "3.13"
+
+            - name: Install dependencies
+              run: |
+                  python -m pip install --upgrade pip
+                  pip install -r requirements-test.txt
+
+            - name: Run Ruff linter
+              run: |
+                  ruff check custom_components/ tools/ tests/
+              continue-on-error: true
+
+            - name: Run Ruff formatter check
+              run: |
+                  ruff format --check custom_components/ tools/ tests/
+              continue-on-error: true
diff --git a/tests/__init__.py b/tests/__init__.py
new file mode 100644
index 0000000..2bfddd0
--- /dev/null
+++ b/tests/__init__.py
@@ -0,0 +1,2 @@
+"""Parmair integration tests."""
+
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000..382dd66
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,104 @@
+"""Pytest configuration and fixtures for Parmair integration tests."""
+
+from __future__ import annotations
+
+import json
+import sys
+from pathlib import Path
+from typing import Any
+
+import pytest
+
+# Add project root to path for imports
+PROJECT_ROOT = Path(__file__).parent.parent
+sys.path.insert(0, str(PROJECT_ROOT))
+sys.path.insert(0, str(PROJECT_ROOT / "tools"))
+
+from tools.mock_coordinator import MockCoordinator, load_dump  # noqa: E402
+
+# Path to test fixtures
+FIXTURES_DIR = Path(__file__).parent / "fixtures"
+
+
+def discover_fixture_files() -> list[Path]:
+    """Discover all JSON fixture files in the fixtures directory."""
+    if not FIXTURES_DIR.exists():
+        return []
+    return sorted(FIXTURES_DIR.glob("*.json"))
+
+
+def get_fixture_ids() -> list[str]:
+    """Get human-readable IDs for fixture files."""
+    return [f.stem for f in discover_fixture_files()]
+
+
+# Parametrize helper for fixture files
+FIXTURE_FILES = discover_fixture_files()
+FIXTURE_IDS = get_fixture_ids()
+
+
+@pytest.fixture(params=FIXTURE_FILES, ids=FIXTURE_IDS)
+def fixture_file(request: pytest.FixtureRequest) -> Path:
+    """Parametrized fixture that yields each fixture file path."""
+    return request.param
+
+
+@pytest.fixture
+def coordinator(fixture_file: Path) -> MockCoordinator:
+    """Create a MockCoordinator from a fixture file."""
+    return load_dump(fixture_file)
+
+
+@pytest.fixture
+def fixture_data(fixture_file: Path) -> dict[str, Any]:
+    """Load raw fixture data as a dictionary."""
+    with open(fixture_file, encoding="utf-8") as f:
+        return json.load(f)
+
+
+@pytest.fixture
+def fixture_metadata(fixture_data: dict[str, Any]) -> dict[str, Any]:
+    """Extract metadata from fixture data."""
+    return fixture_data.get("metadata", {})
+
+
+@pytest.fixture
+def fixture_registers(fixture_data: dict[str, Any]) -> dict[str, Any]:
+    """Extract registers from fixture data."""
+    return fixture_data.get("registers", {})
+
+
+# Single coordinator fixtures for specific machine types (useful for targeted tests)
+@pytest.fixture
+def mac120_v2_coordinator() -> MockCoordinator | None:
+    """Load the MAC120 V2 fixture if available."""
+    fixture_path = FIXTURES_DIR / "MAC120-full-v2.json"
+    if fixture_path.exists():
+        return load_dump(fixture_path)
+    pytest.skip("MAC120-full-v2.json fixture not available")
+    return None
+
+
+# Helper fixtures for version detection
+@pytest.fixture
+def is_v2_device(coordinator: MockCoordinator) -> bool:
+    """Check if the current fixture is a V2.x device."""
+    sw_ver = coordinator.data.get("software_version", 0)
+    return sw_ver >= 2.0 if isinstance(sw_ver, (int, float)) else False
+
+
+# Collect all fixture files at module load time for test discovery
+def pytest_collection_modifyitems(config: pytest.Config, items: list[pytest.Item]) -> None:  # noqa: ARG001
+    """Skip tests if no fixture files are available."""
+    if not FIXTURE_FILES:
+        skip_marker = pytest.mark.skip(reason="No fixture files found in tests/fixtures/")
+        for item in items:
+            # Skip parametrized tests that depend on fixtures
+            if "fixture_file" in item.fixturenames or "coordinator" in item.fixturenames:
+                item.add_marker(skip_marker)
+
+
+def pytest_configure(config: pytest.Config) -> None:
+    """Register custom markers."""
+    config.addinivalue_line("markers", "v1_only: mark test to run only on V1.x devices")
+    config.addinivalue_line("markers", "v2_only: mark test to run only on V2.x devices")
diff --git a/tests/fixtures/MAC120-full-v2.json b/tests/fixtures/MAC120-full-v2.json
new file mode 100644
index 0000000..f30ae83
--- /dev/null
+++ b/tests/fixtures/MAC120-full-v2.json
@@ -0,0 +1,583 @@
+{
+  "metadata": {
+    "timestamp": "2026-01-11T12:05:13.810724",
+    "host": "",
+    "port": 502,
+    "slave_id": 1,
+    "register_map_version": "2.x",
+    "detected_software_version": 2.25,
+    "detected_hardware_type": 112,
+    "registers_read": 63,
+    "registers_failed": 0
+  },
+  "registers": {
+    "software_version": {
+      "address": 1015,
+      "label": "MULTI_SW_VER",
+      "raw": 225,
+      "scaled": 2.25,
+      "scale": 0.01,
+      "optional": false,
+      "writable": false
+    },
+    "hardware_type": {
+      "address": 1125,
+      "label": "VENT_MACHINE",
+      "raw": 112,
+      "scaled": 112,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "heater_type": {
+      "address": 1124,
+      "label": "HEATPUMP_RADIATOR_ENABLE",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "firmware_version": {
+      "address": 1014,
+      "label": "MULTI_FW_VER",
+      "raw": 283,
+      "scaled": 2.83,
+      "scale": 0.01,
+      "optional": false,
+      "writable": false
+    },
+    "bootloader_version": {
+      "address": 1016,
+      "label": "MULTI_BL_VER",
+      "raw": 244,
+      "scaled": 2.44,
+      "scale": 0.01,
+      "optional": false,
+      "writable": false
+    },
+    "power": {
+      "address": 1180,
+      "label": "UNIT_CONTROL_FO",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "control_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "actual_speed": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "speed_control": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "fresh_air_temp": {
+      "address": 1020,
+      "label": "TE01_M",
+      "raw": -43,
+      "scaled": -4.3,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "supply_after_recovery_temp": {
+      "address": 1021,
+      "label": "TE05_M",
+      "raw": 115,
+      "scaled": 11.5,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "supply_temp": {
+      "address": 1022,
+      "label": "TE10_M",
+      "raw": 174,
+      "scaled": 17.400000000000002,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_temp": {
+      "address": 1024,
+      "label": "TE30_M",
+      "raw": 193,
+      "scaled": 19.3,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "waste_temp": {
+      "address": 1023,
+      "label": "TE31_M",
+      "raw": 21,
+      "scaled": 2.1,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_temp_setpoint": {
+      "address": 1073,
+      "label": "TE30_S",
+      "raw": 210,
+      "scaled": 21.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": true
+    },
+    "supply_temp_setpoint": {
+      "address": 1061,
+      "label": "TE10_MIN_HOME_S",
+      "raw": 170,
+      "scaled": 17.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": true
+    },
+    "outdoor_temp_avg": {
+      "address": 1213,
+      "label": "TE01_AVG_FM",
+      "raw": -43,
+      "scaled": -4.3,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "home_speed": {
+      "address": 1060,
+      "label": "HOME_SPEED_S",
+      "raw": 3,
+      "scaled": 3,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "away_speed": {
+      "address": 1063,
+      "label": "AWAY_SPEED_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "boost_setting": {
+      "address": 1065,
+      "label": "BOOST_SETTING_S",
+      "raw": 4,
+      "scaled": 4,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "home_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "boost_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "boost_timer": {
+      "address": 1200,
+      "label": "BOOST_TIMER_FM",
+      "raw": -1,
+      "scaled": -1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "overpressure_state": {
+      "address": 1181,
+      "label": "USERSTATECONTROL_FO",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "overpressure_timer": {
+      "address": 1201,
+      "label": "OVERP_TIMER_FM",
+      "raw": -1,
+      "scaled": -1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "defrost_state": {
+      "address": 1182,
+      "label": "DFRST_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "season_state": {
+      "address": 1189,
+      "label": "SUMMER_MODE_I",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "humidity": {
+      "address": 1025,
+      "label": "ME05_M",
+      "raw": 24,
+      "scaled": 24,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "humidity_24h_avg": {
+      "address": 1192,
+      "label": "ME05_AVG_FM",
+      "raw": 261,
+      "scaled": 26.1,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "co2": {
+      "address": 1030,
+      "label": "QE20_M",
+      "raw": 604,
+      "scaled": 604,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "exhaust_co2": {
+      "address": 1026,
+      "label": "QE05_M",
+      "raw": 604,
+      "scaled": 604,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "wet_room_humidity": {
+      "address": 1029,
+      "label": "ME20_M",
+      "raw": 24,
+      "scaled": 24,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "supply_fan_speed": {
+      "address": 1040,
+      "label": "TF10_Y",
+      "raw": 500,
+      "scaled": 50.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_fan_speed": {
+      "address": 1042,
+      "label": "PF30_Y",
+      "raw": 640,
+      "scaled": 64.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "supply_fan_indicator": {
+      "address": 1027,
+      "label": "TF10_I",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "exhaust_fan_indicator": {
+      "address": 1028,
+      "label": "PF30_I",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "post_heater_output": {
+      "address": 1044,
+      "label": "TV45_Y",
+      "raw": 0,
+      "scaled": 0.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "pre_heater_output": {
+      "address": 1048,
+      "label": "EC05_Y",
+      "raw": 0,
+      "scaled": 0.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "heat_recovery_output": {
+      "address": 1046,
+      "label": "FG50_Y",
+      "raw": 1000,
+      "scaled": 100.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "heat_recovery_efficiency": {
+      "address": 1183,
+      "label": "FG50_EA_M",
+      "raw": 729,
+      "scaled": 72.9,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "heat_pump_output": {
+      "address": 1050,
+      "label": "HP_RAD_O",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "external_signal": {
+      "address": 1031,
+      "label": "EXTERNAL_M",
+      "raw": -10,
+      "scaled": -1.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "external_boost_signal": {
+      "address": 1035,
+      "label": "EXTERNAL_BOOST_M",
+      "raw": -10,
+      "scaled": -1.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "temp_deflection": {
+      "address": 1036,
+      "label": "TE10_DEFECTION_M",
+      "raw": -99,
+      "scaled": -9.9,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "alarm_count": {
+      "address": 1004,
+      "label": "ALARM_COUNT",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "sum_alarm": {
+      "address": 1005,
+      "label": "SUM_ALARM",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "alarms_state": {
+      "address": 1204,
+      "label": "ALARMS_STATE_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": true,
+      "writable": false
+    },
+    "sensor_status": {
+      "address": 1185,
+      "label": "SENSOR_STATUS",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "filter_state": {
+      "address": 1184,
+      "label": "FILTER_STATE_FI",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    },
+    "filter_day": {
+      "address": 1193,
+      "label": "FILTER_DAY",
+      "raw": 25,
+      "scaled": 25,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_month": {
+      "address": 1194,
+      "label": "FILTER_MONTH",
+      "raw": 12,
+      "scaled": 12,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_year": {
+      "address": 1195,
+      "label": "FILTER_YEAR",
+      "raw": 2025,
+      "scaled": 2025,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_day": {
+      "address": 1196,
+      "label": "FILTERNEXT_DAY",
+      "raw": 25,
+      "scaled": 25,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_month": {
+      "address": 1197,
+      "label": "FILTERNEXT_MONTH",
+      "raw": 4,
+      "scaled": 4,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_next_year": {
+      "address": 1198,
+      "label": "FILTERNEXT_YEAR",
+      "raw": 2026,
+      "scaled": 2026,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "filter_interval": {
+      "address": 1090,
+      "label": "FILTER_INTERVAL_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "summer_mode": {
+      "address": 1071,
+      "label": "AUTO_SUMMER_COOL_S",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "time_program_enable": {
+      "address": 1070,
+      "label": "TP_ENABLE_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "heater_enable": {
+      "address": 1074,
+      "label": "AUTO_HEATER_ENABLE_S",
+      "raw": 1,
+      "scaled": 1,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "boost_time_setting": {
+      "address": 1066,
+      "label": "BOOST_TIME_S",
+      "raw": 2,
+      "scaled": 2,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "overpressure_time_setting": {
+      "address": 1069,
+      "label": "OVERP_TIME_S",
+      "raw": 5,
+      "scaled": 5,
+      "scale": 1.0,
+      "optional": false,
+      "writable": true
+    },
+    "power_limit": {
+      "address": 1199,
+      "label": "PWR_LIMIT_FY",
+      "raw": 0,
+      "scaled": 0.0,
+      "scale": 0.1,
+      "optional": false,
+      "writable": false
+    },
+    "summer_power_change": {
+      "address": 1190,
+      "label": "SUMMER_POWER_CHANGE_F",
+      "raw": 0,
+      "scaled": 0,
+      "scale": 1.0,
+      "optional": false,
+      "writable": false
+    }
+  }
+}
+
diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
new file mode 100644
index 0000000..6315d63
--- /dev/null
+++ b/tests/test_interpretation.py
@@ -0,0 +1,343 @@
+"""Tests for Parmair data interpretation using fixture dumps.
+
+These tests validate that the integration correctly interprets register values
+from Parmair devices. Tests are parametrized to run against all available
+fixture files, ensuring compatibility with different machine types.
+"""
+
+from __future__ import annotations
+
+import sys
+from pathlib import Path
+from typing import Any
+
+import pytest
+
+# Add project root to path
+PROJECT_ROOT = Path(__file__).parent.parent
+sys.path.insert(0, str(PROJECT_ROOT))
+sys.path.insert(0, str(PROJECT_ROOT / "tools"))
+
+from tools.mock_coordinator import MockCoordinator
+
+
+class TestFixtureLoading:
+    """Test that fixture files load correctly."""
+
+    def test_fixture_loads_successfully(self, coordinator: MockCoordinator) -> None:
+        """Verify fixture file loads without errors."""
+        assert coordinator is not None
+        assert coordinator.data is not None
+        assert len(coordinator.data) > 0
+
+    def test_fixture_has_metadata(self, fixture_metadata: dict[str, Any]) -> None:
+        """Verify fixture has required metadata."""
+        assert "register_map_version" in fixture_metadata or "detected_software_version" in fixture_metadata
+        
+    def test_fixture_has_registers(self, fixture_registers: dict[str, Any]) -> None:
+        """Verify fixture has register data."""
+        assert len(fixture_registers) > 0
+
+
+class TestSystemInfo:
+    """Test system information interpretation."""
+
+    def test_software_version_present(self, coordinator: MockCoordinator) -> None:
+        """Software version should be present and valid."""
+        sw_ver = coordinator.data.get("software_version")
+        assert sw_ver is not None, "Software version should be present"
+        assert isinstance(sw_ver, (int, float)), "Software version should be numeric"
+        assert 0.5 <= sw_ver <= 10.0, f"Software version {sw_ver} out of expected range"
+
+    def test_hardware_type_present(self, coordinator: MockCoordinator) -> None:
+        """Hardware type should be present and valid."""
+        hw_type = coordinator.data.get("hardware_type")
+        assert hw_type is not None, "Hardware type should be present"
+        # Valid MAC models: 80, 100, 120, 150, etc.
+        assert 50 <= hw_type <= 500, f"Hardware type {hw_type} out of expected range"
+
+    def test_device_info_valid(self, coordinator: MockCoordinator) -> None:
+        """Device info should have required fields."""
+        device_info = coordinator.device_info
+        assert "name" in device_info
+        assert "manufacturer" in device_info
+        assert device_info["manufacturer"] == "Parmair"
+        assert "model" in device_info
+        assert "MAC" in device_info["model"]
+
+
+class TestTemperatures:
+    """Test temperature interpretation."""
+
+    TEMP_KEYS = [
+        "fresh_air_temp",
+        "supply_after_recovery_temp",
+        "supply_temp",
+        "exhaust_temp",
+        "waste_temp",
+    ]
+
+    SETPOINT_KEYS = [
+        "exhaust_temp_setpoint",
+        "supply_temp_setpoint",
+    ]
+
+    def test_temperatures_present(self, coordinator: MockCoordinator) -> None:
+        """At least some temperature values should be present."""
+        present = [key for key in self.TEMP_KEYS if key in coordinator.data]
+        assert len(present) >= 3, f"Expected at least 3 temperatures, found: {present}"
+
+    @pytest.mark.parametrize("temp_key", TEMP_KEYS)
+    def test_temperature_in_valid_range(
+        self, coordinator: MockCoordinator, temp_key: str
+    ) -> None:
+        """Temperature values should be in a physically reasonable range."""
+        if temp_key not in coordinator.data:
+            pytest.skip(f"{temp_key} not present in fixture")
+        
+        value = coordinator.data[temp_key]
+        assert value is not None
+        # Allow -50°C to +80°C range for ventilation systems
+        assert -50 <= value <= 80, f"{temp_key}={value}°C out of valid range"
+
+    @pytest.mark.parametrize("setpoint_key", SETPOINT_KEYS)
+    def test_setpoint_in_valid_range(
+        self, coordinator: MockCoordinator, setpoint_key: str
+    ) -> None:
+        """Temperature setpoints should be in a reasonable range."""
+        if setpoint_key not in coordinator.data:
+            pytest.skip(f"{setpoint_key} not present in fixture")
+        
+        value = coordinator.data[setpoint_key]
+        assert value is not None
+        # Setpoints typically 10°C to 30°C
+        assert 5 <= value <= 35, f"{setpoint_key}={value}°C out of valid range"
+
+
+class TestStates:
+    """Test state interpretation."""
+
+    def test_power_state_valid(self, coordinator: MockCoordinator) -> None:
+        """Power state should be a valid value."""
+        power = coordinator.data.get("power")
+        if power is None:
+            pytest.skip("Power state not present")
+        
+        # V1: 0=Off, 1=Shutting Down, 2=Starting, 3=Running
+        # V2: 0=Off, 1=On
+        assert power in (0, 1, 2, 3), f"Invalid power state: {power}"
+
+    def test_control_state_valid(self, coordinator: MockCoordinator) -> None:
+        """Control state should be a valid value."""
+        control = coordinator.data.get("control_state")
+        if control is None:
+            pytest.skip("Control state not present")
+        
+        # V1: 0=Stop, 1=Away, 2=Home, 3=Boost, 4=Overpressure, 5-8=Timers, 9=Manual
+        # V2: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
+        assert 0 <= control <= 10, f"Invalid control state: {control}"
+
+    def test_defrost_state_binary(self, coordinator: MockCoordinator) -> None:
+        """Defrost state should be binary (0 or 1)."""
+        defrost = coordinator.data.get("defrost_state")
+        if defrost is None:
+            pytest.skip("Defrost state not present")
+        
+        assert defrost in (0, 1), f"Invalid defrost state: {defrost}"
+
+
+class TestSpeeds:
+    """Test speed-related values."""
+
+    def test_actual_speed_valid(self, coordinator: MockCoordinator) -> None:
+        """Actual speed should be in valid range."""
+        speed = coordinator.data.get("actual_speed")
+        if speed is None:
+            pytest.skip("Actual speed not present")
+        
+        # Speed typically 0-5 or similar
+        assert 0 <= speed <= 10, f"Invalid actual speed: {speed}"
+
+    def test_fan_speeds_percentage(self, coordinator: MockCoordinator) -> None:
+        """Fan speeds should be valid percentages."""
+        for key in ("supply_fan_speed", "exhaust_fan_speed"):
+            value = coordinator.data.get(key)
+            if value is None:
+                continue
+            
+            assert 0 <= value <= 100, f"{key}={value}% out of valid range"
+
+    def test_preset_speeds_valid(self, coordinator: MockCoordinator) -> None:
+        """Preset speed settings should be valid."""
+        for key in ("home_speed", "away_speed", "boost_setting"):
+            value = coordinator.data.get(key)
+            if value is None:
+                continue
+            
+            # Preset speeds typically 1-5
+            assert 0 <= value <= 10, f"{key}={value} out of valid range"
+
+
+class TestOptionalSensors:
+    """Test optional sensor interpretation."""
+
+    def test_humidity_valid_if_present(self, coordinator: MockCoordinator) -> None:
+        """Humidity should be 0-100% if present and installed."""
+        humidity = coordinator.data.get("humidity")
+        raw = coordinator.get_raw_value("humidity")
+        
+        if humidity is None or raw in (0, -1, 65535):
+            pytest.skip("Humidity sensor not installed")
+        
+        assert 0 <= humidity <= 100, f"Invalid humidity: {humidity}%"
+
+    def test_co2_valid_if_present(self, coordinator: MockCoordinator) -> None:
+        """CO2 should be reasonable ppm if present and installed."""
+        co2 = coordinator.data.get("co2")
+        raw = coordinator.get_raw_value("co2")
+        
+        if co2 is None or raw in (0, -1, 65535):
+            pytest.skip("CO2 sensor not installed")
+        
+        # CO2 typically 400-5000 ppm in ventilation scenarios
+        assert 200 <= co2 <= 10000, f"Invalid CO2: {co2} ppm"
+
+
+class TestFilterInfo:
+    """Test filter information interpretation."""
+
+    def test_filter_state_valid(self, coordinator: MockCoordinator) -> None:
+        """Filter state should be valid."""
+        state = coordinator.data.get("filter_state")
+        if state is None:
+            pytest.skip("Filter state not present")
+        
+        # V1: 0=Replace, 1=OK
+        # V2: 0=OK, 1=Ack, 2=Reminder
+        assert state in (0, 1, 2), f"Invalid filter state: {state}"
+
+    def test_filter_date_valid(self, coordinator: MockCoordinator) -> None:
+        """Filter date components should be valid."""
+        day = coordinator.data.get("filter_day")
+        month = coordinator.data.get("filter_month")
+        year = coordinator.data.get("filter_year")
+        
+        if day is None or month is None or year is None:
+            pytest.skip("Filter date not present")
+        
+        assert 1 <= day <= 31, f"Invalid filter day: {day}"
+        assert 1 <= month <= 12, f"Invalid filter month: {month}"
+        assert 2000 <= year <= 3000, f"Invalid filter year: {year}"
+
+    def test_filter_interval_valid(self, coordinator: MockCoordinator) -> None:
+        """Filter interval should be valid."""
+        interval = coordinator.data.get("filter_interval")
+        if interval is None:
+            pytest.skip("Filter interval not present")
+        
+        # V2: 0=3 months, 1=4 months, 2=6 months
+        assert 0 <= interval <= 10, f"Invalid filter interval: {interval}"
+
+
+class TestPerformance:
+    """Test performance metrics interpretation."""
+
+    def test_heat_recovery_efficiency_valid(self, coordinator: MockCoordinator) -> None:
+        """Heat recovery efficiency should be 0-100%."""
+        efficiency = coordinator.data.get("heat_recovery_efficiency")
+        if efficiency is None:
+            pytest.skip("Heat recovery efficiency not present")
+        
+        assert 0 <= efficiency <= 100, f"Invalid efficiency: {efficiency}%"
+
+    def test_heater_outputs_percentage(self, coordinator: MockCoordinator) -> None:
+        """Heater outputs should be valid percentages."""
+        for key in ("post_heater_output", "pre_heater_output", "heat_recovery_output"):
+            value = coordinator.data.get(key)
+            if value is None:
+                continue
+            
+            assert 0 <= value <= 100, f"{key}={value}% out of valid range"
+
+
+class TestScaling:
+    """Test that register scaling is applied correctly."""
+
+    def test_temperature_scaling(self, coordinator: MockCoordinator) -> None:
+        """Temperature values should be scaled by 0.1."""
+        # Check that raw/scaled relationship is correct for a temp register
+        raw = coordinator.get_raw_value("supply_temp")
+        scaled = coordinator.data.get("supply_temp")
+        
+        if raw is None or scaled is None:
+            pytest.skip("Supply temp not present")
+        
+        # With 0.1 scaling, raw 174 should give 17.4
+        expected = raw * 0.1
+        assert abs(scaled - expected) < 0.01, f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+
+    def test_version_scaling(self, coordinator: MockCoordinator) -> None:
+        """Version values should be scaled by 0.01."""
+        raw = coordinator.get_raw_value("software_version")
+        scaled = coordinator.data.get("software_version")
+        
+        if raw is None or scaled is None:
+            pytest.skip("Software version not present")
+        
+        # With 0.01 scaling, raw 225 should give 2.25
+        expected = raw * 0.01
+        assert abs(scaled - expected) < 0.001, f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+
+
+class TestRegisterDefinitions:
+    """Test register definition retrieval."""
+
+    def test_get_register_definition(self, coordinator: MockCoordinator) -> None:
+        """Register definitions should be retrievable."""
+        for key in ("software_version", "power", "fresh_air_temp"):
+            if key not in coordinator.data:
+                continue
+            
+            definition = coordinator.get_register_definition(key)
+            assert definition is not None
+            assert definition.key == key
+            assert definition.address > 0
+
+    def test_register_definition_has_label(self, coordinator: MockCoordinator) -> None:
+        """Register definitions should have Modbus labels."""
+        definition = coordinator.get_register_definition("software_version")
+        assert definition.label is not None
+        assert len(definition.label) > 0
+
+
+class TestV2Specific:
+    """Tests specific to V2.x firmware."""
+
+    def test_season_state_v2(
+        self, coordinator: MockCoordinator, is_v2_device: bool
+    ) -> None:
+        """V2 devices should have season state."""
+        if not is_v2_device:
+            pytest.skip("Not a V2 device")
+        
+        season = coordinator.data.get("season_state")
+        if season is None:
+            pytest.skip("Season state not present")
+        
+        # V2: 0=Winter, 1=Transition, 2=Summer
+        assert season in (0, 1, 2), f"Invalid V2 season state: {season}"
+
+    def test_hardware_type_mapping_v2(
+        self, coordinator: MockCoordinator, is_v2_device: bool
+    ) -> None:
+        """V2 hardware type codes should map correctly."""
+        if not is_v2_device:
+            pytest.skip("Not a V2 device")
+        
+        hw_type = coordinator.data.get("hardware_type")
+        if hw_type is None:
+            pytest.skip("Hardware type not present")
+        
+        device_info = coordinator.device_info
+        assert "MAC" in device_info["model"]
+

From a567ad5806d6c136ab20390651635c52f193769c Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 21:20:16 +0200
Subject: [PATCH 05/15] Fix V2 register handling and shared address
 deduplication

---
 custom_components/parmair/config_flow.py |   8 +-
 custom_components/parmair/const.py       |  11 ++-
 custom_components/parmair/coordinator.py |  43 +++++++--
 custom_components/parmair/sensor.py      |  15 +++-
 tests/test_interpretation.py             | 110 +++++++++++++++++++----
 tools/mock_coordinator.py                |  37 +++++++-
 6 files changed, 191 insertions(+), 33 deletions(-)

diff --git a/custom_components/parmair/config_flow.py b/custom_components/parmair/config_flow.py
index cb0ed64..f704b79 100644
--- a/custom_components/parmair/config_flow.py
+++ b/custom_components/parmair/config_flow.py
@@ -50,6 +50,7 @@ def _set_unit_id(client: ModbusTcpClient, unit_id: int) -> None:
     SOFTWARE_VERSION_2,
     SOFTWARE_VERSION_UNKNOWN,
     get_register_definition,
+    get_registers_for_version,
 )
 
 _LOGGER = logging.getLogger(__name__)
@@ -300,9 +301,10 @@ def _read_register(address: int) -> int | None:
         return None  # Signal to caller that manual selection is needed
     
     detected_sw_version, detected_heater_type = detection_result
-    
-    # Verify communication by reading power register
-    power_register = get_register_definition(REG_POWER)
+
+    # Verify communication by reading power register (use version-specific address)
+    registers = get_registers_for_version(detected_sw_version)
+    power_register = get_register_definition(REG_POWER, registers)
     
     # Try to read a register to verify communication
     def _read_test():
diff --git a/custom_components/parmair/const.py b/custom_components/parmair/const.py
index e1cb9c0..9022d54 100644
--- a/custom_components/parmair/const.py
+++ b/custom_components/parmair/const.py
@@ -23,6 +23,11 @@
 SOFTWARE_VERSION_2 = "2.x"
 SOFTWARE_VERSION_UNKNOWN = "unknown"
 
+# V2 VENT_MACHINE codes -> display model number (v2 uses different encoding than v1)
+HARDWARE_TYPE_MAP_V2: dict[int, int] = {
+    112: 120,  # MAC 120
+}
+
 # Heater types - NOTE: Values are REVERSED between firmware versions!
 # Firmware 1.xx (register 1240): 0=Water, 1=Electric, 2=None
 # Firmware 2.xx (register 1127): 0=Electric, 1=Water, 2=None
@@ -248,9 +253,6 @@ def _build_registers_v1() -> Dict[str, RegisterDefinition]:
         REG_HEAT_RECOVERY_EFFICIENCY: RegisterDefinition(
             REG_HEAT_RECOVERY_EFFICIENCY, 1190, "FG50_EA_M", scale=0.1
         ),
-        REG_OVERPRESSURE_TIMER: RegisterDefinition(
-            REG_OVERPRESSURE_TIMER, 1204, "OVERP_TIMER_FM"
-        ),
         REG_DEFROST_STATE: RegisterDefinition(
             REG_DEFROST_STATE, 1183, "DFRST_FI"
         ),
@@ -313,6 +315,7 @@ def _build_registers_v2() -> Dict[str, RegisterDefinition]:
         REG_WASTE_TEMP: RegisterDefinition(REG_WASTE_TEMP, 1023, "TE31_M", scale=0.1),
         
         # Temperature setpoints (×0.1°C scaling)
+        # TE30_S: shared with REG_SUMMER_MODE_TEMP_LIMIT (target room temp / summer mode limit)
         REG_EXHAUST_TEMP_SETPOINT: RegisterDefinition(REG_EXHAUST_TEMP_SETPOINT, 1073, "TE30_S", scale=0.1, writable=True),
         REG_SUPPLY_TEMP_SETPOINT: RegisterDefinition(REG_SUPPLY_TEMP_SETPOINT, 1061, "TE10_MIN_HOME_S", scale=0.1, writable=True),
         
@@ -354,6 +357,7 @@ def _build_registers_v2() -> Dict[str, RegisterDefinition]:
         # Predefined settings registers
         REG_BOOST_TIME_SETTING: RegisterDefinition(REG_BOOST_TIME_SETTING, 1066, "BOOST_TIME_S", writable=True),
         REG_OVERPRESSURE_TIME_SETTING: RegisterDefinition(REG_OVERPRESSURE_TIME_SETTING, 1069, "OVERP_TIME_S", writable=True),
+        # TE30_S: same physical register as REG_EXHAUST_TEMP_SETPOINT (target room temp in summer)
         REG_SUMMER_MODE_TEMP_LIMIT: RegisterDefinition(REG_SUMMER_MODE_TEMP_LIMIT, 1073, "TE30_S", scale=0.1, writable=True),
         
         # Additional number registers
@@ -361,7 +365,6 @@ def _build_registers_v2() -> Dict[str, RegisterDefinition]:
         
         # Additional sensor registers
         REG_HEAT_RECOVERY_EFFICIENCY: RegisterDefinition(REG_HEAT_RECOVERY_EFFICIENCY, 1183, "FG50_EA_M", scale=0.1),
-        REG_OVERPRESSURE_TIMER: RegisterDefinition(REG_OVERPRESSURE_TIMER, 1201, "OVERP_TIMER_FM"),
         REG_DEFROST_STATE: RegisterDefinition(REG_DEFROST_STATE, 1182, "DFRST_FI"),
         REG_SUPPLY_FAN_SPEED: RegisterDefinition(REG_SUPPLY_FAN_SPEED, 1040, "TF10_Y", scale=0.1),
         REG_EXHAUST_FAN_SPEED: RegisterDefinition(REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1),
diff --git a/custom_components/parmair/coordinator.py b/custom_components/parmair/coordinator.py
index fc0123c..c9892ed 100644
--- a/custom_components/parmair/coordinator.py
+++ b/custom_components/parmair/coordinator.py
@@ -23,10 +23,12 @@
     DEFAULT_NAME,
     DEFAULT_SCAN_INTERVAL,
     DOMAIN,
+    HARDWARE_TYPE_MAP_V2,
     HEATER_TYPE_UNKNOWN,
     POLLING_REGISTER_KEYS,
     REGISTERS,
     SOFTWARE_VERSION_1,
+    SOFTWARE_VERSION_2,
     SOFTWARE_VERSION_UNKNOWN,
     STATIC_REGISTER_KEYS,
     RegisterDefinition,
@@ -145,13 +147,20 @@ def _read_modbus_data(self) -> dict[str, Any]:
             failed_registers = []
 
             try:
-                # Read dynamic registers on every poll
+                # Group definitions by address to avoid duplicate reads (e.g. v2 USERSTATECONTROL)
+                address_to_definitions: dict[int, list[RegisterDefinition]] = {}
                 for definition in self._poll_registers:
-                    value = self._read_register_value(definition)
+                    address_to_definitions.setdefault(definition.address, []).append(definition)
+
+                # Read each unique address once, distribute value to all keys using it
+                for address, definitions in address_to_definitions.items():
+                    # Use first definition for scaling (shared addresses have same scale)
+                    value = self._read_register_value(definitions[0])
                     if value is None:
-                        failed_registers.append(f"{definition.label}({definition.register_id})")
+                        failed_registers.append(f"{definitions[0].label}({definitions[0].register_id})")
                         continue
-                    data[definition.key] = value
+                    for definition in definitions:
+                        data[definition.key] = value
                     # Longer delay between reads to prevent transaction ID conflicts
                     time.sleep(0.3)
                 
@@ -164,6 +173,20 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 
                 # Merge static data with dynamic data
                 data.update(self._static_data)
+
+                # v2.x: home_state, boost_state, overpressure_state share register 1181 (USERSTATECONTROL_FO)
+                # 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
+                # Derive binary values for sensors that expect 0/1
+                is_v2 = (
+                    self.software_version == SOFTWARE_VERSION_2
+                    or str(self.software_version).startswith("2.")
+                )
+                if is_v2:
+                    user_state = data.get("control_state")
+                    if user_state is not None:
+                        data["home_state"] = 1 if user_state == 2 else 0  # 2=Home
+                        data["boost_state"] = 1 if user_state == 3 else 0  # 3=Boost
+                        data["overpressure_state"] = 1 if user_state in (4, 5) else 0  # 4=Sauna, 5=Fireplace
                 
                 _LOGGER.debug(
                     "Read data from Parmair %s: %d values (%d static, %d dynamic)",
@@ -186,7 +209,7 @@ def _read_modbus_data(self) -> dict[str, Any]:
 
     def write_register(self, key: str, value: float | int) -> bool:
         """Write a value to a Modbus register respecting scaling with pymodbus 3.x."""
-        definition = get_register_definition(key)
+        definition = get_register_definition(key, self._registers)
         try:
             with self._lock:
                 if not self._client.connected:
@@ -239,10 +262,16 @@ def device_info(self) -> dict[str, Any]:
         sw_version = self.data.get("software_version")
         hw_type = self.data.get("hardware_type")
         
-        # Determine MAC model from hardware type (80, 100, or 150)
+        # Determine MAC model from hardware type
         model = "MAC"
         if hw_type is not None:
-            model = f"MAC {int(hw_type)}"
+            hw_int = int(hw_type)
+            is_v2 = (
+                self.software_version == SOFTWARE_VERSION_2
+                or str(self.software_version).startswith("2.")
+            )
+            model_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int) if is_v2 else hw_int
+            model = f"MAC {model_num}"
         
         device_info = {
             "identifiers": {(DOMAIN, self.entry.entry_id)},
diff --git a/custom_components/parmair/sensor.py b/custom_components/parmair/sensor.py
index b48ab37..f7b0ae2 100644
--- a/custom_components/parmair/sensor.py
+++ b/custom_components/parmair/sensor.py
@@ -495,7 +495,8 @@ def __init__(
         super().__init__(coordinator, entry, data_key, name)
         self._state_map = state_map
         self._attr_device_class = SensorDeviceClass.ENUM
-        self._attr_options = list(state_map.values())
+        # Include "Unknown" so Home Assistant accepts unmapped values (e.g. v2 USERSTATECONTROL 2-5)
+        self._attr_options = list(state_map.values()) + ["Unknown"]
 
     @property
     def native_value(self) -> str | None:
@@ -503,7 +504,17 @@ def native_value(self) -> str | None:
         raw_value = self.coordinator.data.get(self._data_key)
         if raw_value is None:
             return None
-        return self._state_map.get(raw_value, f"Unknown ({raw_value})")
+        mapped = self._state_map.get(raw_value)
+        return mapped if mapped is not None else "Unknown"
+
+    @property
+    def extra_state_attributes(self) -> dict[str, object]:
+        """Expose register metadata and raw value for diagnostics."""
+        attrs = super().extra_state_attributes
+        raw_value = self.coordinator.data.get(self._data_key)
+        if raw_value is not None and raw_value not in self._state_map:
+            attrs["raw_value"] = raw_value
+        return attrs
 
 
 class ParmairFilterChangeDateSensor(CoordinatorEntity[ParmairCoordinator], SensorEntity):
diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
index 6315d63..5ebe1ec 100644
--- a/tests/test_interpretation.py
+++ b/tests/test_interpretation.py
@@ -18,7 +18,16 @@
 sys.path.insert(0, str(PROJECT_ROOT))
 sys.path.insert(0, str(PROJECT_ROOT / "tools"))
 
-from tools.mock_coordinator import MockCoordinator
+import re
+
+from tools.mock_coordinator import (
+    MockCoordinator,
+    HARDWARE_TYPE_MAP_V2,
+    REG_POWER,
+    REG_CONTROL_STATE,
+    SOFTWARE_VERSION_2,
+    get_registers_for_version,
+)
 
 
 class TestFixtureLoading:
@@ -32,7 +41,8 @@ def test_fixture_loads_successfully(self, coordinator: MockCoordinator) -> None:
 
     def test_fixture_has_metadata(self, fixture_metadata: dict[str, Any]) -> None:
         """Verify fixture has required metadata."""
-        assert "register_map_version" in fixture_metadata or "detected_software_version" in fixture_metadata
+        assert "register_map_version" in fixture_metadata, "Fixture must have register_map_version"
+        assert "detected_software_version" in fixture_metadata, "Fixture must have detected_software_version"
         
     def test_fixture_has_registers(self, fixture_registers: dict[str, Any]) -> None:
         """Verify fixture has register data."""
@@ -57,13 +67,15 @@ def test_hardware_type_present(self, coordinator: MockCoordinator) -> None:
         assert 50 <= hw_type <= 500, f"Hardware type {hw_type} out of expected range"
 
     def test_device_info_valid(self, coordinator: MockCoordinator) -> None:
-        """Device info should have required fields."""
+        """Device info should have required fields and valid model format."""
         device_info = coordinator.device_info
         assert "name" in device_info
         assert "manufacturer" in device_info
         assert device_info["manufacturer"] == "Parmair"
         assert "model" in device_info
-        assert "MAC" in device_info["model"]
+        model = device_info["model"]
+        assert model.startswith("MAC "), f"Model should start with 'MAC ', got {model}"
+        assert re.match(r"^MAC \d+$", model), f"Model should match 'MAC <number>', got {model}"
 
 
 class TestTemperatures:
@@ -290,24 +302,71 @@ def test_version_scaling(self, coordinator: MockCoordinator) -> None:
 
 
 class TestRegisterDefinitions:
-    """Test register definition retrieval."""
+    """Test register definition retrieval and correctness."""
+
+    # Expected addresses (key -> address) for v1 and v2 - catches wrong register map
+    V2_EXPECTED_ADDRESSES = {
+        "software_version": 1015,
+        "power": 1180,
+        "control_state": 1181,
+        "fresh_air_temp": 1020,
+    }
+    V1_EXPECTED_ADDRESSES = {
+        "software_version": 1018,
+        "power": 1208,
+        "control_state": 1185,
+        "fresh_air_temp": 1020,
+    }
 
     def test_get_register_definition(self, coordinator: MockCoordinator) -> None:
-        """Register definitions should be retrievable."""
-        for key in ("software_version", "power", "fresh_air_temp"):
+        """Register definitions should be retrievable with correct addresses and labels."""
+        expected = (
+            self.V2_EXPECTED_ADDRESSES
+            if coordinator.software_version == SOFTWARE_VERSION_2
+            or str(coordinator.software_version).startswith("2.")
+            else self.V1_EXPECTED_ADDRESSES
+        )
+        for key in ("software_version", "power", "control_state", "fresh_air_temp"):
             if key not in coordinator.data:
                 continue
-            
+
             definition = coordinator.get_register_definition(key)
             assert definition is not None
             assert definition.key == key
             assert definition.address > 0
-
-    def test_register_definition_has_label(self, coordinator: MockCoordinator) -> None:
-        """Register definitions should have Modbus labels."""
-        definition = coordinator.get_register_definition("software_version")
-        assert definition.label is not None
-        assert len(definition.label) > 0
+            assert definition.address == expected[key], (
+                f"{key} address should be {expected[key]}, got {definition.address}"
+            )
+            assert definition.label is not None and len(definition.label) > 0, (
+                f"{key} should have non-empty label"
+            )
+
+    def test_overpressure_timer_writable(self, coordinator: MockCoordinator) -> None:
+        """Overpressure timer register should be writable (was overwritten by duplicate def)."""
+        if "overpressure_timer" not in coordinator.data:
+            pytest.skip("Overpressure timer not in fixture")
+        definition = coordinator.get_register_definition("overpressure_timer")
+        assert definition.writable, "overpressure_timer should be writable"
+
+
+class TestRegisterMap:
+    """Tests for register map correctness (would catch write_register wrong map bug)."""
+
+    def test_v2_register_addresses_match_documentation(self) -> None:
+        """V2 register addresses must match device docs (catches wrong map in writes)."""
+        regs = get_registers_for_version(SOFTWARE_VERSION_2)
+        assert regs[REG_POWER].address == 1180, (
+            "V2 POWER should be UNIT_CONTROL_FO at 1180"
+        )
+        assert regs[REG_CONTROL_STATE].address == 1181, (
+            "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
+        )
+
+    def test_power_register_address_varies_by_version(self) -> None:
+        """Power register address differs between v1 and v2 (config_flow must use correct one)."""
+        v1_addr = get_registers_for_version("1.x")[REG_POWER].address
+        v2_addr = get_registers_for_version(SOFTWARE_VERSION_2)[REG_POWER].address
+        assert v1_addr != v2_addr, "V1 and V2 power addresses must differ"
 
 
 class TestV2Specific:
@@ -330,7 +389,7 @@ def test_season_state_v2(
     def test_hardware_type_mapping_v2(
         self, coordinator: MockCoordinator, is_v2_device: bool
     ) -> None:
-        """V2 hardware type codes should map correctly."""
+        """V2 hardware type codes should map to correct model (e.g. 112 -> MAC 120)."""
         if not is_v2_device:
             pytest.skip("Not a V2 device")
         
@@ -338,6 +397,25 @@ def test_hardware_type_mapping_v2(
         if hw_type is None:
             pytest.skip("Hardware type not present")
         
+        hw_int = int(hw_type)
+        expected_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int)
+        expected_model = f"MAC {expected_num}"
         device_info = coordinator.device_info
-        assert "MAC" in device_info["model"]
+        assert device_info["model"] == expected_model, (
+            f"V2 hw_type {hw_int} should map to {expected_model}, got {device_info['model']}"
+        )
+
+    def test_v2_derived_states_binary(
+        self, coordinator: MockCoordinator, is_v2_device: bool
+    ) -> None:
+        """V2 home_state, boost_state, overpressure_state must be 0 or 1 (derived from USERSTATECONTROL)."""
+        if not is_v2_device:
+            pytest.skip("Not a V2 device")
+        for key in ("home_state", "boost_state", "overpressure_state"):
+            value = coordinator.data.get(key)
+            if value is None:
+                continue
+            assert value in (0, 1), (
+                f"{key} must be 0 or 1 for binary sensor, got {value}"
+            )
 
diff --git a/tools/mock_coordinator.py b/tools/mock_coordinator.py
index af4d1ea..e465d73 100644
--- a/tools/mock_coordinator.py
+++ b/tools/mock_coordinator.py
@@ -33,6 +33,9 @@
 
 SOFTWARE_VERSION_1 = _const.SOFTWARE_VERSION_1
 SOFTWARE_VERSION_2 = _const.SOFTWARE_VERSION_2
+HARDWARE_TYPE_MAP_V2 = _const.HARDWARE_TYPE_MAP_V2
+REG_POWER = _const.REG_POWER
+REG_CONTROL_STATE = _const.REG_CONTROL_STATE
 RegisterDefinition = _const.RegisterDefinition
 get_register_definition = _const.get_register_definition
 get_registers_for_version = _const.get_registers_for_version
@@ -105,7 +108,13 @@ def device_info(self) -> dict[str, Any]:
 
         model = "MAC"
         if hw_type is not None:
-            model = f"MAC {int(hw_type)}"
+            hw_int = int(hw_type)
+            is_v2 = (
+                self._software_version == SOFTWARE_VERSION_2
+                or str(self._software_version).startswith("2.")
+            )
+            model_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int) if is_v2 else hw_int
+            model = f"MAC {model_num}"
 
         device_info = {
             "identifiers": {("parmair", "mock_device")},
@@ -172,6 +181,19 @@ def from_file(cls, filepath: str | Path) -> "MockCoordinator":
                 # For registers without scaling, use raw value
                 data[key] = reg_data["raw"]
 
+        # v2.x: derive home_state, boost_state, overpressure_state from control_state
+        # (USERSTATECONTROL_FO: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace)
+        is_v2 = (
+            software_version == SOFTWARE_VERSION_2
+            or str(software_version).startswith("2.")
+        )
+        if is_v2:
+            user_state = data.get("control_state")
+            if user_state is not None:
+                data["home_state"] = 1 if user_state == 2 else 0
+                data["boost_state"] = 1 if user_state == 3 else 0
+                data["overpressure_state"] = 1 if user_state in (4, 5) else 0
+
         return cls(
             data=data,
             metadata=metadata,
@@ -224,6 +246,19 @@ def from_dict(
             "register_map_version": software_version,
         }
 
+        # v2.x: derive home_state, boost_state, overpressure_state from control_state
+        is_v2 = (
+            software_version == SOFTWARE_VERSION_2
+            or str(software_version).startswith("2.")
+        )
+        if is_v2:
+            data = dict(data)  # Copy to avoid mutating user input
+            user_state = data.get("control_state")
+            if user_state is not None:
+                data["home_state"] = 1 if user_state == 2 else 0
+                data["boost_state"] = 1 if user_state == 3 else 0
+                data["overpressure_state"] = 1 if user_state in (4, 5) else 0
+
         return cls(
             data=data,
             metadata=metadata,

From f5c11c79c452e1d56893e86470109632b440863f Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 21:49:32 +0200
Subject: [PATCH 06/15] Add pre-heater and post-heater output sensors

---
 custom_components/parmair/const.py  | 12 ++++++++++++
 custom_components/parmair/sensor.py |  2 ++
 tools/test_interpretation.py        |  9 +++++++++
 3 files changed, 23 insertions(+)

diff --git a/custom_components/parmair/const.py b/custom_components/parmair/const.py
index 9022d54..60afa30 100644
--- a/custom_components/parmair/const.py
+++ b/custom_components/parmair/const.py
@@ -120,6 +120,8 @@ def register_id(self) -> int:
 
 # Additional sensor register keys
 REG_HEAT_RECOVERY_EFFICIENCY = "heat_recovery_efficiency"
+REG_PRE_HEATER_OUTPUT = "pre_heater_output"
+REG_POST_HEATER_OUTPUT = "post_heater_output"
 REG_OVERPRESSURE_TIMER = "overpressure_timer"
 REG_DEFROST_STATE = "defrost_state"
 REG_SUPPLY_FAN_SPEED = "supply_fan_speed"
@@ -262,6 +264,12 @@ def _build_registers_v1() -> Dict[str, RegisterDefinition]:
         REG_EXHAUST_FAN_SPEED: RegisterDefinition(
             REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1
         ),
+        REG_PRE_HEATER_OUTPUT: RegisterDefinition(
+            REG_PRE_HEATER_OUTPUT, 1048, "EC05_Y", scale=0.1
+        ),
+        REG_POST_HEATER_OUTPUT: RegisterDefinition(
+            REG_POST_HEATER_OUTPUT, 1044, "TV45_Y", scale=0.1
+        ),
         REG_FILTER_STATE: RegisterDefinition(
             REG_FILTER_STATE, 1205, "FILTER_STATE_FI"
         ),
@@ -368,6 +376,8 @@ def _build_registers_v2() -> Dict[str, RegisterDefinition]:
         REG_DEFROST_STATE: RegisterDefinition(REG_DEFROST_STATE, 1182, "DFRST_FI"),
         REG_SUPPLY_FAN_SPEED: RegisterDefinition(REG_SUPPLY_FAN_SPEED, 1040, "TF10_Y", scale=0.1),
         REG_EXHAUST_FAN_SPEED: RegisterDefinition(REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1),
+        REG_PRE_HEATER_OUTPUT: RegisterDefinition(REG_PRE_HEATER_OUTPUT, 1048, "EC05_Y", scale=0.1),
+        REG_POST_HEATER_OUTPUT: RegisterDefinition(REG_POST_HEATER_OUTPUT, 1044, "TV45_Y", scale=0.1),
         REG_FILTER_STATE: RegisterDefinition(REG_FILTER_STATE, 1184, "FILTER_STATE_FI"),
         REG_FILTER_DAY: RegisterDefinition(REG_FILTER_DAY, 1193, "FILTER_DAY", writable=True),
         REG_FILTER_MONTH: RegisterDefinition(REG_FILTER_MONTH, 1194, "FILTER_MONTH", writable=True),
@@ -437,6 +447,8 @@ def get_registers_for_version(software_version: str) -> Dict[str, RegisterDefini
     REG_DEFROST_STATE,
     REG_SUPPLY_FAN_SPEED,
     REG_EXHAUST_FAN_SPEED,
+    REG_PRE_HEATER_OUTPUT,
+    REG_POST_HEATER_OUTPUT,
     REG_FILTER_STATE,
     REG_FILTER_DAY,
     REG_FILTER_MONTH,
diff --git a/custom_components/parmair/sensor.py b/custom_components/parmair/sensor.py
index f7b0ae2..89ed63c 100644
--- a/custom_components/parmair/sensor.py
+++ b/custom_components/parmair/sensor.py
@@ -81,6 +81,8 @@ async def async_setup_entry(
         ParmairPercentageSensor(coordinator, entry, "lto_heat_recovery_control", "LTO Heat Recovery Control"),
         ParmairPercentageSensor(coordinator, entry, "supply_fan_speed", "Supply Fan Speed"),
         ParmairPercentageSensor(coordinator, entry, "exhaust_fan_speed", "Exhaust Fan Speed"),
+        ParmairPercentageSensor(coordinator, entry, "pre_heater_output", "Pre-heater Output"),
+        ParmairPercentageSensor(coordinator, entry, "post_heater_output", "Post-heater Output"),
         
         # Optional sensors (will show unavailable if hardware not present)
         ParmairHumiditySensor(coordinator, entry, "humidity", "Humidity"),
diff --git a/tools/test_interpretation.py b/tools/test_interpretation.py
index fc8969b..0ee8254 100644
--- a/tools/test_interpretation.py
+++ b/tools/test_interpretation.py
@@ -468,6 +468,15 @@ def _test_speeds(self):
             raw = self.coord.get_raw_value(key)
             self._add_result("Speed", name, raw, format_percentage(value))
 
+        # Pre-/post-heaters (percentage)
+        for key, name in [
+            ("pre_heater_output", "Pre-heater Output"),
+            ("post_heater_output", "Post-heater Output"),
+        ]:
+            value = self.coord.data.get(key)
+            raw = self.coord.get_raw_value(key)
+            self._add_result("Performance", name, raw, format_percentage(value))
+
         # Heat recovery efficiency
         efficiency = self.coord.data.get("heat_recovery_efficiency")
         raw = self.coord.get_raw_value("heat_recovery_efficiency")

From 8aaf977305ff5cf7726a4a531d058346746f3b24 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 21:57:11 +0200
Subject: [PATCH 07/15] Add batch Modbus reads into consecutive register spans

---
 custom_components/parmair/coordinator.py | 126 +++++++++++++++++++----
 1 file changed, 104 insertions(+), 22 deletions(-)

diff --git a/custom_components/parmair/coordinator.py b/custom_components/parmair/coordinator.py
index c9892ed..96c1858 100644
--- a/custom_components/parmair/coordinator.py
+++ b/custom_components/parmair/coordinator.py
@@ -51,6 +51,36 @@ def _set_unit_id(client: ModbusTcpClient, unit_id: int) -> None:
         client.slave_id = unit_id
 
 
+def _build_read_ranges(
+    address_to_definitions: dict[int, list[RegisterDefinition]],
+    max_registers: int = 125,
+) -> list[tuple[int, int]]:
+    """Group addresses into consecutive spans for batch reads.
+
+    Args:
+        address_to_definitions: Maps address -> list of definitions using that address
+        max_registers: Max registers per Modbus request (Modbus limit is 125)
+
+    Returns:
+        List of (start_address, count) for each consecutive span
+    """
+    if not address_to_definitions:
+        return []
+    addresses = sorted(address_to_definitions.keys())
+    ranges: list[tuple[int, int]] = []
+    start = addresses[0]
+    count = 1
+    for prev, curr in zip(addresses[:-1], addresses[1:]):
+        if curr == prev + 1 and count < max_registers:
+            count += 1
+        else:
+            ranges.append((start, count))
+            start = curr
+            count = 1
+    ranges.append((start, count))
+    return ranges
+
+
 class ParmairCoordinator(DataUpdateCoordinator[dict[str, Any]]):
     """Class to manage fetching Parmair data from Modbus."""
 
@@ -109,7 +139,7 @@ def _read_modbus_data(self) -> dict[str, Any]:
             if self._client.connected:
                 try:
                     self._client.close()
-                except:
+                except Exception:
                     pass  # Ignore close errors
             
             if not self._client.connect():
@@ -128,23 +158,31 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 pass
             time.sleep(0.3)
 
-            # Read static registers once on first poll
+            # Read static registers once on first poll (batched)
             if not self._static_data_read:
                 _LOGGER.info("Reading static device information (one-time read)")
+                static_addr_to_defs: dict[int, list[RegisterDefinition]] = {}
                 for definition in self._static_registers:
-                    value = self._read_register_value(definition)
-                    if value is not None:
-                        self._static_data[definition.key] = value
-                        _LOGGER.debug(
-                            "Static register %s: %s",
-                            definition.label,
-                            value,
-                        )
+                    static_addr_to_defs.setdefault(definition.address, []).append(definition)
+                for start_addr, span_count in _build_read_ranges(static_addr_to_defs):
+                    block = self._read_register_block(start_addr, span_count)
+                    if block is None:
+                        time.sleep(0.5)
+                        block = self._read_register_block(start_addr, span_count)
+                    if block is not None:
+                        for i, raw in enumerate(block):
+                            addr = start_addr + i
+                            if addr in static_addr_to_defs:
+                                for definition in static_addr_to_defs[addr]:
+                                    if definition.optional and raw < 0:
+                                        continue
+                                    self._static_data[definition.key] = self._from_raw(definition, raw)
+                                    _LOGGER.debug("Static register %s: %s", definition.label, self._static_data[definition.key])
                     time.sleep(0.3)
                 self._static_data_read = True
-            
+
             data: dict[str, Any] = {}
-            failed_registers = []
+            failed_registers: list[str] = []
 
             try:
                 # Group definitions by address to avoid duplicate reads (e.g. v2 USERSTATECONTROL)
@@ -152,16 +190,30 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 for definition in self._poll_registers:
                     address_to_definitions.setdefault(definition.address, []).append(definition)
 
-                # Read each unique address once, distribute value to all keys using it
-                for address, definitions in address_to_definitions.items():
-                    # Use first definition for scaling (shared addresses have same scale)
-                    value = self._read_register_value(definitions[0])
-                    if value is None:
-                        failed_registers.append(f"{definitions[0].label}({definitions[0].register_id})")
+                # Read in batched ranges, one Modbus request per consecutive span
+                for start_addr, span_count in _build_read_ranges(address_to_definitions):
+                    block = self._read_register_block(start_addr, span_count)
+                    if block is None:
+                        time.sleep(0.5)
+                        block = self._read_register_block(start_addr, span_count)
+                    if block is None:
+                        for addr in range(start_addr, start_addr + span_count):
+                            if addr in address_to_definitions:
+                                failed_registers.append(
+                                    f"{address_to_definitions[addr][0].label}({address_to_definitions[addr][0].register_id})"
+                                )
                         continue
-                    for definition in definitions:
-                        data[definition.key] = value
-                    # Longer delay between reads to prevent transaction ID conflicts
+                    for i, raw in enumerate(block):
+                        addr = start_addr + i
+                        if addr not in address_to_definitions:
+                            continue
+                        definitions = address_to_definitions[addr]
+                        first_def = definitions[0]
+                        if first_def.optional and raw < 0:
+                            continue
+                        value = self._from_raw(first_def, raw)
+                        for definition in definitions:
+                            data[definition.key] = value
                     time.sleep(0.3)
                 
                 if failed_registers:
@@ -204,7 +256,7 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 # Always close after reading to prevent buffer buildup
                 try:
                     self._client.close()
-                except:
+                except Exception:
                     pass
 
     def write_register(self, key: str, value: float | int) -> bool:
@@ -293,6 +345,36 @@ def get_register_definition(self, key: str) -> RegisterDefinition:
         """Expose register metadata for other components."""
         return get_register_definition(key, self._registers)
 
+    def _read_register_block(self, address: int, count: int) -> list[int] | None:
+        """Read a block of consecutive registers. Returns raw values or None on failure."""
+        try:
+            result = self._client.read_holding_registers(
+                address=address, count=count
+            )
+            if not result or (hasattr(result, "isError") and result.isError()):
+                return None
+            if hasattr(result, "registers"):
+                raw_list = list(result.registers)
+            elif isinstance(result, (list, tuple)):
+                raw_list = list(result)
+            else:
+                return None
+            if len(raw_list) != count:
+                return None
+            # Convert to signed int16 where needed
+            out: list[int] = []
+            for raw in raw_list:
+                if raw > 32767:
+                    raw = raw - 65536
+                out.append(raw)
+            return out
+        except Exception as ex:
+            _LOGGER.warning(
+                "Exception reading block at address %d count %d: %s",
+                address, count, ex,
+            )
+            return None
+
     def _read_register_value(self, definition: RegisterDefinition) -> Any | None:
         """Read and scale a single register with pymodbus 3.x."""
         try:

From c6b13eccf301e3ed0ff4ffafa78ed8305643d085 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 22:12:18 +0200
Subject: [PATCH 08/15] Add pymodbus compat layer and improve connection
 reliability

---
 custom_components/parmair/config_flow.py     | 38 +++------
 custom_components/parmair/coordinator.py     | 90 ++++++++++++--------
 custom_components/parmair/pymodbus_compat.py | 83 ++++++++++++++++++
 docs/PYMODBUS_HA_VERSIONS.md                 | 55 ++++++++++++
 test_connection.py                           | 25 ++++--
 tools/discover_registers.py                  |  9 +-
 6 files changed, 224 insertions(+), 76 deletions(-)
 create mode 100644 custom_components/parmair/pymodbus_compat.py
 create mode 100644 docs/PYMODBUS_HA_VERSIONS.md

diff --git a/custom_components/parmair/config_flow.py b/custom_components/parmair/config_flow.py
index f704b79..38c7227 100644
--- a/custom_components/parmair/config_flow.py
+++ b/custom_components/parmair/config_flow.py
@@ -17,18 +17,7 @@
 from homeassistant.loader import async_get_integration
 
 
-def _set_unit_id(client: ModbusTcpClient, unit_id: int) -> None:
-    """Set unit ID on the Modbus client for pymodbus 3.x."""
-    # Pymodbus 3.x uses 'slave' attribute
-    if hasattr(client, 'slave'):
-        client.slave = unit_id
-    # Fallback to other common attributes
-    elif hasattr(client, 'unit_id'):
-        client.unit_id = unit_id
-    elif hasattr(client, 'slave_id'):
-        client.slave_id = unit_id
-
-
+from . import pymodbus_compat
 from .const import (
     CONF_HEATER_TYPE,
     CONF_SCAN_INTERVAL,
@@ -120,15 +109,14 @@ def _detect_device_info():
             },
         ]
         
+        unit_id = data.get(CONF_SLAVE_ID, DEFAULT_SLAVE_ID)
+        
         def _read_register(address: int) -> int | None:
-            """Read a single register with pymodbus 3.x."""
+            """Read a single register (works with any pymodbus 3.x: device_id= or slave=)."""
             try:
-                # Set the unit ID on the client
-                _set_unit_id(client, data[CONF_SLAVE_ID])
-                
-                # Read using pymodbus 3.x API
-                result = client.read_holding_registers(address, count=1)
-                
+                result = pymodbus_compat.read_holding_registers(
+                    client, address, 1, unit_id
+                )
                 # Check if read was successful
                 if result and not (hasattr(result, "isError") and result.isError()):
                     # Extract register value
@@ -308,14 +296,12 @@ def _read_register(address: int) -> int | None:
     
     # Try to read a register to verify communication
     def _read_test():
-        """Test reading from the device with pymodbus 3.x."""
+        """Test reading from the device (works with any pymodbus 3.x)."""
         try:
-            # Set unit ID on client
-            _set_unit_id(client, data[CONF_SLAVE_ID])
-            
-            # Read using pymodbus 3.x API
-            result = client.read_holding_registers(power_register.address, count=1)
-            
+            unit_id = data.get(CONF_SLAVE_ID, DEFAULT_SLAVE_ID)
+            result = pymodbus_compat.read_holding_registers(
+                client, power_register.address, 1, unit_id
+            )
             return not result.isError() if hasattr(result, 'isError') else result is not None
         except Exception as ex:
             _LOGGER.debug("Test read failed: %s", ex)
diff --git a/custom_components/parmair/coordinator.py b/custom_components/parmair/coordinator.py
index 96c1858..624ffd1 100644
--- a/custom_components/parmair/coordinator.py
+++ b/custom_components/parmair/coordinator.py
@@ -2,6 +2,7 @@
 from __future__ import annotations
 
 import logging
+import random
 import threading
 import time
 from datetime import timedelta
@@ -15,13 +16,16 @@
 from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed
 from homeassistant.config_entries import ConfigEntry
 
+from . import pymodbus_compat
 from .const import (
     CONF_HEATER_TYPE,
     CONF_SCAN_INTERVAL,
     CONF_SLAVE_ID,
     CONF_SOFTWARE_VERSION,
     DEFAULT_NAME,
+    DEFAULT_PORT,
     DEFAULT_SCAN_INTERVAL,
+    DEFAULT_SLAVE_ID,
     DOMAIN,
     HARDWARE_TYPE_MAP_V2,
     HEATER_TYPE_UNKNOWN,
@@ -88,8 +92,17 @@ def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
         """Initialize the coordinator."""
         self.entry = entry
         self.host = entry.data[CONF_HOST]
-        self.port = entry.data[CONF_PORT]
-        self.slave_id = entry.data[CONF_SLAVE_ID]
+        self.port = entry.data.get(CONF_PORT, DEFAULT_PORT)
+        # Parmair devices use unit 0; default to 0 and treat legacy slave_id=1 as 0
+        raw_slave_id = entry.data.get(CONF_SLAVE_ID, DEFAULT_SLAVE_ID)
+        if raw_slave_id == 1:
+            _LOGGER.warning(
+                "Config has slave_id=1 but Parmair uses unit 0; using 0. "
+                "Delete and re-add the integration to clear this warning."
+            )
+            self.slave_id = 0
+        else:
+            self.slave_id = raw_slave_id
         self.software_version = entry.data.get(CONF_SOFTWARE_VERSION, SOFTWARE_VERSION_1)
         self.heater_type = entry.data.get(CONF_HEATER_TYPE, HEATER_TYPE_UNKNOWN)
         
@@ -135,25 +148,27 @@ async def _async_update_data(self) -> dict[str, Any]:
     def _read_modbus_data(self) -> dict[str, Any]:
         """Read data from Modbus (runs in executor)."""
         with self._lock:
-            # Close and reconnect to flush any stale responses in buffer
-            if self._client.connected:
+            # Use a fresh client per poll to avoid transaction_id mismatch from stale
+            # responses or from another Modbus client (pymodbus: "transaction_id=X but got id=Y").
+            read_client = ModbusTcpClient(host=self.host, port=self.port)
+            try:
+                if not read_client.connect():
+                    raise ModbusException("Failed to connect to Modbus device")
+                _set_unit_id(read_client, self.slave_id)
+                # Delay after connect to let device and buffers settle
+                time.sleep(0.5)
+                # Jitter to desynchronize from other Modbus clients polling the same device
+                time.sleep(random.uniform(0.2, 0.7))
+            except Exception:
                 try:
-                    self._client.close()
+                    read_client.close()
                 except Exception:
-                    pass  # Ignore close errors
-            
-            if not self._client.connect():
-                raise ModbusException("Failed to connect to Modbus device")
-            
-            # Set slave/unit ID on the client
-            _set_unit_id(self._client, self.slave_id)
-            
-            # Longer delay after connect to allow device to stabilize and clear buffers
-            time.sleep(0.3)
-            
+                    pass
+                raise
+
             # Wake-up read: power register (1001) to keep device responsive
             try:
-                _ = self._client.read_holding_registers(address=1001, count=1)
+                _ = read_client.read_holding_registers(address=1001, count=1)
             except Exception:
                 pass
             time.sleep(0.3)
@@ -165,10 +180,11 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 for definition in self._static_registers:
                     static_addr_to_defs.setdefault(definition.address, []).append(definition)
                 for start_addr, span_count in _build_read_ranges(static_addr_to_defs):
-                    block = self._read_register_block(start_addr, span_count)
-                    if block is None:
-                        time.sleep(0.5)
-                        block = self._read_register_block(start_addr, span_count)
+                    block = self._read_register_block(start_addr, span_count, read_client)
+                    for _ in range(3):
+                        if block is None:
+                            time.sleep(0.5)
+                            block = self._read_register_block(start_addr, span_count, read_client)
                     if block is not None:
                         for i, raw in enumerate(block):
                             addr = start_addr + i
@@ -192,10 +208,11 @@ def _read_modbus_data(self) -> dict[str, Any]:
 
                 # Read in batched ranges, one Modbus request per consecutive span
                 for start_addr, span_count in _build_read_ranges(address_to_definitions):
-                    block = self._read_register_block(start_addr, span_count)
-                    if block is None:
-                        time.sleep(0.5)
-                        block = self._read_register_block(start_addr, span_count)
+                    block = self._read_register_block(start_addr, span_count, read_client)
+                    for _ in range(3):
+                        if block is None:
+                            time.sleep(0.5)
+                            block = self._read_register_block(start_addr, span_count, read_client)
                     if block is None:
                         for addr in range(start_addr, start_addr + span_count):
                             if addr in address_to_definitions:
@@ -253,9 +270,8 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 _LOGGER.error("Error reading from Modbus: %s", ex)
                 raise ModbusException(f"Failed to read data: {ex}") from ex
             finally:
-                # Always close after reading to prevent buffer buildup
                 try:
-                    self._client.close()
+                    read_client.close()
                 except Exception:
                     pass
 
@@ -273,8 +289,9 @@ def write_register(self, key: str, value: float | int) -> bool:
 
                 raw_value = self._to_raw(definition, value)
                 
-                # Write using pymodbus 3.x API
-                result = self._client.write_register(definition.address, raw_value)
+                result = pymodbus_compat.write_register(
+                    self._client, definition.address, raw_value, self.slave_id
+                )
                 
                 _LOGGER.debug(
                     "Wrote %s to register %s (%d): raw=%d",
@@ -345,11 +362,14 @@ def get_register_definition(self, key: str) -> RegisterDefinition:
         """Expose register metadata for other components."""
         return get_register_definition(key, self._registers)
 
-    def _read_register_block(self, address: int, count: int) -> list[int] | None:
+    def _read_register_block(
+        self, address: int, count: int, client: ModbusTcpClient | None = None
+    ) -> list[int] | None:
         """Read a block of consecutive registers. Returns raw values or None on failure."""
+        c = client if client is not None else self._client
         try:
-            result = self._client.read_holding_registers(
-                address=address, count=count
+            result = pymodbus_compat.read_holding_registers(
+                c, address, count, self.slave_id
             )
             if not result or (hasattr(result, "isError") and result.isError()):
                 return None
@@ -378,11 +398,9 @@ def _read_register_block(self, address: int, count: int) -> list[int] | None:
     def _read_register_value(self, definition: RegisterDefinition) -> Any | None:
         """Read and scale a single register with pymodbus 3.x."""
         try:
-            # Read using pymodbus 3.x API (unit ID already set on client)
-            result = self._client.read_holding_registers(
-                address=definition.address, count=1
+            result = pymodbus_compat.read_holding_registers(
+                self._client, definition.address, 1, self.slave_id
             )
-            
             if not result or (hasattr(result, "isError") and result.isError()):
                 _LOGGER.warning(
                     "Failed reading register %s (%s) at address %d",
diff --git a/custom_components/parmair/pymodbus_compat.py b/custom_components/parmair/pymodbus_compat.py
new file mode 100644
index 0000000..5ceb23d
--- /dev/null
+++ b/custom_components/parmair/pymodbus_compat.py
@@ -0,0 +1,83 @@
+"""Pymodbus API compatibility across HA/pymodbus versions.
+
+Home Assistant bundles different pymodbus versions across releases; the parameter
+for unit/slave ID has changed over time (device_id= in 3.10+, slave= and unit=
+in older 3.x). We detect the working parameter on first use and cache it, so we
+support any version and survive HA upgrades (module reload resets the cache).
+
+See docs/PYMODBUS_HA_VERSIONS.md for HA release → pymodbus version mapping.
+"""
+
+from __future__ import annotations
+
+import logging
+import threading
+from typing import Any
+
+_LOGGER = logging.getLogger(__name__)
+
+# Cached parameter name for unit/slave ID (set on first successful call).
+# None = not yet detected. After HA upgrade, module reload clears this.
+_read_kwarg: str | None = None
+_write_kwarg: str | None = None
+_lock = threading.Lock()
+
+# Try order: 3.10+ use device_id=, older 3.x use slave=, some use unit=
+_READ_CANDIDATES = ("device_id", "slave", "unit")
+_WRITE_CANDIDATES = ("device_id", "slave", "unit")
+
+
+def read_holding_registers(
+    client: Any, address: int, count: int, unit_id: int
+) -> Any:
+    """Read holding registers with unit ID. Works with any pymodbus 3.x bundled by HA."""
+    global _read_kwarg
+    if _read_kwarg is not None:
+        return client.read_holding_registers(
+            address=address, count=count, **{_read_kwarg: unit_id}
+        )
+    with _lock:
+        if _read_kwarg is not None:
+            return client.read_holding_registers(
+                address=address, count=count, **{_read_kwarg: unit_id}
+            )
+        for kw in _READ_CANDIDATES:
+            try:
+                result = client.read_holding_registers(
+                    address=address, count=count, **{kw: unit_id}
+                )
+                _read_kwarg = kw
+                _LOGGER.debug("pymodbus read_holding_registers uses %s=", kw)
+                return result
+            except TypeError:
+                continue
+        _read_kwarg = "device_id"
+        return client.read_holding_registers(
+            address=address, count=count, device_id=unit_id
+        )
+
+
+def write_register(client: Any, address: int, value: int, unit_id: int) -> Any:
+    """Write single register with unit ID. Works with any pymodbus 3.x bundled by HA."""
+    global _write_kwarg
+    if _write_kwarg is not None:
+        return client.write_register(
+            address, value, **{_write_kwarg: unit_id}
+        )
+    with _lock:
+        if _write_kwarg is not None:
+            return client.write_register(
+                address, value, **{_write_kwarg: unit_id}
+            )
+        for kw in _WRITE_CANDIDATES:
+            try:
+                result = client.write_register(
+                    address, value, **{kw: unit_id}
+                )
+                _write_kwarg = kw
+                _LOGGER.debug("pymodbus write_register uses %s=", kw)
+                return result
+            except TypeError:
+                continue
+        _write_kwarg = "device_id"
+        return client.write_register(address, value, device_id=unit_id)
diff --git a/docs/PYMODBUS_HA_VERSIONS.md b/docs/PYMODBUS_HA_VERSIONS.md
new file mode 100644
index 0000000..4552c9e
--- /dev/null
+++ b/docs/PYMODBUS_HA_VERSIONS.md
@@ -0,0 +1,55 @@
+# Home Assistant vs pymodbus versions
+
+Home Assistant’s **built-in Modbus** integration pins a specific pymodbus version in `homeassistant/components/modbus/manifest.json`. That version can differ between HA releases and changes when you upgrade HA.
+
+This integration supports all of these by detecting the correct unit-ID parameter on first use (see `custom_components/parmair/pymodbus_compat.py`).
+
+## Unit/slave ID parameter by pymodbus version
+
+| pymodbus version | Parameter for unit/slave ID | Notes |
+|------------------|-----------------------------|--------|
+| **3.10.0+**      | `device_id=`                | Renamed from `slave=` in 3.10.0 (API change). |
+| **3.7.x – 3.9.x**| `slave=`                    | Default unit ID in calls is often 1. |
+| **3.5.x – 3.6.x**| `slave=` or `unit=`         | Older 3.x. |
+| **3.1.x – 3.4.x**| `slave=` or `unit=`         | Even older 3.x. |
+| **2.x**          | `unit=`                     | Legacy; HA modbus moved to 3.x in 2023. |
+
+So: **pymodbus ≥ 3.10** use `device_id=`, **&lt; 3.10** use `slave=` (or `unit=` in some older releases).
+
+## HA Modbus manifest history (which HA ships which pymodbus)
+
+From `home-assistant/core` `homeassistant/components/modbus/manifest.json`:
+
+| Date (commit) | pymodbus version | Likely HA release |
+|---------------|------------------|-------------------|
+| Sep 2025      | **3.11.2**      | 2025.10.x         |
+| Aug 2025      | 3.11.1, 3.11.0  | 2025.9, 2025.8    |
+| Jun 2025      | **3.9.2**       | 2025.6.x          |
+| Jan 2025      | **3.8.3**       | 2025.1.x          |
+| Dec 2024      | **3.7.4**       | 2024.12.x         |
+| Jul 2024      | 3.6.9           | 2024.7.x          |
+| Apr 2024      | 3.6.8, 3.6.7    | 2024.4.x          |
+| Mar 2024      | 3.6.6, 3.6.5    | 2024.3.x          |
+| Feb 2024      | **3.6.4**      | 2024.2.x          |
+| Jan 2024      | 2.6.3 → 3.6.x   | 2024.1.x          |
+| Oct 2023      | 3.5.4           | 2023.10.x         |
+| Sep 2023      | 3.5.0–3.5.2     | 2023.9.x          |
+| Aug 2023      | 3.4.1           | 2023.8.x          |
+| Jun 2023      | 3.3.1           | 2023.6.x          |
+| Feb 2023      | 3.1.0–3.1.3     | 2023.2.x          |
+| Oct 2021      | 2.5.3           | 2021.10.x         |
+
+So:
+
+- **HA 2025.8+** (pymodbus 3.11.0+): use **`device_id=`**.
+- **HA 2025.6 and earlier** in the table (pymodbus 3.9.2 and below): use **`slave=`** (or `unit=` on very old 3.x / 2.x).
+
+Custom integrations like Parmair can declare their own `pymodbus` requirement (e.g. `pymodbus>=3.11.2`), but when installed as a custom component they often end up using the **same pymodbus** as the HA environment (e.g. the one installed for the built-in Modbus integration). So in practice, the version that runs may still be the one from the HA release.
+
+That’s why the Parmair integration does **not** assume a single pymodbus API: it tries `device_id=` then `slave=` then `unit=` on first use and caches the one that works, so it behaves correctly across HA versions and after upgrades.
+
+## References
+
+- [HA modbus manifest.json](https://github.com/home-assistant/core/blob/dev/homeassistant/components/modbus/manifest.json)
+- [HA modbus manifest commit history](https://github.com/home-assistant/core/commits/dev/homeassistant/components/modbus/manifest.json)
+- [pymodbus API changes (3.10+: device_id)](https://pymodbus.readthedocs.io/en/stable/source/api_changes.html)
diff --git a/test_connection.py b/test_connection.py
index 0d209a4..e36e158 100644
--- a/test_connection.py
+++ b/test_connection.py
@@ -8,7 +8,7 @@
     
 Example:
     python test_connection.py 192.168.1.100
-    python test_connection.py 192.168.1.100 502 1
+    python test_connection.py 192.168.1.100 502 0
 """
 
 import sys
@@ -20,7 +20,16 @@
 REGISTER_EXHAUST_TEMP = 23  # Register 24
 REGISTER_SUPPLY_TEMP = 22  # Register 23
 
-def test_connection(host, port=502, slave_id=1):
+
+def _read_register(client, address, slave_id):
+    """Read one register; pymodbus 3.10+ uses device_id=, older uses slave=."""
+    try:
+        return client.read_holding_registers(address, 1, device_id=slave_id)
+    except TypeError:
+        return client.read_holding_registers(address, 1, slave=slave_id)
+
+
+def test_connection(host, port=502, slave_id=0):
     """Test connection to Parmair device."""
     print(f"Connecting to Parmair device at {host}:{port} (slave ID: {slave_id})")
     
@@ -37,7 +46,7 @@ def test_connection(host, port=502, slave_id=1):
         
         # Test reading power status
         print("\nReading registers...")
-        result = client.read_holding_registers(REGISTER_POWER, 1, slave=slave_id)
+        result = _read_register(client, REGISTER_POWER, slave_id)
         
         if result.isError():
             print(f"❌ Error reading register {REGISTER_POWER}: {result}")
@@ -49,7 +58,7 @@ def test_connection(host, port=502, slave_id=1):
         print(f"✅ Power State (Reg 208): {power_state} ({power_states.get(power_state, 'Unknown')})")
         
         # Read control state
-        result = client.read_holding_registers(REGISTER_CONTROL_STATE, 1, slave=slave_id)
+        result = _read_register(client, REGISTER_CONTROL_STATE, slave_id)
         if not result.isError():
             control_state = result.registers[0]
             control_states = {
@@ -59,13 +68,13 @@ def test_connection(host, port=502, slave_id=1):
             print(f"✅ Control State (Reg 185): {control_state} ({control_states.get(control_state, f'Mode {control_state}')})")
         
         # Read exhaust temperature
-        result = client.read_holding_registers(REGISTER_EXHAUST_TEMP, 1, slave=slave_id)
+        result = _read_register(client, REGISTER_EXHAUST_TEMP, slave_id)
         if not result.isError():
             temp = result.registers[0] / 10.0
             print(f"✅ Exhaust Temperature (Reg 24): {temp}°C")
         
-        # Read supply temperature  
-        result = client.read_holding_registers(REGISTER_SUPPLY_TEMP, 1, slave=slave_id)
+        # Read supply temperature
+        result = _read_register(client, REGISTER_SUPPLY_TEMP, slave_id)
         if not result.isError():
             temp = result.registers[0] / 10.0
             print(f"✅ Supply Temperature (Reg 23): {temp}°C")
@@ -98,7 +107,7 @@ def main():
     
     host = sys.argv[1]
     port = int(sys.argv[2]) if len(sys.argv) > 2 else 502
-    slave_id = int(sys.argv[3]) if len(sys.argv) > 3 else 1
+    slave_id = int(sys.argv[3]) if len(sys.argv) > 3 else 0
     
     try:
         success = test_connection(host, port, slave_id)
diff --git a/tools/discover_registers.py b/tools/discover_registers.py
index f27b2ae..4b3bfa2 100644
--- a/tools/discover_registers.py
+++ b/tools/discover_registers.py
@@ -131,17 +131,14 @@
 
 
 def read_register(client: ModbusTcpClient, address: int, slave_id: int) -> int | None:
-    """Try to read a single register."""
+    """Try to read a single register. pymodbus 3.10+ uses device_id=; older uses slave=."""
     try:
-        # pymodbus 3.11+ API
-        result = client.read_holding_registers(address, count=1, slave=slave_id)
+        result = client.read_holding_registers(address, count=1, device_id=slave_id)
     except TypeError:
         try:
-            # Try device_id instead of slave
-            result = client.read_holding_registers(address, count=1, device_id=slave_id)
+            result = client.read_holding_registers(address, count=1, slave=slave_id)
         except TypeError:
             try:
-                # Older API with positional args
                 result = client.read_holding_registers(address, 1, unit=slave_id)
             except TypeError:
                 return None

From 00d3f258411e02bfcc9e4c5722173b9f40c0b63c Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 22:28:53 +0200
Subject: [PATCH 09/15] Add version-aware V1/V2 state display mappings

---
 custom_components/parmair/const.py  |  49 ++++++++++++-
 custom_components/parmair/fan.py    |   9 ++-
 custom_components/parmair/sensor.py | 105 ++++++++++++++++++++--------
 custom_components/parmair/switch.py |  13 +++-
 docs/V1_V2_MAPPINGS.md              |  88 +++++++++++++++++++++++
 5 files changed, 231 insertions(+), 33 deletions(-)
 create mode 100644 docs/V1_V2_MAPPINGS.md

diff --git a/custom_components/parmair/const.py b/custom_components/parmair/const.py
index 60afa30..be8f76f 100644
--- a/custom_components/parmair/const.py
+++ b/custom_components/parmair/const.py
@@ -483,7 +483,7 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
     return reg_map[key]
 
 
-# Operating modes for IV01_CONTROLSTATE
+# Operating modes for IV01_CONTROLSTATE (V1) / USERSTATECONTROL_FO (V2)
 MODE_STOP = 0
 MODE_AWAY = 1
 MODE_HOME = 2
@@ -495,6 +495,30 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
 MODE_OVERPRESSURE_TIMER = 8
 MODE_MANUAL = 9
 
+# Control state display mapping (differs by firmware version)
+# V1.x IV01_CONTROLSTATE_FO: Stop, Away, Home, Boost, Overpressure, timers, Manual
+# V2.x USERSTATECONTROL_FO: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
+CONTROL_STATE_MAP_V1: Dict[int, str] = {
+    MODE_STOP: "Stop",
+    MODE_AWAY: "Away",
+    MODE_HOME: "Home",
+    MODE_BOOST: "Boost",
+    MODE_OVERPRESSURE: "Overpressure",
+    5: "Away Timer",
+    6: "Home Timer",
+    7: "Boost Timer",
+    8: "Overpressure Timer",
+    MODE_MANUAL: "Manual",
+}
+CONTROL_STATE_MAP_V2: Dict[int, str] = {
+    0: "Off",
+    1: "Away",
+    2: "Home",
+    3: "Boost",
+    4: "Sauna",
+    5: "Fireplace",
+}
+
 # Speed control values for IV01_SPEED
 SPEED_AUTO = 0
 SPEED_STOP = 1
@@ -504,8 +528,29 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
 SPEED_4 = 5
 SPEED_5 = 6
 
-# POWER_BTN states
+# POWER_BTN states (V1: POWER_BTN_FI = Off/Shutting Down/Starting/Running)
 POWER_OFF = 0
 POWER_SHUTTING_DOWN = 1
 POWER_STARTING = 2
 POWER_RUNNING = 3
+
+# Power state display mapping (differs by firmware version)
+# V1.x POWER_BTN_FI: 0=Off, 1=Shutting Down, 2=Starting, 3=Running
+# V2.x UNIT_CONTROL_FO: 0=Off, 1=On
+POWER_STATE_MAP_V1: Dict[int, str] = {
+    POWER_OFF: "Off",
+    POWER_SHUTTING_DOWN: "Shutting Down",
+    POWER_STARTING: "Starting",
+    POWER_RUNNING: "Running",
+}
+POWER_STATE_MAP_V2: Dict[int, str] = {0: "Off", 1: "On"}
+
+# Filter state display mapping (differs by firmware version)
+# V1.x FILTER_STATE_FI: 0=Replace, 1=OK
+FILTER_STATE_MAP_V1: Dict[int, str] = {0: "Replace", 1: "OK"}
+# V2.x FILTER_STATE_FI: 0=Idle/OK, 1=Acknowledge Change, 2=Replace Reminder
+FILTER_STATE_MAP_V2: Dict[int, str] = {
+    0: "OK",
+    1: "Acknowledge Change",
+    2: "Replace Reminder",
+}
diff --git a/custom_components/parmair/fan.py b/custom_components/parmair/fan.py
index 9cbe561..3ff0eb0 100644
--- a/custom_components/parmair/fan.py
+++ b/custom_components/parmair/fan.py
@@ -25,6 +25,7 @@
     POWER_RUNNING,
     REG_CONTROL_STATE,
     REG_POWER,
+    SOFTWARE_VERSION_2,
 )
 from .coordinator import ParmairCoordinator
 
@@ -72,7 +73,13 @@ def is_on(self) -> bool:
         """Return true if the fan is on."""
         power_state = self.coordinator.data.get("power", POWER_OFF)
         control_state = self.coordinator.data.get("control_state", MODE_STOP)
-        return power_state == POWER_RUNNING and control_state != MODE_STOP
+        # V1: power 3 = Running. V2: power 1 = On.
+        is_v2 = (
+            self.coordinator.software_version == SOFTWARE_VERSION_2
+            or str(self.coordinator.software_version).startswith("2.")
+        )
+        power_ok = (power_state == 1) if is_v2 else (power_state == POWER_RUNNING)
+        return power_ok and control_state != MODE_STOP
 
     @property
     def percentage(self) -> int | None:
diff --git a/custom_components/parmair/sensor.py b/custom_components/parmair/sensor.py
index 89ed63c..e00cb75 100644
--- a/custom_components/parmair/sensor.py
+++ b/custom_components/parmair/sensor.py
@@ -23,6 +23,12 @@
 from .const import (
     DOMAIN,
     DEFAULT_NAME,
+    CONTROL_STATE_MAP_V1,
+    CONTROL_STATE_MAP_V2,
+    FILTER_STATE_MAP_V1,
+    FILTER_STATE_MAP_V2,
+    POWER_STATE_MAP_V1,
+    POWER_STATE_MAP_V2,
     SOFTWARE_VERSION_2,
     HEATER_TYPE_WATER_V1,
     HEATER_TYPE_ELECTRIC_V1,
@@ -36,6 +42,49 @@
 _LOGGER = logging.getLogger(__name__)
 
 
+def _filter_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
+    """Return filter state mapping based on device firmware version.
+    Prefers device-reported software_version over config entry."""
+    sw = coordinator.data.get("software_version")
+    if sw is not None:
+        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+            return FILTER_STATE_MAP_V2
+        return FILTER_STATE_MAP_V1
+    # Fallback to config entry when device data not yet available
+    cfg = coordinator.software_version
+    if cfg == SOFTWARE_VERSION_2 or str(cfg).startswith("2."):
+        return FILTER_STATE_MAP_V2
+    return FILTER_STATE_MAP_V1
+
+
+def _power_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
+    """Return power state mapping based on device firmware version.
+    V1: Off, Shutting Down, Starting, Running. V2: Off, On."""
+    sw = coordinator.data.get("software_version")
+    if sw is not None:
+        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+            return POWER_STATE_MAP_V2
+        return POWER_STATE_MAP_V1
+    cfg = coordinator.software_version
+    if cfg == SOFTWARE_VERSION_2 or str(cfg).startswith("2."):
+        return POWER_STATE_MAP_V2
+    return POWER_STATE_MAP_V1
+
+
+def _control_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
+    """Return control state mapping based on device firmware version.
+    V1: Stop, Away, Home, Boost, Overpressure, timers, Manual. V2: Off, Away, Home, Boost, Sauna, Fireplace."""
+    sw = coordinator.data.get("software_version")
+    if sw is not None:
+        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+            return CONTROL_STATE_MAP_V2
+        return CONTROL_STATE_MAP_V1
+    cfg = coordinator.software_version
+    if cfg == SOFTWARE_VERSION_2 or str(cfg).startswith("2."):
+        return CONTROL_STATE_MAP_V2
+    return CONTROL_STATE_MAP_V1
+
+
 async def async_setup_entry(
     hass: HomeAssistant,
     entry: ConfigEntry,
@@ -74,7 +123,13 @@ async def async_setup_entry(
         
         # State sensors
         ParmairBinarySensor(coordinator, entry, "defrost_state", "Defrost State", {0: "Off", 1: "Active"}),
-        ParmairBinarySensor(coordinator, entry, "filter_state", "Filter Status", {0: "Replace", 1: "OK"}),
+        ParmairBinarySensor(
+            coordinator,
+            entry,
+            "filter_state",
+            "Filter Status",
+            _filter_state_map(coordinator),
+        ),
         
         # Performance sensors
         ParmairPercentageSensor(coordinator, entry, "heat_recovery_efficiency", "Heat Recovery Efficiency"),
@@ -323,24 +378,14 @@ def native_value(self) -> float | None:
 
 
 class ParmairControlStateSensor(ParmairRegisterEntity, SensorEntity):
-    """Representation of control state with mapped values."""
+    """Representation of control state with mapped values.
+
+    V1.x (IV01_CONTROLSTATE_FO): Stop, Away, Home, Boost, Overpressure, timers, Manual.
+    V2.x (USERSTATECONTROL_FO): Off, Away, Home, Boost, Sauna, Fireplace.
+    """
 
     _attr_has_entity_name = True
     _attr_device_class = SensorDeviceClass.ENUM
-    _attr_options = ["Stop", "Away", "Home", "Boost", "Overpressure", "Away Timer", "Home Timer", "Boost Timer", "Overpressure Timer", "Manual"]
-
-    STATE_MAP = {
-        0: "Stop",
-        1: "Away",
-        2: "Home",
-        3: "Boost",
-        4: "Overpressure",
-        5: "Away Timer",
-        6: "Home Timer",
-        7: "Boost Timer",
-        8: "Overpressure Timer",
-        9: "Manual"
-    }
 
     def __init__(
         self,
@@ -351,14 +396,17 @@ def __init__(
     ) -> None:
         """Initialize the sensor."""
         super().__init__(coordinator, entry, data_key, name)
+        state_map = _control_state_map(coordinator)
+        self._attr_options = list(state_map.values())
 
     @property
     def native_value(self) -> str | None:
-        """Return the sensor value."""
+        """Return the sensor value using correct mapping for firmware version."""
         raw_value = self.coordinator.data.get(self._data_key)
         if raw_value is None:
             return None
-        return self.STATE_MAP.get(raw_value, f"Unknown ({raw_value})")
+        state_map = _control_state_map(self.coordinator)
+        return state_map.get(int(raw_value), f"Unknown ({raw_value})")
 
 
 class ParmairSpeedControlSensor(ParmairRegisterEntity, SensorEntity):
@@ -394,18 +442,14 @@ def extra_state_attributes(self) -> dict[str, str]:
 
 
 class ParmairPowerStateSensor(ParmairRegisterEntity, SensorEntity):
-    """Representation of power state with mapped values."""
+    """Representation of power state with mapped values.
+
+    V1.x (POWER_BTN_FI): 0=Off, 1=Shutting Down, 2=Starting, 3=Running.
+    V2.x (UNIT_CONTROL_FO): 0=Off, 1=On.
+    """
 
     _attr_has_entity_name = True
     _attr_device_class = SensorDeviceClass.ENUM
-    _attr_options = ["Off", "Shutting Down", "Starting", "Running"]
-
-    STATE_MAP = {
-        0: "Off",
-        1: "Shutting Down",
-        2: "Starting",
-        3: "Running"
-    }
 
     def __init__(
         self,
@@ -416,14 +460,17 @@ def __init__(
     ) -> None:
         """Initialize the sensor."""
         super().__init__(coordinator, entry, data_key, name)
+        state_map = _power_state_map(coordinator)
+        self._attr_options = list(state_map.values())
 
     @property
     def native_value(self) -> str | None:
-        """Return the sensor value."""
+        """Return the sensor value using correct mapping for firmware version."""
         raw_value = self.coordinator.data.get(self._data_key)
         if raw_value is None:
             return None
-        return self.STATE_MAP.get(raw_value, f"Unknown ({raw_value})")
+        state_map = _power_state_map(self.coordinator)
+        return state_map.get(int(raw_value), f"Unknown ({raw_value})")
 
 
 class ParmairHeaterTypeSensor(ParmairRegisterEntity, SensorEntity):
diff --git a/custom_components/parmair/switch.py b/custom_components/parmair/switch.py
index 890a907..d232e96 100644
--- a/custom_components/parmair/switch.py
+++ b/custom_components/parmair/switch.py
@@ -24,6 +24,7 @@
     REG_SUMMER_MODE,
     REG_SUMMER_MODE_TEMP_LIMIT,
     REG_TIME_PROGRAM_ENABLE,
+    SOFTWARE_VERSION_2,
 )
 from .coordinator import ParmairCoordinator
 
@@ -110,7 +111,17 @@ def __init__(
     def is_on(self) -> bool | None:
         """Return true if switch is on."""
         value = self.coordinator.data.get(self._data_key)
-        return value == 1 if value is not None else None
+        if value is None:
+            return None
+        # V2 summer mode (AUTO_SUMMER_COOL_S): 0=off, 1=on, 2=auto
+        if self._data_key == REG_SUMMER_MODE:
+            is_v2 = (
+                self.coordinator.software_version == SOFTWARE_VERSION_2
+                or str(self.coordinator.software_version).startswith("2.")
+            )
+            if is_v2:
+                return value in (1, 2)
+        return value == 1
 
     @property
     def extra_state_attributes(self) -> dict[str, Any] | None:
diff --git a/docs/V1_V2_MAPPINGS.md b/docs/V1_V2_MAPPINGS.md
new file mode 100644
index 0000000..a014629
--- /dev/null
+++ b/docs/V1_V2_MAPPINGS.md
@@ -0,0 +1,88 @@
+# Parmair firmware V1 vs V2 – register and mapping differences
+
+This document lists mapping and behavioural differences between **firmware 1.x** (e.g. MAC 80/100/150) and **firmware 2.x** (e.g. MAC 120 v2, MAC 2). The integration uses these to show correct labels and options in Home Assistant.
+
+## Power state
+
+| Version | Register        | Values |
+|--------|-----------------|--------|
+| **V1** | POWER_BTN_FI    | 0=Off, 1=Shutting Down, 2=Starting, 3=Running |
+| **V2** | UNIT_CONTROL_FO | 0=Off, 1=On |
+
+**Integration:** `ParmairPowerStateSensor` uses `POWER_STATE_MAP_V1` / `POWER_STATE_MAP_V2`. Fan `is_on` treats V2 value 1 as “on” and V1 value 3 as “running”.
+
+---
+
+## Control state (user mode)
+
+| Version | Register            | Values |
+|--------|---------------------|--------|
+| **V1** | IV01_CONTROLSTATE_FO | 0=Stop, 1=Away, 2=Home, 3=Boost, 4=Overpressure, 5=Away Timer, 6=Home Timer, 7=Boost Timer, 8=Overpressure Timer, 9=Manual |
+| **V2** | USERSTATECONTROL_FO | 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace |
+
+**Integration:** `ParmairControlStateSensor` uses `CONTROL_STATE_MAP_V1` / `CONTROL_STATE_MAP_V2`. Fan presets (away/home/boost) use the same numeric values 1/2/3 on both. On V2, “Overpressure” switch reflects Sauna (4) or Fireplace (5).
+
+---
+
+## Home / Boost / Overpressure state (V2)
+
+On **V2**, `home_state`, `boost_state` and `overpressure_state` are not separate registers; they are derived in the coordinator from `USERSTATECONTROL_FO` (register 1181):
+
+- **home_state:** 1 when control_state == 2 (Home), else 0  
+- **boost_state:** 1 when control_state == 3 (Boost), else 0  
+- **overpressure_state:** 1 when control_state in (4, 5) (Sauna, Fireplace), else 0  
+
+So the same binary sensors and maps {0: "Away", 1: "Home"} and {0: "Off", 1: "On"} work for both versions.
+
+---
+
+## Heater type
+
+| Version | Register (concept) | Values |
+|--------|---------------------|--------|
+| **V1** | HEAT_RADIATOR_TYPE  | 0=Water, 1=Electric, 2=None |
+| **V2** | HEATPUMP_RADIATOR_ENABLE / HEAT_RADIATOR_TYPE | 0=Electric, 1=Water, 2=None |
+
+**Integration:** `ParmairHeaterTypeSensor` uses `STATE_MAP_V1` / `STATE_MAP_V2` in `const.py` (reversed 0/1 for Water vs Electric).
+
+---
+
+## Filter state
+
+| Version | Register       | Values |
+|--------|----------------|--------|
+| **V1** | FILTER_STATE_FI | 0=Replace, 1=OK |
+| **V2** | FILTER_STATE_FI | 0=OK (Idle), 1=Acknowledge Change, 2=Replace Reminder |
+
+**Integration:** `_filter_state_map(coordinator)` and `ParmairBinarySensor` for “Filter Status” use `FILTER_STATE_MAP_V1` / `FILTER_STATE_MAP_V2`.
+
+---
+
+## Summer mode (switch)
+
+| Version | Register           | Values |
+|--------|--------------------|--------|
+| **V1** | SUMMER_MODE_S       | 0=Off, 1=On (typical) |
+| **V2** | AUTO_SUMMER_COOL_S  | 0=Off, 1=On, 2=Auto |
+
+**Integration:** `ParmairSwitch` for Summer Mode: on V2, `is_on` is true when value is 1 or 2. Turn on writes 1, turn off writes 0.
+
+---
+
+## Other mappings (same or assumed same)
+
+- **Speed (actual_speed / speed_control):** Same 0–6 semantics (Auto, Stop, 1–5) on both; register addresses differ.
+- **Defrost state:** Binary 0/1; same meaning.
+- **Boost time setting:** 0=30 min … 4=180 min; same mapping used for both (no V2-specific doc).
+- **Overpressure time setting:** 0=15 min … 4=120 min; same mapping used for both.
+- **Filter interval:** 0=3 months, 1=4 months, 2=6 months (v2_register); same as integration.
+
+---
+
+## Constants and helpers in code
+
+- **const.py:** `POWER_STATE_MAP_V1/V2`, `CONTROL_STATE_MAP_V1/V2`, `FILTER_STATE_MAP_V1/V2`, heater type constants and register definitions per version.
+- **sensor.py:** `_power_state_map()`, `_control_state_map()`, `_filter_state_map()`; Power State, Control State, Heater Type and Filter Status sensors choose map from coordinator firmware version.
+- **fan.py:** `is_on` uses V2 power 1 = on, V1 power 3 = running.
+- **switch.py:** Summer mode `is_on` for V2 uses value in (1, 2).
+- **coordinator.py:** For V2, derives `home_state`, `boost_state`, `overpressure_state` from `control_state` (USERSTATECONTROL_FO).

From 1f529e98ecf8b9215d13a8acb286087c585a2761 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 22:41:37 +0200
Subject: [PATCH 10/15] Add V2 filter state display mapping test

---
 tests/test_interpretation.py | 24 +++++++++++++++++++++++-
 1 file changed, 23 insertions(+), 1 deletion(-)

diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
index 5ebe1ec..2dfa8df 100644
--- a/tests/test_interpretation.py
+++ b/tests/test_interpretation.py
@@ -20,13 +20,18 @@
 
 import re
 
+from custom_components.parmair.const import (
+    FILTER_STATE_MAP_V1,
+    FILTER_STATE_MAP_V2,
+    SOFTWARE_VERSION_2,
+)
 from tools.mock_coordinator import (
     MockCoordinator,
     HARDWARE_TYPE_MAP_V2,
     REG_POWER,
     REG_CONTROL_STATE,
-    SOFTWARE_VERSION_2,
     get_registers_for_version,
+    load_dump,
 )
 
 
@@ -228,6 +233,23 @@ def test_filter_state_valid(self, coordinator: MockCoordinator) -> None:
         # V2: 0=OK, 1=Ack, 2=Reminder
         assert state in (0, 1, 2), f"Invalid filter state: {state}"
 
+    def test_filter_state_display_mapping_v2(self) -> None:
+        """V2 filter_state=0 (Idle/OK) must display as 'OK', not 'Replace'."""
+        coord = load_dump(PROJECT_ROOT / "tests" / "fixtures" / "MAC120-full-v2.json")
+        state = coord.data.get("filter_state")
+        assert state is not None, "Fixture must have filter_state"
+        is_v2 = (
+            coord.software_version == SOFTWARE_VERSION_2
+            or str(coord.software_version).startswith("2.")
+        )
+        assert is_v2, "MAC120-full-v2 fixture should be V2"
+        mapping = FILTER_STATE_MAP_V2 if is_v2 else FILTER_STATE_MAP_V1
+        display = mapping.get(int(state), "Unknown")
+        assert display == "OK", (
+            f"V2 filter_state=0 must display 'OK', got '{display}'. "
+            "V1 and V2 use different mappings (V1: 0=Replace, V2: 0=OK)."
+        )
+
     def test_filter_date_valid(self, coordinator: MockCoordinator) -> None:
         """Filter date components should be valid."""
         day = coordinator.data.get("filter_day")

From df1bddeb96582c2f3d99fef172d5f4a3e1aa8b4a Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 22:55:23 +0200
Subject: [PATCH 11/15] Fix ruff linting and formatting

---
 .github/workflows/tests.yml                  |   8 +-
 custom_components/parmair/__init__.py        |  14 +-
 custom_components/parmair/button.py          |   1 +
 custom_components/parmair/config_flow.py     | 211 +++++------
 custom_components/parmair/const.py           | 365 +++++++++----------
 custom_components/parmair/coordinator.py     | 134 ++++---
 custom_components/parmair/fan.py             |  38 +-
 custom_components/parmair/number.py          |  19 +-
 custom_components/parmair/pymodbus_compat.py |  24 +-
 custom_components/parmair/select.py          |  29 +-
 custom_components/parmair/sensor.py          |  94 ++---
 custom_components/parmair/switch.py          | 140 ++++---
 test_connection.py                           |  53 +--
 tests/__init__.py                            |   1 -
 tests/conftest.py                            |   2 +-
 tests/test_interpretation.py                 | 107 +++---
 tools/discover_registers.py                  |  39 +-
 tools/dump_registers.py                      |  21 +-
 tools/mock_coordinator.py                    |  62 ++--
 tools/test_interpretation.py                 |  84 ++---
 20 files changed, 716 insertions(+), 730 deletions(-)

diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index cec52a2..12c6a75 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -51,11 +51,7 @@ jobs:
                   pip install -r requirements-test.txt
 
             - name: Run Ruff linter
-              run: |
-                  ruff check custom_components/ tools/ tests/
-              continue-on-error: true
+              run: ruff check custom_components/ tools/ tests/
 
             - name: Run Ruff formatter check
-              run: |
-                  ruff format --check custom_components/ tools/ tests/
-              continue-on-error: true
+              run: ruff format --check custom_components/ tools/ tests/
diff --git a/custom_components/parmair/__init__.py b/custom_components/parmair/__init__.py
index 454dc74..fdcadb1 100644
--- a/custom_components/parmair/__init__.py
+++ b/custom_components/parmair/__init__.py
@@ -1,8 +1,8 @@
 """The Parmair Air Conditioning integration."""
+
 from __future__ import annotations
 
 import logging
-from datetime import timedelta
 
 from homeassistant.config_entries import ConfigEntry
 from homeassistant.const import Platform
@@ -27,21 +27,21 @@
 async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
     """Set up Parmair from a config entry."""
     _LOGGER.debug("Setting up Parmair integration for %s", entry.data.get("host"))
-    
+
     coordinator = ParmairCoordinator(hass, entry)
-    
+
     try:
         await coordinator.async_config_entry_first_refresh()
     except Exception as ex:
         raise ConfigEntryNotReady(
             f"Unable to connect to Parmair device at {entry.data.get('host')}"
         ) from ex
-    
+
     hass.data.setdefault(DOMAIN, {})
     hass.data[DOMAIN][entry.entry_id] = coordinator
-    
+
     await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
-    
+
     return True
 
 
@@ -49,5 +49,5 @@ async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
     """Unload a config entry."""
     if unload_ok := await hass.config_entries.async_unload_platforms(entry, PLATFORMS):
         hass.data[DOMAIN].pop(entry.entry_id)
-    
+
     return unload_ok
diff --git a/custom_components/parmair/button.py b/custom_components/parmair/button.py
index ce17e84..c3db84b 100644
--- a/custom_components/parmair/button.py
+++ b/custom_components/parmair/button.py
@@ -1,4 +1,5 @@
 """Button platform for Parmair MAC integration."""
+
 from __future__ import annotations
 
 import logging
diff --git a/custom_components/parmair/config_flow.py b/custom_components/parmair/config_flow.py
index 38c7227..de85acb 100644
--- a/custom_components/parmair/config_flow.py
+++ b/custom_components/parmair/config_flow.py
@@ -1,21 +1,20 @@
 """Config flow for Parmair integration."""
+
 from __future__ import annotations
 
 import logging
 import time
 from typing import Any
 
-import voluptuous as vol
+import homeassistant.helpers.config_validation as cv
 import pymodbus
-from pymodbus.client import ModbusTcpClient
-
+import voluptuous as vol
 from homeassistant import config_entries
 from homeassistant.const import CONF_HOST, CONF_NAME, CONF_PORT
 from homeassistant.core import HomeAssistant
 from homeassistant.data_entry_flow import FlowResult
-import homeassistant.helpers.config_validation as cv
 from homeassistant.loader import async_get_integration
-
+from pymodbus.client import ModbusTcpClient
 
 from . import pymodbus_compat
 from .const import (
@@ -32,9 +31,7 @@
     HEATER_TYPE_NONE,
     HEATER_TYPE_UNKNOWN,
     HEATER_TYPE_WATER,
-    REG_HEATER_TYPE,
     REG_POWER,
-    REG_SOFTWARE_VERSION,
     SOFTWARE_VERSION_1,
     SOFTWARE_VERSION_2,
     SOFTWARE_VERSION_UNKNOWN,
@@ -64,18 +61,18 @@ class CannotConnect(Exception):
 async def validate_connection(hass: HomeAssistant, data: dict[str, Any]) -> dict[str, Any]:
     """Validate the user input allows us to connect and detect device info."""
     client = ModbusTcpClient(host=data[CONF_HOST], port=data[CONF_PORT])
-    
+
     def _connect():
         """Connect to the Modbus device."""
         return client.connect()
-    
+
     # Run the blocking connection in executor
     connected = await hass.async_add_executor_job(_connect)
-    
+
     if not connected:
         client.close()
         raise CannotConnect
-    
+
     # Auto-detect software version and heater type with retry logic
     def _detect_device_info():
         """Detect software version and heater type from device with retries."""
@@ -83,14 +80,14 @@ def _detect_device_info():
         detected_heater_type = HEATER_TYPE_UNKNOWN
         detected_firmware_registers = None  # Track which address set worked
         detected_machine_type = None  # Track detected machine type value
-        
+
         # Log pymodbus version for debugging
-        pymodbus_version = getattr(pymodbus, '__version__', 'unknown')
+        pymodbus_version = getattr(pymodbus, "__version__", "unknown")
         _LOGGER.info("Starting device auto-detection... (pymodbus version: %s)", pymodbus_version)
-        
+
         # Longer initial delay after connection for device to stabilize during setup
         time.sleep(1.0)
-        
+
         # Two-register consensus detection for robust firmware identification
         # Each firmware version has unique SOFTWARE_VERSION and VENT_MACHINE addresses
         # Both registers must be readable for positive identification
@@ -108,28 +105,26 @@ def _detect_device_info():
                 "sw_range": (1.0, 1.99),
             },
         ]
-        
+
         unit_id = data.get(CONF_SLAVE_ID, DEFAULT_SLAVE_ID)
-        
+
         def _read_register(address: int) -> int | None:
             """Read a single register (works with any pymodbus 3.x: device_id= or slave=)."""
             try:
-                result = pymodbus_compat.read_holding_registers(
-                    client, address, 1, unit_id
-                )
+                result = pymodbus_compat.read_holding_registers(client, address, 1, unit_id)
                 # Check if read was successful
                 if result and not (hasattr(result, "isError") and result.isError()):
                     # Extract register value
                     if hasattr(result, "registers"):
                         return result.registers[0]
-                    elif isinstance(result, (list, tuple)):
+                    elif isinstance(result, list | tuple):
                         return result[0]
                     else:
                         return result
             except Exception as ex:
                 _LOGGER.debug("Failed to read register at address %d: %s", address, ex)
             return None
-        
+
         # Warm-up: Read universal register (1001 - power) repeatedly until device responds
         # This "wakes up" the device and ensures it's ready for version detection
         _LOGGER.debug("Warming up connection by reading power register (1001)...")
@@ -142,90 +137,95 @@ def _read_register(address: int) -> int | None:
                 break
             _LOGGER.debug("Warm-up attempt %d failed, waiting 500ms...", attempt + 1)
             time.sleep(0.5)
-        
+
         if not warmup_success:
             _LOGGER.warning("Device warm-up failed after 5 attempts, detection may fail")
-        
+
         # Try each firmware detection set
         for detection_set in detection_sets:
             firmware = detection_set["firmware"]
             sw_address = detection_set["sw_address"]
             vm_address = detection_set["vm_address"]
             sw_min, sw_max = detection_set["sw_range"]
-            
+
             _LOGGER.debug(
                 "Trying two-register consensus detection for firmware %s (SW:%d, VM:%d)",
-                firmware, sw_address, vm_address
+                firmware,
+                sw_address,
+                vm_address,
             )
-            
+
             # Read both registers with delay between reads
             raw_sw = _read_register(sw_address)
             time.sleep(0.2)  # Delay between register reads during detection
             raw_vm = _read_register(vm_address)
             time.sleep(0.1)  # Small delay before validation
-            
+
             # Validate both registers
             sw_valid = False
             vm_readable = False
-            
+
             if raw_sw is not None and 0 < raw_sw < 10000:
                 sw_version = raw_sw * 0.01
                 if sw_min <= sw_version <= sw_max:
                     sw_valid = True
                     _LOGGER.debug(
                         "Address %d returned valid version %.2f for firmware %s",
-                        sw_address, sw_version, firmware
+                        sw_address,
+                        sw_version,
+                        firmware,
                     )
                 else:
                     _LOGGER.debug(
                         "Address %d version %.2f outside expected range %.2f-%.2f",
-                        sw_address, sw_version, sw_min, sw_max
+                        sw_address,
+                        sw_version,
+                        sw_min,
+                        sw_max,
                     )
             else:
                 _LOGGER.debug("Address %d returned invalid or no data", sw_address)
-            
+
             if raw_vm is not None:
                 vm_readable = True
-                _LOGGER.debug(
-                    "Address %d returned machine type value %d",
-                    vm_address, raw_vm
-                )
+                _LOGGER.debug("Address %d returned machine type value %d", vm_address, raw_vm)
             else:
-                _LOGGER.debug(
-                    "Address %d returned no data",
-                    vm_address
-                )
-            
+                _LOGGER.debug("Address %d returned no data", vm_address)
+
             # Both registers must be readable for consensus
             if sw_valid and vm_readable:
                 if firmware == "2.xx":
                     detected_sw_version = SOFTWARE_VERSION_2
                 else:
                     detected_sw_version = SOFTWARE_VERSION_1
-                
+
                 detected_firmware_registers = firmware
                 detected_machine_type = raw_vm  # Store detected machine type
-                
+
                 _LOGGER.info(
                     "Firmware %s confirmed by two-register consensus: "
                     "SW version %.2f (addr %d) + Machine type %d (addr %d)",
-                    firmware, sw_version, sw_address, raw_vm, vm_address
+                    firmware,
+                    sw_version,
+                    sw_address,
+                    raw_vm,
+                    vm_address,
                 )
                 break  # Success, exit detection loop
             else:
                 _LOGGER.debug(
                     "Firmware %s consensus failed (SW valid: %s, VM readable: %s)",
-                    firmware, sw_valid, vm_readable
+                    firmware,
+                    sw_valid,
+                    vm_readable,
                 )
-        
+
         # If software version was not detected, return None to trigger manual selection
         if detected_sw_version == SOFTWARE_VERSION_UNKNOWN:
-            _LOGGER.warning(
-                "Could not auto-detect software version via two-register consensus"
-            )
+            _LOGGER.warning("Could not auto-detect software version via two-register consensus")
             # Return None to indicate detection failed - user will be asked to select manually
             return None
-        
+
         # Now detect heater type using the correct address for detected firmware
         heater_addresses = []
         if detected_firmware_registers == "2.xx":
@@ -234,23 +234,27 @@ def _read_register(address: int) -> int | None:
         else:
             # Firmware 1.xx: heater type at address 1240
             heater_addresses = [(1240, "1.xx")]
-        
+
         # Try to read heater type from the correct address
         for heater_address, fw_label in heater_addresses:
-            _LOGGER.debug("Trying heater type detection with address %d (firmware %s)", heater_address, fw_label)
-            
+            _LOGGER.debug(
+                "Trying heater type detection with address %d (firmware %s)",
+                heater_address,
+                fw_label,
+            )
+
             raw_heater = _read_register(heater_address)
-            
+
             # Validate heater type (0=Water, 1=Electric, 2=None)
             if raw_heater is not None and raw_heater in [0, 1, 2]:
                 detected_heater_type = int(raw_heater)
-                
+
                 heater_names = {
                     HEATER_TYPE_NONE: "None",
                     HEATER_TYPE_WATER: "Water",
                     HEATER_TYPE_ELECTRIC: "Electric",
                 }
-                
+
                 _LOGGER.info(
                     "Auto-detected heater type: %s (%s) from address %d (firmware %s)",
                     detected_heater_type,
@@ -260,40 +264,42 @@ def _read_register(address: int) -> int | None:
                 )
                 break  # Success, exit address loop
             else:
-                _LOGGER.debug("Address %d returned invalid heater type: %s", heater_address, raw_heater)
-        
+                _LOGGER.debug(
+                    "Address %d returned invalid heater type: %s", heater_address, raw_heater
+                )
+
         # Use defaults if detection failed
         if detected_heater_type == HEATER_TYPE_UNKNOWN:
             detected_heater_type = HEATER_TYPE_NONE
-            _LOGGER.warning(
-                "Heater type detection failed, defaulting to None (no heater)"
-            )
-        
+            _LOGGER.warning("Heater type detection failed, defaulting to None (no heater)")
+
         # Log final detection summary
         _LOGGER.info(
             "=== Detection Complete === Firmware: %s | Machine Type: %s | Heater: %s",
             detected_sw_version,
             detected_machine_type if detected_machine_type is not None else "Unknown",
-            {HEATER_TYPE_NONE: "None", HEATER_TYPE_WATER: "Water", HEATER_TYPE_ELECTRIC: "Electric"}.get(
-                detected_heater_type, "Unknown"
-            ),
+            {
+                HEATER_TYPE_NONE: "None",
+                HEATER_TYPE_WATER: "Water",
+                HEATER_TYPE_ELECTRIC: "Electric",
+            }.get(detected_heater_type, "Unknown"),
         )
-        
+
         return detected_sw_version, detected_heater_type
-    
+
     detection_result = await hass.async_add_executor_job(_detect_device_info)
-    
+
     # If detection returned None, firmware version couldn't be determined
     if detection_result is None:
         client.close()
         return None  # Signal to caller that manual selection is needed
-    
+
     detected_sw_version, detected_heater_type = detection_result
 
     # Verify communication by reading power register (use version-specific address)
     registers = get_registers_for_version(detected_sw_version)
     power_register = get_register_definition(REG_POWER, registers)
-    
+
     # Try to read a register to verify communication
     def _read_test():
         """Test reading from the device (works with any pymodbus 3.x)."""
@@ -302,18 +308,18 @@ def _read_test():
             result = pymodbus_compat.read_holding_registers(
                 client, power_register.address, 1, unit_id
             )
-            return not result.isError() if hasattr(result, 'isError') else result is not None
+            return not result.isError() if hasattr(result, "isError") else result is not None
         except Exception as ex:
             _LOGGER.debug("Test read failed: %s", ex)
             return False
-    
+
     try:
         success = await hass.async_add_executor_job(_read_test)
         if not success:
             raise CannotConnect
     finally:
         client.close()
-    
+
     return {
         "title": data[CONF_NAME],
         CONF_SOFTWARE_VERSION: detected_sw_version,
@@ -332,12 +338,10 @@ def __init__(self) -> None:
         self._user_input: dict[str, Any] | None = None
         self._detection_failed: bool = False
 
-    async def async_step_user(
-        self, user_input: dict[str, Any] | None = None
-    ) -> FlowResult:
+    async def async_step_user(self, user_input: dict[str, Any] | None = None) -> FlowResult:
         """Handle the initial step."""
         errors: dict[str, str] = {}
-        
+
         if self._integration_version is None:
             try:
                 integration = await async_get_integration(self.hass, DOMAIN)
@@ -348,26 +352,24 @@ async def async_step_user(
         if user_input is not None:
             # Always use slave ID 0 (Parmair devices use unit 0)
             user_input[CONF_SLAVE_ID] = DEFAULT_SLAVE_ID
-            
+
             # Create unique ID based on host and slave ID
-            await self.async_set_unique_id(
-                f"{user_input[CONF_HOST]}_{user_input[CONF_SLAVE_ID]}"
-            )
+            await self.async_set_unique_id(f"{user_input[CONF_HOST]}_{user_input[CONF_SLAVE_ID]}")
             self._abort_if_unique_id_configured()
-            
+
             try:
                 info = await validate_connection(self.hass, user_input)
-                
+
                 # If info is None, detection failed - ask user to manually select
                 if info is None:
                     self._user_input = user_input
                     self._detection_failed = True
                     return await self.async_step_manual_version()
-                
+
                 # Store detected software version and heater type
                 user_input[CONF_SOFTWARE_VERSION] = info[CONF_SOFTWARE_VERSION]
                 user_input[CONF_HEATER_TYPE] = info[CONF_HEATER_TYPE]
-                
+
                 # Create entry with detected or default values
                 return self.async_create_entry(title=info["title"], data=user_input)
             except CannotConnect:
@@ -375,7 +377,7 @@ async def async_step_user(
             except Exception:  # pylint: disable=broad-except
                 _LOGGER.exception("Unexpected exception")
                 errors["base"] = "unknown"
-        
+
         return self.async_show_form(
             step_id="user",
             data_schema=STEP_USER_DATA_SCHEMA,
@@ -392,27 +394,30 @@ async def async_step_manual_version(
         if user_input is not None:
             # Combine stored connection info with manual selections
             final_data = {**self._user_input, **user_input}
-            
+
             # Create entry with manually selected version
-            return self.async_create_entry(
-                title=final_data[CONF_NAME],
-                data=final_data
-            )
-        
+            return self.async_create_entry(title=final_data[CONF_NAME], data=final_data)
+
         # Show form for manual selection
         return self.async_show_form(
             step_id="manual_version",
-            data_schema=vol.Schema({
-                vol.Required(CONF_SOFTWARE_VERSION, default=SOFTWARE_VERSION_1): vol.In({
-                    SOFTWARE_VERSION_1: "Software 1.xx",
-                    SOFTWARE_VERSION_2: "Software 2.xx",
-                }),
-                vol.Required(CONF_HEATER_TYPE, default=HEATER_TYPE_NONE): vol.In({
-                    HEATER_TYPE_NONE: "None",
-                    HEATER_TYPE_WATER: "Water",
-                    HEATER_TYPE_ELECTRIC: "Electric",
-                }),
-            }),
+            data_schema=vol.Schema(
+                {
+                    vol.Required(CONF_SOFTWARE_VERSION, default=SOFTWARE_VERSION_1): vol.In(
+                        {
+                            SOFTWARE_VERSION_1: "Software 1.xx",
+                            SOFTWARE_VERSION_2: "Software 2.xx",
+                        }
+                    ),
+                    vol.Required(CONF_HEATER_TYPE, default=HEATER_TYPE_NONE): vol.In(
+                        {
+                            HEATER_TYPE_NONE: "None",
+                            HEATER_TYPE_WATER: "Water",
+                            HEATER_TYPE_ELECTRIC: "Electric",
+                        }
+                    ),
+                }
+            ),
             description_placeholders={
                 "info": "Auto-detection failed. Please select your device's software version and heater type manually.",
             },
diff --git a/custom_components/parmair/const.py b/custom_components/parmair/const.py
index be8f76f..4941786 100644
--- a/custom_components/parmair/const.py
+++ b/custom_components/parmair/const.py
@@ -3,19 +3,18 @@
 from __future__ import annotations
 
 from dataclasses import dataclass
-from typing import Dict
 
 DOMAIN = "parmair"
 
 # Configuration
-CONF_SLAVE_ID = "slave_id"
+CONF_HEATER_TYPE = "heater_type"
 CONF_SCAN_INTERVAL = "scan_interval"
+CONF_SLAVE_ID = "slave_id"
 CONF_SOFTWARE_VERSION = "software_version"
-CONF_HEATER_TYPE = "heater_type"
 
 DEFAULT_NAME = "Parmair MAC"
-DEFAULT_SCAN_INTERVAL = 60  # seconds
 DEFAULT_PORT = 502
+DEFAULT_SCAN_INTERVAL = 60  # seconds
 DEFAULT_SLAVE_ID = 0  # Parmair devices respond with unit ID 0
 
 # Software versions
@@ -33,20 +32,20 @@
 # Firmware 2.xx (register 1127): 0=Electric, 1=Water, 2=None
 
 # v1.xx heater type values
-HEATER_TYPE_WATER_V1 = 0
 HEATER_TYPE_ELECTRIC_V1 = 1
 HEATER_TYPE_NONE_V1 = 2
+HEATER_TYPE_WATER_V1 = 0
 
 # v2.xx heater type values
 HEATER_TYPE_ELECTRIC_V2 = 0
-HEATER_TYPE_WATER_V2 = 1
 HEATER_TYPE_NONE_V2 = 2
+HEATER_TYPE_WATER_V2 = 1
 
 # Legacy constants (v1.xx mapping for backward compatibility)
-HEATER_TYPE_WATER = 0
 HEATER_TYPE_ELECTRIC = 1
 HEATER_TYPE_NONE = 2
 HEATER_TYPE_UNKNOWN = -1
+HEATER_TYPE_WATER = 0
 
 
 @dataclass(frozen=True)
@@ -68,158 +67,115 @@ def register_id(self) -> int:
         return self.address - 1000
 
 
-# Register keys
-REG_HARDWARE_TYPE = "hardware_type"
-REG_SOFTWARE_VERSION = "software_version"
-REG_POWER = "power"
-REG_CONTROL_STATE = "control_state"
+# Register keys (alphabetical)
+REG_ACKNOWLEDGE_ALARMS = "acknowledge_alarms"
 REG_ACTUAL_SPEED = "actual_speed"
-REG_SPEED_CONTROL = "speed_control"
-REG_FRESH_AIR_TEMP = "fresh_air_temp"
-REG_SUPPLY_AFTER_RECOVERY_TEMP = "supply_after_recovery_temp"
-REG_SUPPLY_TEMP = "supply_temp"
-REG_EXHAUST_TEMP = "exhaust_temp"
-REG_WASTE_TEMP = "waste_temp"
-REG_EXHAUST_TEMP_SETPOINT = "exhaust_temp_setpoint"
-REG_SUPPLY_TEMP_SETPOINT = "supply_temp_setpoint"
-REG_HOME_SPEED = "home_speed"
+REG_ALARM_COUNT = "alarm_count"
+REG_ALARMS_STATE = "alarms_state"
 REG_AWAY_SPEED = "away_speed"
 REG_BOOST_SETTING = "boost_setting"
-REG_HOME_STATE = "home_state"
 REG_BOOST_STATE = "boost_state"
 REG_BOOST_TIMER = "boost_timer"
-REG_OVERPRESSURE_STATE = "overpressure_state"
-REG_OVERPRESSURE_TIMER = "overpressure_timer"
-REG_HUMIDITY = "humidity"
-REG_HUMIDITY_24H_AVG = "humidity_24h_avg"
-REG_CO2_EXHAUST = "co2_exhaust"  # MAC 2 only (v2.xx) - combination sensor in exhaust duct
-REG_LTO_HEAT_RECOVERY_CONTROL = "lto_heat_recovery_control"
-REG_ALARM_COUNT = "alarm_count"
-REG_SUM_ALARM = "sum_alarm"
-REG_ALARMS_STATE = "alarms_state"
-
-# Switch register keys
-REG_SUMMER_MODE = "summer_mode"
-REG_TIME_PROGRAM_ENABLE = "time_program_enable"
-REG_HEATER_ENABLE = "heater_enable"
-
-# Predefined settings register keys
 REG_BOOST_TIME_SETTING = "boost_time_setting"
-REG_OVERPRESSURE_TIME_SETTING = "overpressure_time_setting"
-REG_SUMMER_MODE_TEMP_LIMIT = "summer_mode_temp_limit"
-
-# Button register keys
-REG_ACKNOWLEDGE_ALARMS = "acknowledge_alarms"
-REG_FILTER_REPLACED = "filter_replaced"
-
-# Select register keys
-REG_HEATER_TYPE = "heater_type"
-
-# Additional number register keys
-REG_FILTER_INTERVAL = "filter_interval"
-
-# Additional sensor register keys
-REG_HEAT_RECOVERY_EFFICIENCY = "heat_recovery_efficiency"
-REG_PRE_HEATER_OUTPUT = "pre_heater_output"
-REG_POST_HEATER_OUTPUT = "post_heater_output"
-REG_OVERPRESSURE_TIMER = "overpressure_timer"
+REG_CO2_EXHAUST = "co2_exhaust"  # MAC 2 only (v2.xx) - combination sensor in exhaust duct
+REG_CONTROL_STATE = "control_state"
 REG_DEFROST_STATE = "defrost_state"
-REG_SUPPLY_FAN_SPEED = "supply_fan_speed"
 REG_EXHAUST_FAN_SPEED = "exhaust_fan_speed"
-REG_FILTER_STATE = "filter_state"
+REG_EXHAUST_TEMP = "exhaust_temp"
+REG_EXHAUST_TEMP_SETPOINT = "exhaust_temp_setpoint"
 REG_FILTER_DAY = "filter_day"
+REG_FILTER_INTERVAL = "filter_interval"
 REG_FILTER_MONTH = "filter_month"
-REG_FILTER_YEAR = "filter_year"
 REG_FILTER_NEXT_DAY = "filter_next_day"
 REG_FILTER_NEXT_MONTH = "filter_next_month"
 REG_FILTER_NEXT_YEAR = "filter_next_year"
+REG_FILTER_REPLACED = "filter_replaced"
+REG_FILTER_STATE = "filter_state"
+REG_FILTER_YEAR = "filter_year"
+REG_FRESH_AIR_TEMP = "fresh_air_temp"
+REG_HARDWARE_TYPE = "hardware_type"
+REG_HEAT_RECOVERY_EFFICIENCY = "heat_recovery_efficiency"
+REG_HEATER_ENABLE = "heater_enable"
+REG_HEATER_TYPE = "heater_type"
+REG_HOME_SPEED = "home_speed"
+REG_HOME_STATE = "home_state"
+REG_HUMIDITY = "humidity"
+REG_HUMIDITY_24H_AVG = "humidity_24h_avg"
+REG_LTO_HEAT_RECOVERY_CONTROL = "lto_heat_recovery_control"
+REG_OVERPRESSURE_STATE = "overpressure_state"
+REG_OVERPRESSURE_TIMER = "overpressure_timer"
+REG_OVERPRESSURE_TIME_SETTING = "overpressure_time_setting"
+REG_POST_HEATER_OUTPUT = "post_heater_output"
+REG_POWER = "power"
+REG_PRE_HEATER_OUTPUT = "pre_heater_output"
+REG_SPEED_CONTROL = "speed_control"
+REG_SUM_ALARM = "sum_alarm"
+REG_SUMMER_MODE = "summer_mode"
+REG_SUMMER_MODE_TEMP_LIMIT = "summer_mode_temp_limit"
+REG_SUPPLY_AFTER_RECOVERY_TEMP = "supply_after_recovery_temp"
+REG_SUPPLY_FAN_SPEED = "supply_fan_speed"
+REG_SUPPLY_TEMP = "supply_temp"
+REG_SUPPLY_TEMP_SETPOINT = "supply_temp_setpoint"
+REG_SOFTWARE_VERSION = "software_version"
+REG_TIME_PROGRAM_ENABLE = "time_program_enable"
+REG_WASTE_TEMP = "waste_temp"
 
 
-def _build_registers_v1() -> Dict[str, RegisterDefinition]:
+def _build_registers_v1() -> dict[str, RegisterDefinition]:
     """Build the complete register map for Parmair MAC devices with software version 1.xx.
-    
+
     This is the current register map from the CSV documentation.
     """
 
     return {
         REG_HARDWARE_TYPE: RegisterDefinition(REG_HARDWARE_TYPE, 1244, "VENT_MACHINE"),
-        REG_SOFTWARE_VERSION: RegisterDefinition(REG_SOFTWARE_VERSION, 1018, "MULTI_SW_VER", scale=0.01),
+        REG_SOFTWARE_VERSION: RegisterDefinition(
+            REG_SOFTWARE_VERSION, 1018, "MULTI_SW_VER", scale=0.01
+        ),
         REG_POWER: RegisterDefinition(REG_POWER, 1208, "POWER_BTN_FI", writable=True),
         REG_CONTROL_STATE: RegisterDefinition(
             REG_CONTROL_STATE, 1185, "IV01_CONTROLSTATE_FO", writable=True
         ),
-        REG_ACTUAL_SPEED: RegisterDefinition(
-            REG_ACTUAL_SPEED, 1186, "IV01_SPEED_FO"
-        ),
+        REG_ACTUAL_SPEED: RegisterDefinition(REG_ACTUAL_SPEED, 1186, "IV01_SPEED_FO"),
         REG_SPEED_CONTROL: RegisterDefinition(
             REG_SPEED_CONTROL, 1187, "IV01_SPEED_FOC", writable=True
         ),
-        REG_FRESH_AIR_TEMP: RegisterDefinition(
-            REG_FRESH_AIR_TEMP, 1020, "TE01_M", scale=0.1
-        ),
+        REG_FRESH_AIR_TEMP: RegisterDefinition(REG_FRESH_AIR_TEMP, 1020, "TE01_M", scale=0.1),
         REG_SUPPLY_AFTER_RECOVERY_TEMP: RegisterDefinition(
             REG_SUPPLY_AFTER_RECOVERY_TEMP, 1022, "TE05_M", scale=0.1
         ),
-        REG_SUPPLY_TEMP: RegisterDefinition(
-            REG_SUPPLY_TEMP, 1023, "TE10_M", scale=0.1
-        ),
-        REG_EXHAUST_TEMP: RegisterDefinition(
-            REG_EXHAUST_TEMP, 1024, "TE30_M", scale=0.1
-        ),
-        REG_WASTE_TEMP: RegisterDefinition(
-            REG_WASTE_TEMP, 1025, "TE31_M", scale=0.1
-        ),
+        REG_SUPPLY_TEMP: RegisterDefinition(REG_SUPPLY_TEMP, 1023, "TE10_M", scale=0.1),
+        REG_EXHAUST_TEMP: RegisterDefinition(REG_EXHAUST_TEMP, 1024, "TE30_M", scale=0.1),
+        REG_WASTE_TEMP: RegisterDefinition(REG_WASTE_TEMP, 1025, "TE31_M", scale=0.1),
         REG_EXHAUST_TEMP_SETPOINT: RegisterDefinition(
             REG_EXHAUST_TEMP_SETPOINT, 1060, "TE30_S", scale=0.1, writable=True
         ),
         REG_SUPPLY_TEMP_SETPOINT: RegisterDefinition(
             REG_SUPPLY_TEMP_SETPOINT, 1065, "TE10_S", scale=0.1, writable=True
         ),
-        REG_HOME_SPEED: RegisterDefinition(
-            REG_HOME_SPEED, 1104, "HOME_SPEED_S", writable=True
-        ),
-        REG_AWAY_SPEED: RegisterDefinition(
-            REG_AWAY_SPEED, 1105, "AWAY_SPEED_S", writable=True
-        ),
+        REG_HOME_SPEED: RegisterDefinition(REG_HOME_SPEED, 1104, "HOME_SPEED_S", writable=True),
+        REG_AWAY_SPEED: RegisterDefinition(REG_AWAY_SPEED, 1105, "AWAY_SPEED_S", writable=True),
         REG_BOOST_SETTING: RegisterDefinition(
             REG_BOOST_SETTING, 1117, "BOOST_SETTING_S", writable=True
         ),
-        REG_HOME_STATE: RegisterDefinition(
-            REG_HOME_STATE, 1200, "HOME_STATE_FI"
-        ),
-        REG_BOOST_STATE: RegisterDefinition(
-            REG_BOOST_STATE, 1201, "BOOST_STATE_FI"
-        ),
-        REG_BOOST_TIMER: RegisterDefinition(
-            REG_BOOST_TIMER, 1202, "BOOST_TIMER_FM", writable=True
-        ),
-        REG_OVERPRESSURE_STATE: RegisterDefinition(
-            REG_OVERPRESSURE_STATE, 1203, "OVERP_STATE_FI"
-        ),
+        REG_HOME_STATE: RegisterDefinition(REG_HOME_STATE, 1200, "HOME_STATE_FI"),
+        REG_BOOST_STATE: RegisterDefinition(REG_BOOST_STATE, 1201, "BOOST_STATE_FI"),
+        REG_BOOST_TIMER: RegisterDefinition(REG_BOOST_TIMER, 1202, "BOOST_TIMER_FM", writable=True),
+        REG_OVERPRESSURE_STATE: RegisterDefinition(REG_OVERPRESSURE_STATE, 1203, "OVERP_STATE_FI"),
         REG_OVERPRESSURE_TIMER: RegisterDefinition(
             REG_OVERPRESSURE_TIMER, 1204, "OVERP_TIMER_FM", writable=True
         ),
-        REG_HUMIDITY: RegisterDefinition(
-            REG_HUMIDITY, 1180, "MEXX_FM", optional=True
-        ),
+        REG_HUMIDITY: RegisterDefinition(REG_HUMIDITY, 1180, "MEXX_FM", optional=True),
         REG_HUMIDITY_24H_AVG: RegisterDefinition(
             REG_HUMIDITY_24H_AVG, 1192, "ME05_AVG_FM", scale=0.1, optional=True
         ),
         REG_LTO_HEAT_RECOVERY_CONTROL: RegisterDefinition(
             REG_LTO_HEAT_RECOVERY_CONTROL, 1046, "FG50_Y", scale=0.1
         ),
-        REG_ALARM_COUNT: RegisterDefinition(
-            REG_ALARM_COUNT, 1004, "ALARM_COUNT"
-        ),
-        REG_SUM_ALARM: RegisterDefinition(
-            REG_SUM_ALARM, 1005, "SUM_ALARM"
-        ),
-        REG_ALARMS_STATE: RegisterDefinition(
-            REG_ALARMS_STATE, 1206, "ALARMS_STATE_FI"
-        ),
-        REG_SUMMER_MODE: RegisterDefinition(
-            REG_SUMMER_MODE, 1079, "SUMMER_MODE_S", writable=True
-        ),
+        REG_ALARM_COUNT: RegisterDefinition(REG_ALARM_COUNT, 1004, "ALARM_COUNT"),
+        REG_SUM_ALARM: RegisterDefinition(REG_SUM_ALARM, 1005, "SUM_ALARM"),
+        REG_ALARMS_STATE: RegisterDefinition(REG_ALARMS_STATE, 1206, "ALARMS_STATE_FI"),
+        REG_SUMMER_MODE: RegisterDefinition(REG_SUMMER_MODE, 1079, "SUMMER_MODE_S", writable=True),
         REG_TIME_PROGRAM_ENABLE: RegisterDefinition(
             REG_TIME_PROGRAM_ENABLE, 1108, "TP_ENABLE_S", writable=True
         ),
@@ -255,33 +211,17 @@ def _build_registers_v1() -> Dict[str, RegisterDefinition]:
         REG_HEAT_RECOVERY_EFFICIENCY: RegisterDefinition(
             REG_HEAT_RECOVERY_EFFICIENCY, 1190, "FG50_EA_M", scale=0.1
         ),
-        REG_DEFROST_STATE: RegisterDefinition(
-            REG_DEFROST_STATE, 1183, "DFRST_FI"
-        ),
-        REG_SUPPLY_FAN_SPEED: RegisterDefinition(
-            REG_SUPPLY_FAN_SPEED, 1040, "TF10_Y", scale=0.1
-        ),
-        REG_EXHAUST_FAN_SPEED: RegisterDefinition(
-            REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1
-        ),
-        REG_PRE_HEATER_OUTPUT: RegisterDefinition(
-            REG_PRE_HEATER_OUTPUT, 1048, "EC05_Y", scale=0.1
-        ),
+        REG_DEFROST_STATE: RegisterDefinition(REG_DEFROST_STATE, 1183, "DFRST_FI"),
+        REG_SUPPLY_FAN_SPEED: RegisterDefinition(REG_SUPPLY_FAN_SPEED, 1040, "TF10_Y", scale=0.1),
+        REG_EXHAUST_FAN_SPEED: RegisterDefinition(REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1),
+        REG_PRE_HEATER_OUTPUT: RegisterDefinition(REG_PRE_HEATER_OUTPUT, 1048, "EC05_Y", scale=0.1),
         REG_POST_HEATER_OUTPUT: RegisterDefinition(
             REG_POST_HEATER_OUTPUT, 1044, "TV45_Y", scale=0.1
         ),
-        REG_FILTER_STATE: RegisterDefinition(
-            REG_FILTER_STATE, 1205, "FILTER_STATE_FI"
-        ),
-        REG_FILTER_DAY: RegisterDefinition(
-            REG_FILTER_DAY, 1086, "FILTER_DAY", writable=True
-        ),
-        REG_FILTER_MONTH: RegisterDefinition(
-            REG_FILTER_MONTH, 1087, "FILTER_MONTH", writable=True
-        ),
-        REG_FILTER_YEAR: RegisterDefinition(
-            REG_FILTER_YEAR, 1088, "FILTER_YEAR", writable=True
-        ),
+        REG_FILTER_STATE: RegisterDefinition(REG_FILTER_STATE, 1205, "FILTER_STATE_FI"),
+        REG_FILTER_DAY: RegisterDefinition(REG_FILTER_DAY, 1086, "FILTER_DAY", writable=True),
+        REG_FILTER_MONTH: RegisterDefinition(REG_FILTER_MONTH, 1087, "FILTER_MONTH", writable=True),
+        REG_FILTER_YEAR: RegisterDefinition(REG_FILTER_YEAR, 1088, "FILTER_YEAR", writable=True),
         REG_FILTER_NEXT_DAY: RegisterDefinition(
             REG_FILTER_NEXT_DAY, 1089, "FILTERNEXT_DAY", writable=True
         ),
@@ -294,12 +234,12 @@ def _build_registers_v1() -> Dict[str, RegisterDefinition]:
     }
 
 
-def _build_registers_v2() -> Dict[str, RegisterDefinition]:
+def _build_registers_v2() -> dict[str, RegisterDefinition]:
     """Build the complete register map for Parmair MAC devices with software version 2.xx.
-    
+
     Firmware 2.xx uses Register ID + 1000 addressing scheme.
     For example: Register ID 20 (TE01_M) -> Address 1020
-    
+
     Note: These registers are NOT compatible with 1.xx firmware which uses different
     control registers (POWER_BTN_FI, IV01_CONTROLSTATE_FO, etc.). Firmware 2.xx uses
     UNIT_CONTROL_FO and USERSTATECONTROL_FO instead.
@@ -307,93 +247,134 @@ def _build_registers_v2() -> Dict[str, RegisterDefinition]:
     return {
         # System information - same register IDs as v1 but +1000 offset
         REG_HARDWARE_TYPE: RegisterDefinition(REG_HARDWARE_TYPE, 1125, "VENT_MACHINE"),
-        REG_SOFTWARE_VERSION: RegisterDefinition(REG_SOFTWARE_VERSION, 1015, "MULTI_SW_VER", scale=0.01),
-        
+        REG_SOFTWARE_VERSION: RegisterDefinition(
+            REG_SOFTWARE_VERSION, 1015, "MULTI_SW_VER", scale=0.01
+        ),
         # Control registers - v2 uses different control scheme
         REG_POWER: RegisterDefinition(REG_POWER, 1180, "UNIT_CONTROL_FO", writable=True),
-        REG_CONTROL_STATE: RegisterDefinition(REG_CONTROL_STATE, 1181, "USERSTATECONTROL_FO", writable=True),
+        REG_CONTROL_STATE: RegisterDefinition(
+            REG_CONTROL_STATE, 1181, "USERSTATECONTROL_FO", writable=True
+        ),
         REG_ACTUAL_SPEED: RegisterDefinition(REG_ACTUAL_SPEED, 1187, "IV01_SPEED_FO"),
-        REG_SPEED_CONTROL: RegisterDefinition(REG_SPEED_CONTROL, 1187, "IV01_SPEED_FO", writable=True),
-        
+        REG_SPEED_CONTROL: RegisterDefinition(
+            REG_SPEED_CONTROL, 1187, "IV01_SPEED_FO", writable=True
+        ),
         # Temperature sensors (×0.1°C scaling)
         REG_FRESH_AIR_TEMP: RegisterDefinition(REG_FRESH_AIR_TEMP, 1020, "TE01_M", scale=0.1),
-        REG_SUPPLY_AFTER_RECOVERY_TEMP: RegisterDefinition(REG_SUPPLY_AFTER_RECOVERY_TEMP, 1021, "TE05_M", scale=0.1),
+        REG_SUPPLY_AFTER_RECOVERY_TEMP: RegisterDefinition(
+            REG_SUPPLY_AFTER_RECOVERY_TEMP, 1021, "TE05_M", scale=0.1
+        ),
         REG_SUPPLY_TEMP: RegisterDefinition(REG_SUPPLY_TEMP, 1022, "TE10_M", scale=0.1),
         REG_EXHAUST_TEMP: RegisterDefinition(REG_EXHAUST_TEMP, 1024, "TE30_M", scale=0.1),
         REG_WASTE_TEMP: RegisterDefinition(REG_WASTE_TEMP, 1023, "TE31_M", scale=0.1),
-        
         # Temperature setpoints (×0.1°C scaling)
         # TE30_S: shared with REG_SUMMER_MODE_TEMP_LIMIT (target room temp / summer mode limit)
-        REG_EXHAUST_TEMP_SETPOINT: RegisterDefinition(REG_EXHAUST_TEMP_SETPOINT, 1073, "TE30_S", scale=0.1, writable=True),
-        REG_SUPPLY_TEMP_SETPOINT: RegisterDefinition(REG_SUPPLY_TEMP_SETPOINT, 1061, "TE10_MIN_HOME_S", scale=0.1, writable=True),
-        
+        REG_EXHAUST_TEMP_SETPOINT: RegisterDefinition(
+            REG_EXHAUST_TEMP_SETPOINT, 1073, "TE30_S", scale=0.1, writable=True
+        ),
+        REG_SUPPLY_TEMP_SETPOINT: RegisterDefinition(
+            REG_SUPPLY_TEMP_SETPOINT, 1061, "TE10_MIN_HOME_S", scale=0.1, writable=True
+        ),
         # Speed presets
         REG_HOME_SPEED: RegisterDefinition(REG_HOME_SPEED, 1060, "HOME_SPEED_S", writable=True),
         REG_AWAY_SPEED: RegisterDefinition(REG_AWAY_SPEED, 1063, "AWAY_SPEED_S", writable=True),
-        REG_BOOST_SETTING: RegisterDefinition(REG_BOOST_SETTING, 1065, "BOOST_SETTING_S", writable=True),
-        
+        REG_BOOST_SETTING: RegisterDefinition(
+            REG_BOOST_SETTING, 1065, "BOOST_SETTING_S", writable=True
+        ),
         # State indicators - using soft measurements for v2
         REG_HOME_STATE: RegisterDefinition(REG_HOME_STATE, 1181, "USERSTATECONTROL_FO"),
         REG_BOOST_STATE: RegisterDefinition(REG_BOOST_STATE, 1181, "USERSTATECONTROL_FO"),
         REG_BOOST_TIMER: RegisterDefinition(REG_BOOST_TIMER, 1200, "BOOST_TIMER_FM", writable=True),
-        REG_OVERPRESSURE_STATE: RegisterDefinition(REG_OVERPRESSURE_STATE, 1181, "USERSTATECONTROL_FO"),
-        REG_OVERPRESSURE_TIMER: RegisterDefinition(REG_OVERPRESSURE_TIMER, 1201, "OVERP_TIMER_FM", writable=True),
-        
+        REG_OVERPRESSURE_STATE: RegisterDefinition(
+            REG_OVERPRESSURE_STATE, 1181, "USERSTATECONTROL_FO"
+        ),
+        REG_OVERPRESSURE_TIMER: RegisterDefinition(
+            REG_OVERPRESSURE_TIMER, 1201, "OVERP_TIMER_FM", writable=True
+        ),
         # Standard sensors (v2.xx)
         REG_HUMIDITY: RegisterDefinition(REG_HUMIDITY, 1025, "ME05_M"),
-        REG_HUMIDITY_24H_AVG: RegisterDefinition(REG_HUMIDITY_24H_AVG, 1192, "ME05_AVG_FM", scale=0.1),
-        REG_CO2_EXHAUST: RegisterDefinition(REG_CO2_EXHAUST, 1026, "QE05_M"),  # MAC 2 standard sensor (v2.xx)
-        REG_LTO_HEAT_RECOVERY_CONTROL: RegisterDefinition(REG_LTO_HEAT_RECOVERY_CONTROL, 1046, "FG50_Y", scale=0.1),
-        
+        REG_HUMIDITY_24H_AVG: RegisterDefinition(
+            REG_HUMIDITY_24H_AVG, 1192, "ME05_AVG_FM", scale=0.1
+        ),
+        REG_CO2_EXHAUST: RegisterDefinition(
+            REG_CO2_EXHAUST, 1026, "QE05_M"
+        ),  # MAC 2 standard sensor (v2.xx)
+        REG_LTO_HEAT_RECOVERY_CONTROL: RegisterDefinition(
+            REG_LTO_HEAT_RECOVERY_CONTROL, 1046, "FG50_Y", scale=0.1
+        ),
         # Alarm registers
         REG_ALARM_COUNT: RegisterDefinition(REG_ALARM_COUNT, 1004, "ALARM_COUNT"),
         REG_SUM_ALARM: RegisterDefinition(REG_SUM_ALARM, 1005, "SUM_ALARM"),
         REG_ALARMS_STATE: RegisterDefinition(REG_ALARMS_STATE, 1204, "ALARMS_STATE_FI"),
-        
         # Switch registers
-        REG_SUMMER_MODE: RegisterDefinition(REG_SUMMER_MODE, 1071, "AUTO_SUMMER_COOL_S", writable=True),
-        REG_TIME_PROGRAM_ENABLE: RegisterDefinition(REG_TIME_PROGRAM_ENABLE, 1070, "TP_ENABLE_S", writable=True),
-        REG_HEATER_ENABLE: RegisterDefinition(REG_HEATER_ENABLE, 1074, "AUTO_HEATER_ENABLE_S", writable=True),
-        
+        REG_SUMMER_MODE: RegisterDefinition(
+            REG_SUMMER_MODE, 1071, "AUTO_SUMMER_COOL_S", writable=True
+        ),
+        REG_TIME_PROGRAM_ENABLE: RegisterDefinition(
+            REG_TIME_PROGRAM_ENABLE, 1070, "TP_ENABLE_S", writable=True
+        ),
+        REG_HEATER_ENABLE: RegisterDefinition(
+            REG_HEATER_ENABLE, 1074, "AUTO_HEATER_ENABLE_S", writable=True
+        ),
         # Button registers
-        REG_ACKNOWLEDGE_ALARMS: RegisterDefinition(REG_ACKNOWLEDGE_ALARMS, 1003, "ACK_ALARMS", writable=True),
-        REG_FILTER_REPLACED: RegisterDefinition(REG_FILTER_REPLACED, 1184, "FILTER_STATE_FI", writable=True),
-        
+        REG_ACKNOWLEDGE_ALARMS: RegisterDefinition(
+            REG_ACKNOWLEDGE_ALARMS, 1003, "ACK_ALARMS", writable=True
+        ),
+        REG_FILTER_REPLACED: RegisterDefinition(
+            REG_FILTER_REPLACED, 1184, "FILTER_STATE_FI", writable=True
+        ),
         # Select registers
-        REG_HEATER_TYPE: RegisterDefinition(REG_HEATER_TYPE, 1127, "HEAT_RADIATOR_TYPE", writable=True),
-        
+        REG_HEATER_TYPE: RegisterDefinition(
+            REG_HEATER_TYPE, 1127, "HEAT_RADIATOR_TYPE", writable=True
+        ),
         # Predefined settings registers
-        REG_BOOST_TIME_SETTING: RegisterDefinition(REG_BOOST_TIME_SETTING, 1066, "BOOST_TIME_S", writable=True),
-        REG_OVERPRESSURE_TIME_SETTING: RegisterDefinition(REG_OVERPRESSURE_TIME_SETTING, 1069, "OVERP_TIME_S", writable=True),
+        REG_BOOST_TIME_SETTING: RegisterDefinition(
+            REG_BOOST_TIME_SETTING, 1066, "BOOST_TIME_S", writable=True
+        ),
+        REG_OVERPRESSURE_TIME_SETTING: RegisterDefinition(
+            REG_OVERPRESSURE_TIME_SETTING, 1069, "OVERP_TIME_S", writable=True
+        ),
         # TE30_S: same physical register as REG_EXHAUST_TEMP_SETPOINT (target room temp in summer)
-        REG_SUMMER_MODE_TEMP_LIMIT: RegisterDefinition(REG_SUMMER_MODE_TEMP_LIMIT, 1073, "TE30_S", scale=0.1, writable=True),
-        
+        REG_SUMMER_MODE_TEMP_LIMIT: RegisterDefinition(
+            REG_SUMMER_MODE_TEMP_LIMIT, 1073, "TE30_S", scale=0.1, writable=True
+        ),
         # Additional number registers
-        REG_FILTER_INTERVAL: RegisterDefinition(REG_FILTER_INTERVAL, 1090, "FILTER_INTERVAL_S", writable=True),
-        
+        REG_FILTER_INTERVAL: RegisterDefinition(
+            REG_FILTER_INTERVAL, 1090, "FILTER_INTERVAL_S", writable=True
+        ),
         # Additional sensor registers
-        REG_HEAT_RECOVERY_EFFICIENCY: RegisterDefinition(REG_HEAT_RECOVERY_EFFICIENCY, 1183, "FG50_EA_M", scale=0.1),
+        REG_HEAT_RECOVERY_EFFICIENCY: RegisterDefinition(
+            REG_HEAT_RECOVERY_EFFICIENCY, 1183, "FG50_EA_M", scale=0.1
+        ),
         REG_DEFROST_STATE: RegisterDefinition(REG_DEFROST_STATE, 1182, "DFRST_FI"),
         REG_SUPPLY_FAN_SPEED: RegisterDefinition(REG_SUPPLY_FAN_SPEED, 1040, "TF10_Y", scale=0.1),
         REG_EXHAUST_FAN_SPEED: RegisterDefinition(REG_EXHAUST_FAN_SPEED, 1042, "PF30_Y", scale=0.1),
         REG_PRE_HEATER_OUTPUT: RegisterDefinition(REG_PRE_HEATER_OUTPUT, 1048, "EC05_Y", scale=0.1),
-        REG_POST_HEATER_OUTPUT: RegisterDefinition(REG_POST_HEATER_OUTPUT, 1044, "TV45_Y", scale=0.1),
+        REG_POST_HEATER_OUTPUT: RegisterDefinition(
+            REG_POST_HEATER_OUTPUT, 1044, "TV45_Y", scale=0.1
+        ),
         REG_FILTER_STATE: RegisterDefinition(REG_FILTER_STATE, 1184, "FILTER_STATE_FI"),
         REG_FILTER_DAY: RegisterDefinition(REG_FILTER_DAY, 1193, "FILTER_DAY", writable=True),
         REG_FILTER_MONTH: RegisterDefinition(REG_FILTER_MONTH, 1194, "FILTER_MONTH", writable=True),
         REG_FILTER_YEAR: RegisterDefinition(REG_FILTER_YEAR, 1195, "FILTER_YEAR", writable=True),
-        REG_FILTER_NEXT_DAY: RegisterDefinition(REG_FILTER_NEXT_DAY, 1196, "FILTERNEXT_DAY", writable=True),
-        REG_FILTER_NEXT_MONTH: RegisterDefinition(REG_FILTER_NEXT_MONTH, 1197, "FILTERNEXT_MONTH", writable=True),
-        REG_FILTER_NEXT_YEAR: RegisterDefinition(REG_FILTER_NEXT_YEAR, 1198, "FILTERNEXT_YEAR", writable=True),
+        REG_FILTER_NEXT_DAY: RegisterDefinition(
+            REG_FILTER_NEXT_DAY, 1196, "FILTERNEXT_DAY", writable=True
+        ),
+        REG_FILTER_NEXT_MONTH: RegisterDefinition(
+            REG_FILTER_NEXT_MONTH, 1197, "FILTERNEXT_MONTH", writable=True
+        ),
+        REG_FILTER_NEXT_YEAR: RegisterDefinition(
+            REG_FILTER_NEXT_YEAR, 1198, "FILTERNEXT_YEAR", writable=True
+        ),
     }
 
 
-def get_registers_for_version(software_version: str) -> Dict[str, RegisterDefinition]:
+def get_registers_for_version(software_version: str) -> dict[str, RegisterDefinition]:
     """Get the appropriate register map based on software version.
-    
+
     Args:
         software_version: Software version string (e.g., "1.x", "2.x", "1.83", "2.28")
-    
+
     Returns:
         Dictionary mapping register keys to RegisterDefinition objects
     """
@@ -411,8 +392,8 @@ def get_registers_for_version(software_version: str) -> Dict[str, RegisterDefini
 # Static registers (read once at startup - values don't change during operation)
 STATIC_REGISTER_KEYS = (
     REG_SOFTWARE_VERSION,  # Software version never changes
-    REG_HARDWARE_TYPE,     # Hardware model (80/100/150) never changes
-    REG_HEATER_TYPE,       # Heater type (water/electric) rarely changes
+    REG_HARDWARE_TYPE,  # Hardware model (80/100/150) never changes
+    REG_HEATER_TYPE,  # Heater type (water/electric) rarely changes
 )
 
 # Dynamic registers (polled regularly - values change during operation)
@@ -467,13 +448,15 @@ def get_registers_for_version(software_version: str) -> Dict[str, RegisterDefini
 )
 
 
-def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] | None = None) -> RegisterDefinition:
+def get_register_definition(
+    key: str, registers: dict[str, RegisterDefinition] | None = None
+) -> RegisterDefinition:
     """Return the register definition for a given key.
-    
+
     Args:
         key: Register key to look up
         registers: Optional register map to use. If None, uses default REGISTERS.
-    
+
     Returns:
         RegisterDefinition for the requested register
     """
@@ -498,7 +481,7 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
 # Control state display mapping (differs by firmware version)
 # V1.x IV01_CONTROLSTATE_FO: Stop, Away, Home, Boost, Overpressure, timers, Manual
 # V2.x USERSTATECONTROL_FO: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
-CONTROL_STATE_MAP_V1: Dict[int, str] = {
+CONTROL_STATE_MAP_V1: dict[int, str] = {
     MODE_STOP: "Stop",
     MODE_AWAY: "Away",
     MODE_HOME: "Home",
@@ -510,7 +493,7 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
     8: "Overpressure Timer",
     MODE_MANUAL: "Manual",
 }
-CONTROL_STATE_MAP_V2: Dict[int, str] = {
+CONTROL_STATE_MAP_V2: dict[int, str] = {
     0: "Off",
     1: "Away",
     2: "Home",
@@ -537,19 +520,19 @@ def get_register_definition(key: str, registers: Dict[str, RegisterDefinition] |
 # Power state display mapping (differs by firmware version)
 # V1.x POWER_BTN_FI: 0=Off, 1=Shutting Down, 2=Starting, 3=Running
 # V2.x UNIT_CONTROL_FO: 0=Off, 1=On
-POWER_STATE_MAP_V1: Dict[int, str] = {
+POWER_STATE_MAP_V1: dict[int, str] = {
     POWER_OFF: "Off",
     POWER_SHUTTING_DOWN: "Shutting Down",
     POWER_STARTING: "Starting",
     POWER_RUNNING: "Running",
 }
-POWER_STATE_MAP_V2: Dict[int, str] = {0: "Off", 1: "On"}
+POWER_STATE_MAP_V2: dict[int, str] = {0: "Off", 1: "On"}
 
 # Filter state display mapping (differs by firmware version)
 # V1.x FILTER_STATE_FI: 0=Replace, 1=OK
-FILTER_STATE_MAP_V1: Dict[int, str] = {0: "Replace", 1: "OK"}
+FILTER_STATE_MAP_V1: dict[int, str] = {0: "Replace", 1: "OK"}
 # V2.x FILTER_STATE_FI: 0=Idle/OK, 1=Acknowledge Change, 2=Replace Reminder
-FILTER_STATE_MAP_V2: Dict[int, str] = {
+FILTER_STATE_MAP_V2: dict[int, str] = {
     0: "OK",
     1: "Acknowledge Change",
     2: "Replace Reminder",
diff --git a/custom_components/parmair/coordinator.py b/custom_components/parmair/coordinator.py
index 624ffd1..e745355 100644
--- a/custom_components/parmair/coordinator.py
+++ b/custom_components/parmair/coordinator.py
@@ -1,6 +1,8 @@
 """DataUpdateCoordinator for Parmair integration."""
+
 from __future__ import annotations
 
+import contextlib
 import logging
 import random
 import threading
@@ -8,13 +10,12 @@
 from datetime import timedelta
 from typing import Any
 
-from pymodbus.client import ModbusTcpClient
-from pymodbus.exceptions import ModbusException
-
+from homeassistant.config_entries import ConfigEntry
 from homeassistant.const import CONF_HOST, CONF_PORT
 from homeassistant.core import HomeAssistant
 from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed
-from homeassistant.config_entries import ConfigEntry
+from pymodbus.client import ModbusTcpClient
+from pymodbus.exceptions import ModbusException
 
 from . import pymodbus_compat
 from .const import (
@@ -30,10 +31,8 @@
     HARDWARE_TYPE_MAP_V2,
     HEATER_TYPE_UNKNOWN,
     POLLING_REGISTER_KEYS,
-    REGISTERS,
     SOFTWARE_VERSION_1,
     SOFTWARE_VERSION_2,
-    SOFTWARE_VERSION_UNKNOWN,
     STATIC_REGISTER_KEYS,
     RegisterDefinition,
     get_register_definition,
@@ -46,12 +45,12 @@
 def _set_unit_id(client: ModbusTcpClient, unit_id: int) -> None:
     """Set unit ID on the Modbus client for pymodbus 3.x."""
     # Pymodbus 3.x uses 'slave' attribute
-    if hasattr(client, 'slave'):
+    if hasattr(client, "slave"):
         client.slave = unit_id
     # Fallback to other common attributes
-    elif hasattr(client, 'unit_id'):
+    elif hasattr(client, "unit_id"):
         client.unit_id = unit_id
-    elif hasattr(client, 'slave_id'):
+    elif hasattr(client, "slave_id"):
         client.slave_id = unit_id
 
 
@@ -74,7 +73,7 @@ def _build_read_ranges(
     ranges: list[tuple[int, int]] = []
     start = addresses[0]
     count = 1
-    for prev, curr in zip(addresses[:-1], addresses[1:]):
+    for prev, curr in zip(addresses[:-1], addresses[1:], strict=True):
         if curr == prev + 1 and count < max_registers:
             count += 1
         else:
@@ -105,32 +104,28 @@ def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
             self.slave_id = raw_slave_id
         self.software_version = entry.data.get(CONF_SOFTWARE_VERSION, SOFTWARE_VERSION_1)
         self.heater_type = entry.data.get(CONF_HEATER_TYPE, HEATER_TYPE_UNKNOWN)
-        
+
         scan_interval = entry.data.get(CONF_SCAN_INTERVAL, DEFAULT_SCAN_INTERVAL)
-        
+
         # Get version-specific register map
         self._registers = get_registers_for_version(self.software_version)
-        
+
         # Separate static and dynamic register lists
         self._static_registers: list[RegisterDefinition] = [
-            self._registers[key]
-            for key in STATIC_REGISTER_KEYS
-            if key in self._registers
+            self._registers[key] for key in STATIC_REGISTER_KEYS if key in self._registers
         ]
-        
+
         self._poll_registers: list[RegisterDefinition] = [
-            self._registers[key]
-            for key in POLLING_REGISTER_KEYS
-            if key in self._registers
+            self._registers[key] for key in POLLING_REGISTER_KEYS if key in self._registers
         ]
-        
+
         # Storage for static data (read once)
         self._static_data: dict[str, Any] = {}
         self._static_data_read = False
 
         self._client = ModbusTcpClient(host=self.host, port=self.port)
         self._lock = threading.Lock()
-        
+
         super().__init__(
             hass,
             _LOGGER,
@@ -160,17 +155,13 @@ def _read_modbus_data(self) -> dict[str, Any]:
                 # Jitter to desynchronize from other Modbus clients polling the same device
                 time.sleep(random.uniform(0.2, 0.7))
             except Exception:
-                try:
+                with contextlib.suppress(Exception):
                     read_client.close()
-                except Exception:
-                    pass
                 raise
 
             # Wake-up read: power register (1001) to keep device responsive
-            try:
+            with contextlib.suppress(Exception):
                 _ = read_client.read_holding_registers(address=1001, count=1)
-            except Exception:
-                pass
             time.sleep(0.3)
 
             # Read static registers once on first poll (batched)
@@ -192,8 +183,14 @@ def _read_modbus_data(self) -> dict[str, Any]:
                                 for definition in static_addr_to_defs[addr]:
                                     if definition.optional and raw < 0:
                                         continue
-                                    self._static_data[definition.key] = self._from_raw(definition, raw)
-                                    _LOGGER.debug("Static register %s: %s", definition.label, self._static_data[definition.key])
+                                    self._static_data[definition.key] = self._from_raw(
+                                        definition, raw
+                                    )
+                                    _LOGGER.debug(
+                                        "Static register %s: %s",
+                                        definition.label,
+                                        self._static_data[definition.key],
+                                    )
                     time.sleep(0.3)
                 self._static_data_read = True
 
@@ -232,31 +229,32 @@ def _read_modbus_data(self) -> dict[str, Any]:
                         for definition in definitions:
                             data[definition.key] = value
                     time.sleep(0.3)
-                
+
                 if failed_registers:
                     _LOGGER.debug(
                         "Failed to read %d registers: %s",
                         len(failed_registers),
                         ", ".join(failed_registers),
                     )
-                
+
                 # Merge static data with dynamic data
                 data.update(self._static_data)
 
                 # v2.x: home_state, boost_state, overpressure_state share register 1181 (USERSTATECONTROL_FO)
                 # 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
                 # Derive binary values for sensors that expect 0/1
-                is_v2 = (
-                    self.software_version == SOFTWARE_VERSION_2
-                    or str(self.software_version).startswith("2.")
-                )
+                is_v2 = self.software_version == SOFTWARE_VERSION_2 or str(
+                    self.software_version
+                ).startswith("2.")
                 if is_v2:
                     user_state = data.get("control_state")
                     if user_state is not None:
                         data["home_state"] = 1 if user_state == 2 else 0  # 2=Home
                         data["boost_state"] = 1 if user_state == 3 else 0  # 3=Boost
-                        data["overpressure_state"] = 1 if user_state in (4, 5) else 0  # 4=Sauna, 5=Fireplace
-                
+                        data["overpressure_state"] = (
+                            1 if user_state in (4, 5) else 0
+                        )  # 4=Sauna, 5=Fireplace
+
                 _LOGGER.debug(
                     "Read data from Parmair %s: %d values (%d static, %d dynamic)",
                     self.host,
@@ -265,43 +263,43 @@ def _read_modbus_data(self) -> dict[str, Any]:
                     len(data) - len(self._static_data),
                 )
                 return data
-                
+
             except Exception as ex:
                 _LOGGER.error("Error reading from Modbus: %s", ex)
                 raise ModbusException(f"Failed to read data: {ex}") from ex
             finally:
-                try:
+                with contextlib.suppress(Exception):
                     read_client.close()
-                except Exception:
-                    pass
 
     def write_register(self, key: str, value: float | int) -> bool:
         """Write a value to a Modbus register respecting scaling with pymodbus 3.x."""
         definition = get_register_definition(key, self._registers)
         try:
             with self._lock:
-                if not self._client.connected:
-                    if not self._client.connect():
-                        return False
-                
+                if not self._client.connected and not self._client.connect():
+                    return False
+
                 # Set unit ID on client
                 _set_unit_id(self._client, self.slave_id)
 
                 raw_value = self._to_raw(definition, value)
-                
+
                 result = pymodbus_compat.write_register(
                     self._client, definition.address, raw_value, self.slave_id
                 )
-                
+
                 _LOGGER.debug(
                     "Wrote %s to register %s (%d): raw=%d",
-                    value, definition.label, definition.address, raw_value
+                    value,
+                    definition.label,
+                    definition.address,
+                    raw_value,
                 )
-                
+
                 # Small delay after write to allow device to process
                 time.sleep(0.3)
-                
-                return not result.isError() if hasattr(result, 'isError') else result is not None
+
+                return not result.isError() if hasattr(result, "isError") else result is not None
         except Exception as ex:
             _LOGGER.error(
                 "Error writing to Modbus register %s (%s): %s",
@@ -318,11 +316,12 @@ async def async_write_register(self, key: str, value: float | int) -> bool:
 
     async def async_shutdown(self) -> None:
         """Close the Modbus connection."""
+
         def _close():
             with self._lock:
                 if self._client.connected:
                     self._client.close()
-        
+
         await self.hass.async_add_executor_job(_close)
 
     @property
@@ -330,32 +329,31 @@ def device_info(self) -> dict[str, Any]:
         """Return device information."""
         sw_version = self.data.get("software_version")
         hw_type = self.data.get("hardware_type")
-        
+
         # Determine MAC model from hardware type
         model = "MAC"
         if hw_type is not None:
             hw_int = int(hw_type)
-            is_v2 = (
-                self.software_version == SOFTWARE_VERSION_2
-                or str(self.software_version).startswith("2.")
-            )
+            is_v2 = self.software_version == SOFTWARE_VERSION_2 or str(
+                self.software_version
+            ).startswith("2.")
             model_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int) if is_v2 else hw_int
             model = f"MAC {model_num}"
-        
+
         device_info = {
             "identifiers": {(DOMAIN, self.entry.entry_id)},
             "name": self.entry.data.get("name", DEFAULT_NAME),
             "manufacturer": "Parmair",
             "model": model,
         }
-        
+
         # Add software version
         if sw_version is not None:
-            if isinstance(sw_version, (int, float)):
+            if isinstance(sw_version, int | float):
                 device_info["sw_version"] = f"{sw_version:.2f}"
             else:
                 device_info["sw_version"] = str(sw_version)
-        
+
         return device_info
 
     def get_register_definition(self, key: str) -> RegisterDefinition:
@@ -368,14 +366,12 @@ def _read_register_block(
         """Read a block of consecutive registers. Returns raw values or None on failure."""
         c = client if client is not None else self._client
         try:
-            result = pymodbus_compat.read_holding_registers(
-                c, address, count, self.slave_id
-            )
+            result = pymodbus_compat.read_holding_registers(c, address, count, self.slave_id)
             if not result or (hasattr(result, "isError") and result.isError()):
                 return None
             if hasattr(result, "registers"):
                 raw_list = list(result.registers)
-            elif isinstance(result, (list, tuple)):
+            elif isinstance(result, list | tuple):
                 raw_list = list(result)
             else:
                 return None
@@ -391,7 +387,9 @@ def _read_register_block(
         except Exception as ex:
             _LOGGER.warning(
                 "Exception reading block at address %d count %d: %s",
-                address, count, ex,
+                address,
+                count,
+                ex,
             )
             return None
 
@@ -412,7 +410,7 @@ def _read_register_value(self, definition: RegisterDefinition) -> Any | None:
 
             if hasattr(result, "registers"):
                 raw = result.registers[0]
-            elif isinstance(result, (list, tuple)):
+            elif isinstance(result, list | tuple):
                 raw = result[0]
             else:
                 raw = result
diff --git a/custom_components/parmair/fan.py b/custom_components/parmair/fan.py
index 3ff0eb0..0a72de1 100644
--- a/custom_components/parmair/fan.py
+++ b/custom_components/parmair/fan.py
@@ -1,4 +1,5 @@
 """Fan platform for Parmair ventilation integration."""
+
 from __future__ import annotations
 
 import logging
@@ -15,7 +16,6 @@
 )
 
 from .const import (
-    DEFAULT_NAME,
     DOMAIN,
     MODE_AWAY,
     MODE_BOOST,
@@ -46,7 +46,7 @@ async def async_setup_entry(
 ) -> None:
     """Set up Parmair fan platform."""
     coordinator: ParmairCoordinator = hass.data[DOMAIN][entry.entry_id]
-    
+
     async_add_entities([ParmairFan(coordinator, entry)])
 
 
@@ -55,10 +55,7 @@ class ParmairFan(CoordinatorEntity[ParmairCoordinator], FanEntity):
 
     _attr_has_entity_name = True
     _attr_name = None
-    _attr_supported_features = (
-        FanEntityFeature.SET_SPEED
-        | FanEntityFeature.PRESET_MODE
-    )
+    _attr_supported_features = FanEntityFeature.SET_SPEED | FanEntityFeature.PRESET_MODE
     _attr_preset_modes = [PRESET_MODE_AWAY, PRESET_MODE_HOME, PRESET_MODE_BOOST]
     _attr_speed_count = 3
 
@@ -74,10 +71,9 @@ def is_on(self) -> bool:
         power_state = self.coordinator.data.get("power", POWER_OFF)
         control_state = self.coordinator.data.get("control_state", MODE_STOP)
         # V1: power 3 = Running. V2: power 1 = On.
-        is_v2 = (
-            self.coordinator.software_version == SOFTWARE_VERSION_2
-            or str(self.coordinator.software_version).startswith("2.")
-        )
+        is_v2 = self.coordinator.software_version == SOFTWARE_VERSION_2 or str(
+            self.coordinator.software_version
+        ).startswith("2.")
         power_ok = (power_state == 1) if is_v2 else (power_state == POWER_RUNNING)
         return power_ok and control_state != MODE_STOP
 
@@ -86,9 +82,9 @@ def percentage(self) -> int | None:
         """Return the current speed percentage."""
         if not self.is_on:
             return 0
-        
+
         control_state = self.coordinator.data.get("control_state", MODE_STOP)
-        
+
         # Map control state to percentage
         if control_state == MODE_AWAY:
             return ordered_list_item_to_percentage(ORDERED_NAMED_FAN_SPEEDS, PRESET_MODE_AWAY)
@@ -96,7 +92,7 @@ def percentage(self) -> int | None:
             return ordered_list_item_to_percentage(ORDERED_NAMED_FAN_SPEEDS, PRESET_MODE_HOME)
         elif control_state == MODE_BOOST:
             return ordered_list_item_to_percentage(ORDERED_NAMED_FAN_SPEEDS, PRESET_MODE_BOOST)
-        
+
         return None
 
     @property
@@ -104,16 +100,16 @@ def preset_mode(self) -> str | None:
         """Return the current preset mode."""
         if not self.is_on:
             return None
-        
+
         control_state = self.coordinator.data.get("control_state", MODE_STOP)
-        
+
         if control_state == MODE_AWAY:
             return PRESET_MODE_AWAY
         elif control_state == MODE_HOME:
             return PRESET_MODE_HOME
         elif control_state == MODE_BOOST:
             return PRESET_MODE_BOOST
-        
+
         return None
 
     async def async_turn_on(
@@ -127,7 +123,7 @@ async def async_turn_on(
         if self.coordinator.data.get("power") != POWER_RUNNING:
             await self.coordinator.async_write_register(REG_POWER, POWER_RUNNING)
             await self.coordinator.async_request_refresh()
-        
+
         # Then set mode
         if preset_mode:
             await self.async_set_preset_mode(preset_mode)
@@ -148,7 +144,7 @@ async def async_set_percentage(self, percentage: int) -> None:
         if percentage == 0:
             await self.async_turn_off()
             return
-        
+
         # Map percentage to preset mode
         named_speed = percentage_to_ordered_list_item(ORDERED_NAMED_FAN_SPEEDS, percentage)
         await self.async_set_preset_mode(named_speed)
@@ -160,7 +156,7 @@ async def async_set_preset_mode(self, preset_mode: str) -> None:
             PRESET_MODE_HOME: MODE_HOME,
             PRESET_MODE_BOOST: MODE_BOOST,
         }
-        
+
         if preset_mode in mode_map:
             mode_value = mode_map[preset_mode]
             if await self.coordinator.async_write_register(REG_CONTROL_STATE, mode_value):
@@ -172,5 +168,7 @@ def extra_state_attributes(self) -> dict[str, object]:
 
         return {
             "parmair_power_register": self.coordinator.get_register_definition(REG_POWER).label,
-            "parmair_control_register": self.coordinator.get_register_definition(REG_CONTROL_STATE).label,
+            "parmair_control_register": self.coordinator.get_register_definition(
+                REG_CONTROL_STATE
+            ).label,
         }
diff --git a/custom_components/parmair/number.py b/custom_components/parmair/number.py
index ac2cd36..c3a3465 100644
--- a/custom_components/parmair/number.py
+++ b/custom_components/parmair/number.py
@@ -1,4 +1,5 @@
 """Number platform for Parmair MAC integration."""
+
 from __future__ import annotations
 
 import logging
@@ -55,10 +56,20 @@ async def async_setup_entry(
             coordinator, entry, REG_FILTER_INTERVAL, "Filter Change Interval"
         ),
         ParmairTimerNumber(
-            coordinator, entry, REG_BOOST_TIMER, "Boost Timer", "mdi:timer", "Set boost mode timer in minutes"
+            coordinator,
+            entry,
+            REG_BOOST_TIMER,
+            "Boost Timer",
+            "mdi:timer",
+            "Set boost mode timer in minutes",
         ),
         ParmairTimerNumber(
-            coordinator, entry, REG_OVERPRESSURE_TIMER, "Overpressure Timer", "mdi:timer", "Set overpressure mode timer in minutes"
+            coordinator,
+            entry,
+            REG_OVERPRESSURE_TIMER,
+            "Overpressure Timer",
+            "mdi:timer",
+            "Set overpressure mode timer in minutes",
         ),
     ]
 
@@ -144,7 +155,7 @@ def __init__(
     ) -> None:
         """Initialize speed preset number."""
         super().__init__(coordinator, entry, data_key, name)
-        
+
         # Adjust boost setting range (2-4 per documentation)
         if data_key == REG_BOOST_SETTING:
             self._attr_native_min_value = 2
@@ -167,7 +178,7 @@ def __init__(
     ) -> None:
         """Initialize temperature setpoint number."""
         super().__init__(coordinator, entry, data_key, name)
-        
+
         # Set appropriate ranges based on register
         if data_key == REG_EXHAUST_TEMP_SETPOINT:
             self._attr_native_min_value = 18.0
diff --git a/custom_components/parmair/pymodbus_compat.py b/custom_components/parmair/pymodbus_compat.py
index 5ceb23d..e09fb0d 100644
--- a/custom_components/parmair/pymodbus_compat.py
+++ b/custom_components/parmair/pymodbus_compat.py
@@ -27,15 +27,11 @@
 _WRITE_CANDIDATES = ("device_id", "slave", "unit")
 
 
-def read_holding_registers(
-    client: Any, address: int, count: int, unit_id: int
-) -> Any:
+def read_holding_registers(client: Any, address: int, count: int, unit_id: int) -> Any:
     """Read holding registers with unit ID. Works with any pymodbus 3.x bundled by HA."""
     global _read_kwarg
     if _read_kwarg is not None:
-        return client.read_holding_registers(
-            address=address, count=count, **{_read_kwarg: unit_id}
-        )
+        return client.read_holding_registers(address=address, count=count, **{_read_kwarg: unit_id})
     with _lock:
         if _read_kwarg is not None:
             return client.read_holding_registers(
@@ -52,28 +48,20 @@ def read_holding_registers(
             except TypeError:
                 continue
         _read_kwarg = "device_id"
-        return client.read_holding_registers(
-            address=address, count=count, device_id=unit_id
-        )
+        return client.read_holding_registers(address=address, count=count, device_id=unit_id)
 
 
 def write_register(client: Any, address: int, value: int, unit_id: int) -> Any:
     """Write single register with unit ID. Works with any pymodbus 3.x bundled by HA."""
     global _write_kwarg
     if _write_kwarg is not None:
-        return client.write_register(
-            address, value, **{_write_kwarg: unit_id}
-        )
+        return client.write_register(address, value, **{_write_kwarg: unit_id})
     with _lock:
         if _write_kwarg is not None:
-            return client.write_register(
-                address, value, **{_write_kwarg: unit_id}
-            )
+            return client.write_register(address, value, **{_write_kwarg: unit_id})
         for kw in _WRITE_CANDIDATES:
             try:
-                result = client.write_register(
-                    address, value, **{kw: unit_id}
-                )
+                result = client.write_register(address, value, **{kw: unit_id})
                 _write_kwarg = kw
                 _LOGGER.debug("pymodbus write_register uses %s=", kw)
                 return result
diff --git a/custom_components/parmair/select.py b/custom_components/parmair/select.py
index 9a0f34a..50ef64c 100644
--- a/custom_components/parmair/select.py
+++ b/custom_components/parmair/select.py
@@ -1,4 +1,5 @@
 """Select platform for Parmair MAC integration."""
+
 from __future__ import annotations
 
 import logging
@@ -7,25 +8,31 @@
 from homeassistant.config_entries import ConfigEntry
 from homeassistant.core import HomeAssistant
 from homeassistant.helpers.entity_platform import AddEntitiesCallback
-from homeassistant.helpers.update_coordinator import CoordinatorEntity
-
-from .const import (
-    DOMAIN,
-)
-from .coordinator import ParmairCoordinator
 
 _LOGGER = logging.getLogger(__name__)
 
 
 async def async_setup_entry(
-    hass: HomeAssistant,
-    entry: ConfigEntry,
+    _hass: HomeAssistant,
+    _entry: ConfigEntry,
     async_add_entities: AddEntitiesCallback,
 ) -> None:
     """Set up Parmair select platform."""
     coordinator: ParmairCoordinator = hass.data[DOMAIN][entry.entry_id]
-
-    # No select entities currently configured
-    entities: list[SelectEntity] = []
+    is_v2 = coordinator.software_version == SOFTWARE_VERSION_2 or str(
+        coordinator.software_version
+    ).startswith("2.")
+
+    entities: list[SelectEntity] = [
+        ParmairFilterIntervalSelect(coordinator, entry),
+        ParmairManualSpeedSelect(coordinator, entry),
+        ParmairSpeedPresetSelect(coordinator, entry, REG_HOME_SPEED, "Home Speed Preset"),
+        ParmairSpeedPresetSelect(coordinator, entry, REG_AWAY_SPEED, "Away Speed Preset"),
+        ParmairBoostSpeedSelect(coordinator, entry),
+        ParmairBoostDurationSelect(coordinator, entry),
+        ParmairOverpressureDurationSelect(coordinator, entry),
+    ]
+    if is_v2:
+        entities.append(ParmairSummerModeSelect(coordinator, entry))
 
     async_add_entities(entities)
diff --git a/custom_components/parmair/sensor.py b/custom_components/parmair/sensor.py
index e00cb75..2af85fa 100644
--- a/custom_components/parmair/sensor.py
+++ b/custom_components/parmair/sensor.py
@@ -1,4 +1,5 @@
 """Sensor platform for Parmair integration."""
+
 from __future__ import annotations
 
 import logging
@@ -13,7 +14,6 @@
     CONCENTRATION_PARTS_PER_MILLION,
     PERCENTAGE,
     UnitOfTemperature,
-    UnitOfTime,
 )
 from homeassistant.core import HomeAssistant
 from homeassistant.helpers.entity import EntityCategory
@@ -21,21 +21,20 @@
 from homeassistant.helpers.update_coordinator import CoordinatorEntity
 
 from .const import (
-    DOMAIN,
-    DEFAULT_NAME,
     CONTROL_STATE_MAP_V1,
     CONTROL_STATE_MAP_V2,
+    DOMAIN,
     FILTER_STATE_MAP_V1,
     FILTER_STATE_MAP_V2,
-    POWER_STATE_MAP_V1,
-    POWER_STATE_MAP_V2,
-    SOFTWARE_VERSION_2,
-    HEATER_TYPE_WATER_V1,
     HEATER_TYPE_ELECTRIC_V1,
-    HEATER_TYPE_NONE_V1,
     HEATER_TYPE_ELECTRIC_V2,
-    HEATER_TYPE_WATER_V2,
+    HEATER_TYPE_NONE_V1,
     HEATER_TYPE_NONE_V2,
+    HEATER_TYPE_WATER_V1,
+    HEATER_TYPE_WATER_V2,
+    POWER_STATE_MAP_V1,
+    POWER_STATE_MAP_V2,
+    SOFTWARE_VERSION_2,
 )
 from .coordinator import ParmairCoordinator
 
@@ -47,7 +46,7 @@ def _filter_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
     Prefers device-reported software_version over config entry."""
     sw = coordinator.data.get("software_version")
     if sw is not None:
-        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+        if sw >= 2.0 if isinstance(sw, int | float) else str(sw).startswith("2."):
             return FILTER_STATE_MAP_V2
         return FILTER_STATE_MAP_V1
     # Fallback to config entry when device data not yet available
@@ -62,7 +61,7 @@ def _power_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
     V1: Off, Shutting Down, Starting, Running. V2: Off, On."""
     sw = coordinator.data.get("software_version")
     if sw is not None:
-        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+        if sw >= 2.0 if isinstance(sw, int | float) else str(sw).startswith("2."):
             return POWER_STATE_MAP_V2
         return POWER_STATE_MAP_V1
     cfg = coordinator.software_version
@@ -76,7 +75,7 @@ def _control_state_map(coordinator: ParmairCoordinator) -> dict[int, str]:
     V1: Stop, Away, Home, Boost, Overpressure, timers, Manual. V2: Off, Away, Home, Boost, Sauna, Fireplace."""
     sw = coordinator.data.get("software_version")
     if sw is not None:
-        if sw >= 2.0 if isinstance(sw, (int, float)) else str(sw).startswith("2."):
+        if sw >= 2.0 if isinstance(sw, int | float) else str(sw).startswith("2."):
             return CONTROL_STATE_MAP_V2
         return CONTROL_STATE_MAP_V1
     cfg = coordinator.software_version
@@ -92,37 +91,47 @@ async def async_setup_entry(
 ) -> None:
     """Set up Parmair sensor platform."""
     coordinator: ParmairCoordinator = hass.data[DOMAIN][entry.entry_id]
-    
+
     _LOGGER.debug(
         "Setting up Parmair sensors. Available data keys: %s",
         list(coordinator.data.keys()) if coordinator.data else "None",
     )
-    
+
     entities = [
         # System information
         ParmairSoftwareVersionSensor(coordinator, entry, "software_version", "Software Version"),
         ParmairHeaterTypeSensor(coordinator, entry, "heater_type", "Heater Type"),
-        
         # Temperature sensors
         ParmairTemperatureSensor(coordinator, entry, "fresh_air_temp", "Fresh Air Temperature"),
-        ParmairTemperatureSensor(coordinator, entry, "supply_after_recovery_temp", "Supply Air Temperature (After Recovery)"),
+        ParmairTemperatureSensor(
+            coordinator,
+            entry,
+            "supply_after_recovery_temp",
+            "Supply Air Temperature (After Recovery)",
+        ),
         ParmairTemperatureSensor(coordinator, entry, "supply_temp", "Supply Air Temperature"),
         ParmairTemperatureSensor(coordinator, entry, "exhaust_temp", "Exhaust Air Temperature"),
         ParmairTemperatureSensor(coordinator, entry, "waste_temp", "Waste Air Temperature"),
-        ParmairTemperatureSensor(coordinator, entry, "exhaust_temp_setpoint", "Exhaust Temperature Setpoint"),
-        ParmairTemperatureSensor(coordinator, entry, "supply_temp_setpoint", "Supply Temperature Setpoint"),
-        
+        ParmairTemperatureSensor(
+            coordinator, entry, "exhaust_temp_setpoint", "Exhaust Temperature Setpoint"
+        ),
+        ParmairTemperatureSensor(
+            coordinator, entry, "supply_temp_setpoint", "Supply Temperature Setpoint"
+        ),
         # Other sensors
         ParmairControlStateSensor(coordinator, entry, "control_state", "Control State"),
         ParmairSpeedControlSensor(coordinator, entry, "actual_speed", "Current Speed"),
         ParmairPowerStateSensor(coordinator, entry, "power", "Power State"),
-        ParmairBinarySensor(coordinator, entry, "home_state", "Home/Away State", {0: "Away", 1: "Home"}),
+        ParmairBinarySensor(
+            coordinator, entry, "home_state", "Home/Away State", {0: "Away", 1: "Home"}
+        ),
         ParmairBinarySensor(coordinator, entry, "boost_state", "Boost State", {0: "Off", 1: "On"}),
         ParmairAlarmSensor(coordinator, entry, "alarm_count", "Alarm Count"),
         ParmairAlarmSensor(coordinator, entry, "sum_alarm", "Summary Alarm"),
-        
         # State sensors
-        ParmairBinarySensor(coordinator, entry, "defrost_state", "Defrost State", {0: "Off", 1: "Active"}),
+        ParmairBinarySensor(
+            coordinator, entry, "defrost_state", "Defrost State", {0: "Off", 1: "Active"}
+        ),
         ParmairBinarySensor(
             coordinator,
             entry,
@@ -130,23 +139,24 @@ async def async_setup_entry(
             "Filter Status",
             _filter_state_map(coordinator),
         ),
-        
         # Performance sensors
-        ParmairPercentageSensor(coordinator, entry, "heat_recovery_efficiency", "Heat Recovery Efficiency"),
-        ParmairPercentageSensor(coordinator, entry, "lto_heat_recovery_control", "LTO Heat Recovery Control"),
+        ParmairPercentageSensor(
+            coordinator, entry, "heat_recovery_efficiency", "Heat Recovery Efficiency"
+        ),
+        ParmairPercentageSensor(
+            coordinator, entry, "lto_heat_recovery_control", "LTO Heat Recovery Control"
+        ),
         ParmairPercentageSensor(coordinator, entry, "supply_fan_speed", "Supply Fan Speed"),
         ParmairPercentageSensor(coordinator, entry, "exhaust_fan_speed", "Exhaust Fan Speed"),
         ParmairPercentageSensor(coordinator, entry, "pre_heater_output", "Pre-heater Output"),
         ParmairPercentageSensor(coordinator, entry, "post_heater_output", "Post-heater Output"),
-        
         # Optional sensors (will show unavailable if hardware not present)
         ParmairHumiditySensor(coordinator, entry, "humidity", "Humidity"),
         ParmairHumidity24hAvgSensor(coordinator, entry, "humidity_24h_avg", "Humidity 24h Average"),
-        
         # Filter change date sensor
         ParmairFilterChangeDateSensor(coordinator, entry),
     ]
-    
+
     # Add exhaust CO2 sensor only for MAC 2 devices (v2.xx firmware)
     # QE05_M = Combination sensor in exhaust duct (CO2 + humidity)
     # Only in newest MAC 2 devices
@@ -156,7 +166,7 @@ async def async_setup_entry(
     except (KeyError, ValueError):
         # Register doesn't exist in v1.xx firmware - skip this sensor
         pass
-    
+
     async_add_entities(entities)
 
 
@@ -432,13 +442,11 @@ def native_value(self) -> int | None:
         if raw_value is None:
             return None
         return int(raw_value)
-    
+
     @property
     def extra_state_attributes(self) -> dict[str, str]:
         """Return additional attributes."""
-        return {
-            "description": "0=Stop, 1=Speed 1, 2=Speed 2, 3=Speed 3, 4=Speed 4, 5=Speed 5"
-        }
+        return {"description": "0=Stop, 1=Speed 1, 2=Speed 2, 3=Speed 3, 4=Speed 4, 5=Speed 5"}
 
 
 class ParmairPowerStateSensor(ParmairRegisterEntity, SensorEntity):
@@ -475,7 +483,7 @@ def native_value(self) -> str | None:
 
 class ParmairHeaterTypeSensor(ParmairRegisterEntity, SensorEntity):
     """Representation of heater type with mapped values.
-    
+
     NOTE: Heater type values are REVERSED between firmware versions!
     v1.xx: 0=Water, 1=Electric, 2=None
     v2.xx: 0=Electric, 1=Water, 2=None
@@ -490,14 +498,14 @@ class ParmairHeaterTypeSensor(ParmairRegisterEntity, SensorEntity):
     STATE_MAP_V1 = {
         HEATER_TYPE_WATER_V1: "Water",
         HEATER_TYPE_ELECTRIC_V1: "Electric",
-        HEATER_TYPE_NONE_V1: "None"
+        HEATER_TYPE_NONE_V1: "None",
     }
-    
+
     # v2.xx mapping (register 1127)
     STATE_MAP_V2 = {
         HEATER_TYPE_ELECTRIC_V2: "Electric",
         HEATER_TYPE_WATER_V2: "Water",
-        HEATER_TYPE_NONE_V2: "None"
+        HEATER_TYPE_NONE_V2: "None",
     }
 
     def __init__(
@@ -516,7 +524,7 @@ def native_value(self) -> str | None:
         raw_value = self.coordinator.data.get(self._data_key)
         if raw_value is None:
             return None
-        
+
         # Determine firmware version from software_version sensor
         software_version = self.coordinator.data.get("software_version")
         if software_version and software_version >= 2.0:
@@ -590,10 +598,10 @@ def native_value(self) -> str | None:
         day = self.coordinator.data.get("filter_day")
         month = self.coordinator.data.get("filter_month")
         year = self.coordinator.data.get("filter_year")
-        
+
         if day is None or month is None or year is None:
             return None
-        
+
         # Validate date values
         try:
             if not (1 <= day <= 31 and 1 <= month <= 12 and 2000 <= year <= 3000):
@@ -608,14 +616,14 @@ def extra_state_attributes(self) -> dict[str, any]:
         next_day = self.coordinator.data.get("filter_next_day")
         next_month = self.coordinator.data.get("filter_next_month")
         next_year = self.coordinator.data.get("filter_next_year")
-        
+
         attrs = {}
-        
+
         if next_day is not None and next_month is not None and next_year is not None:
             try:
                 if 1 <= next_day <= 31 and 1 <= next_month <= 12 and 2000 <= next_year <= 3000:
                     attrs["next_change_date"] = f"{next_year:04d}-{next_month:02d}-{next_day:02d}"
             except (ValueError, TypeError):
                 pass
-        
+
         return attrs
diff --git a/custom_components/parmair/switch.py b/custom_components/parmair/switch.py
index d232e96..ca183ed 100644
--- a/custom_components/parmair/switch.py
+++ b/custom_components/parmair/switch.py
@@ -1,4 +1,5 @@
 """Switch platform for Parmair MAC integration."""
+
 from __future__ import annotations
 
 import logging
@@ -38,47 +39,57 @@ async def async_setup_entry(
 ) -> None:
     """Set up Parmair switch platform."""
     coordinator: ParmairCoordinator = hass.data[DOMAIN][entry.entry_id]
-
-    entities: list[SwitchEntity] = [
-        ParmairSwitch(
-            coordinator,
-            entry,
-            REG_SUMMER_MODE,
-            "Summer Mode",
-            "mdi:weather-sunny",
-            "Enables heat recovery summer operation mode",
-        ),
-        ParmairSwitch(
-            coordinator,
-            entry,
-            REG_TIME_PROGRAM_ENABLE,
-            "Time Program",
-            "mdi:clock-outline",
-            "Enables weekly time program control",
-        ),
-        ParmairSwitch(
-            coordinator,
-            entry,
-            REG_HEATER_ENABLE,
-            "Post Heater",
-            "mdi:radiator",
-            "Enables post-heating element",
-        ),
-        ParmairBoostSwitch(
-            coordinator,
-            entry,
-            "Boost Mode",
-            "mdi:fan-plus",
-            "Activates boost ventilation mode",
-        ),
-        ParmairOverpressureSwitch(
-            coordinator,
-            entry,
-            "Overpressure Mode",
-            "mdi:gauge",
-            "Activates overpressure mode",
-        ),
-    ]
+    is_v1 = coordinator.software_version == SOFTWARE_VERSION_1 or str(
+        coordinator.software_version
+    ).startswith("1.")
+
+    entities: list[SwitchEntity] = []
+    # Summer Mode: V1 uses switch (0/1), V2 uses Select (Off/On/Auto)
+    if is_v1:
+        entities.append(
+            ParmairSwitch(
+                coordinator,
+                entry,
+                REG_SUMMER_MODE,
+                "Summer Mode",
+                "mdi:weather-sunny",
+                "Enables heat recovery summer operation mode",
+            )
+        )
+    entities.extend(
+        [
+            ParmairSwitch(
+                coordinator,
+                entry,
+                REG_TIME_PROGRAM_ENABLE,
+                "Time Program",
+                "mdi:clock-outline",
+                "Enables weekly time program control",
+            ),
+            ParmairSwitch(
+                coordinator,
+                entry,
+                REG_HEATER_ENABLE,
+                "Post Heater",
+                "mdi:radiator",
+                "Enables post-heating element",
+            ),
+            ParmairBoostSwitch(
+                coordinator,
+                entry,
+                "Boost Mode",
+                "mdi:fan-plus",
+                "Activates boost ventilation mode",
+            ),
+            ParmairOverpressureSwitch(
+                coordinator,
+                entry,
+                "Overpressure Mode",
+                "mdi:gauge",
+                "Activates overpressure mode",
+            ),
+        ]
+    )
 
     async_add_entities(entities)
 
@@ -115,10 +126,9 @@ def is_on(self) -> bool | None:
             return None
         # V2 summer mode (AUTO_SUMMER_COOL_S): 0=off, 1=on, 2=auto
         if self._data_key == REG_SUMMER_MODE:
-            is_v2 = (
-                self.coordinator.software_version == SOFTWARE_VERSION_2
-                or str(self.coordinator.software_version).startswith("2.")
-            )
+            is_v2 = self.coordinator.software_version == SOFTWARE_VERSION_2 or str(
+                self.coordinator.software_version
+            ).startswith("2.")
             if is_v2:
                 return value in (1, 2)
         return value == 1
@@ -186,22 +196,32 @@ def is_on(self) -> bool | None:
     def extra_state_attributes(self) -> dict[str, Any]:
         """Return boost mode predefined settings and current timer."""
         # Boost time setting: 0=30min, 1=60min, 2=90min, 3=120min, 4=180min
-        boost_time_map = {0: "30 minutes", 1: "60 minutes", 2: "90 minutes", 3: "120 minutes", 4: "180 minutes"}
+        boost_time_map = {
+            0: "30 minutes",
+            1: "60 minutes",
+            2: "90 minutes",
+            3: "120 minutes",
+            4: "180 minutes",
+        }
         # Boost speed setting: 2-4 maps to speed 3-5
         boost_speed_map = {2: "Speed 3", 3: "Speed 4", 4: "Speed 5"}
-        
+
         boost_time_value = self.coordinator.data.get(REG_BOOST_TIME_SETTING)
         boost_speed_value = self.coordinator.data.get(REG_BOOST_SETTING)
         boost_timer_remaining = self.coordinator.data.get(REG_BOOST_TIMER)
-        
+
         attrs = {}
         if boost_time_value is not None:
-            attrs["preset_duration"] = boost_time_map.get(boost_time_value, f"Unknown ({boost_time_value})")
+            attrs["preset_duration"] = boost_time_map.get(
+                boost_time_value, f"Unknown ({boost_time_value})"
+            )
         if boost_speed_value is not None:
-            attrs["preset_speed"] = boost_speed_map.get(boost_speed_value, f"Unknown ({boost_speed_value})")
+            attrs["preset_speed"] = boost_speed_map.get(
+                boost_speed_value, f"Unknown ({boost_speed_value})"
+            )
         if boost_timer_remaining is not None and boost_timer_remaining > 0:
             attrs["remaining_time"] = f"{boost_timer_remaining} minutes"
-        
+
         return attrs
 
     async def async_turn_on(self, **kwargs: Any) -> None:
@@ -257,17 +277,25 @@ def is_on(self) -> bool | None:
     def extra_state_attributes(self) -> dict[str, Any]:
         """Return overpressure mode predefined settings and current timer."""
         # Overpressure time setting: 0=15min, 1=30min, 2=45min, 3=60min, 4=120min
-        overp_time_map = {0: "15 minutes", 1: "30 minutes", 2: "45 minutes", 3: "60 minutes", 4: "120 minutes"}
-        
+        overp_time_map = {
+            0: "15 minutes",
+            1: "30 minutes",
+            2: "45 minutes",
+            3: "60 minutes",
+            4: "120 minutes",
+        }
+
         overp_time_value = self.coordinator.data.get(REG_OVERPRESSURE_TIME_SETTING)
         overp_timer_remaining = self.coordinator.data.get(REG_OVERPRESSURE_TIMER)
-        
+
         attrs = {}
         if overp_time_value is not None:
-            attrs["preset_duration"] = overp_time_map.get(overp_time_value, f"Unknown ({overp_time_value})")
+            attrs["preset_duration"] = overp_time_map.get(
+                overp_time_value, f"Unknown ({overp_time_value})"
+            )
         if overp_timer_remaining is not None and overp_timer_remaining > 0:
             attrs["remaining_time"] = f"{overp_timer_remaining} minutes"
-        
+
         return attrs
 
     async def async_turn_on(self, **kwargs: Any) -> None:
diff --git a/test_connection.py b/test_connection.py
index e36e158..e9e2906 100644
--- a/test_connection.py
+++ b/test_connection.py
@@ -5,13 +5,14 @@
 
 Usage:
     python test_connection.py <host> [port] [slave_id]
-    
+
 Example:
     python test_connection.py 192.168.1.100
     python test_connection.py 192.168.1.100 502 0
 """
 
 import sys
+
 from pymodbus.client import ModbusTcpClient
 
 # Register addresses from const.py (subtract 1 from register ID)
@@ -32,68 +33,76 @@ def _read_register(client, address, slave_id):
 def test_connection(host, port=502, slave_id=0):
     """Test connection to Parmair device."""
     print(f"Connecting to Parmair device at {host}:{port} (slave ID: {slave_id})")
-    
+
     client = ModbusTcpClient(host=host, port=port)
-    
+
     try:
         # Connect to device
         if not client.connect():
             print("❌ Failed to connect to device")
             print("   Check IP address, port, and network connectivity")
             return False
-        
+
         print("✅ Connected successfully")
-        
+
         # Test reading power status
         print("\nReading registers...")
         result = _read_register(client, REGISTER_POWER, slave_id)
-        
+
         if result.isError():
             print(f"❌ Error reading register {REGISTER_POWER}: {result}")
             print("   Check slave ID and Modbus configuration")
             return False
-        
+
         power_state = result.registers[0]
         power_states = {0: "Off", 1: "Shutting down", 2: "Starting", 3: "Running"}
-        print(f"✅ Power State (Reg 208): {power_state} ({power_states.get(power_state, 'Unknown')})")
-        
+        print(
+            f"✅ Power State (Reg 208): {power_state} ({power_states.get(power_state, 'Unknown')})"
+        )
+
         # Read control state
         result = _read_register(client, REGISTER_CONTROL_STATE, slave_id)
         if not result.isError():
             control_state = result.registers[0]
             control_states = {
-                0: "STOP", 1: "AWAY", 2: "HOME", 3: "BOOST",
-                4: "OVERPRESSURE", 9: "MANUAL"
+                0: "STOP",
+                1: "AWAY",
+                2: "HOME",
+                3: "BOOST",
+                4: "OVERPRESSURE",
+                9: "MANUAL",
             }
-            print(f"✅ Control State (Reg 185): {control_state} ({control_states.get(control_state, f'Mode {control_state}')})")
-        
+            print(
+                f"✅ Control State (Reg 185): {control_state} ({control_states.get(control_state, f'Mode {control_state}')})"
+            )
+
         # Read exhaust temperature
         result = _read_register(client, REGISTER_EXHAUST_TEMP, slave_id)
         if not result.isError():
             temp = result.registers[0] / 10.0
             print(f"✅ Exhaust Temperature (Reg 24): {temp}°C")
-        
+
         # Read supply temperature
         result = _read_register(client, REGISTER_SUPPLY_TEMP, slave_id)
         if not result.isError():
             temp = result.registers[0] / 10.0
             print(f"✅ Supply Temperature (Reg 23): {temp}°C")
-        
-        print("\n" + "="*50)
+
+        print("\n" + "=" * 50)
         print("✅ Connection test successful!")
-        print("="*50)
+        print("=" * 50)
         print("\nYou can now add the Parmair integration in Home Assistant:")
         print("  1. Go to Settings → Devices & Services")
         print("  2. Click '+ ADD INTEGRATION'")
         print("  3. Search for 'Parmair'")
         print(f"  4. Enter host: {host}, port: {port}, slave ID: {slave_id}")
-        
+
         return True
-        
+
     except Exception as ex:
         print(f"❌ Exception occurred: {ex}")
         return False
-    
+
     finally:
         client.close()
 
@@ -104,11 +113,11 @@ def main():
         print("Usage: python test_connection.py <host> [port] [slave_id]")
         print("Example: python test_connection.py 192.168.1.100")
         sys.exit(1)
-    
+
     host = sys.argv[1]
     port = int(sys.argv[2]) if len(sys.argv) > 2 else 502
     slave_id = int(sys.argv[3]) if len(sys.argv) > 3 else 0
-    
+
     try:
         success = test_connection(host, port, slave_id)
         sys.exit(0 if success else 1)
diff --git a/tests/__init__.py b/tests/__init__.py
index 2bfddd0..812b982 100644
--- a/tests/__init__.py
+++ b/tests/__init__.py
@@ -1,2 +1 @@
 """Parmair integration tests."""
-
diff --git a/tests/conftest.py b/tests/conftest.py
index 382dd66..d1ce874 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -84,7 +84,7 @@ def mac120_v2_coordinator() -> MockCoordinator | None:
 def is_v2_device(coordinator: MockCoordinator) -> bool:
     """Check if the current fixture is a V2.x device."""
     sw_ver = coordinator.data.get("software_version", 0)
-    return sw_ver >= 2.0 if isinstance(sw_ver, (int, float)) else False
+    return sw_ver >= 2.0 if isinstance(sw_ver, int | float) else False
 
 
 # Collect all fixture files at module load time for test discovery
diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
index 2dfa8df..47a331c 100644
--- a/tests/test_interpretation.py
+++ b/tests/test_interpretation.py
@@ -7,6 +7,7 @@
 
 from __future__ import annotations
 
+import re
 import sys
 from pathlib import Path
 from typing import Any
@@ -18,18 +19,16 @@
 sys.path.insert(0, str(PROJECT_ROOT))
 sys.path.insert(0, str(PROJECT_ROOT / "tools"))
 
-import re
-
-from custom_components.parmair.const import (
+from custom_components.parmair.const import (  # noqa: E402
     FILTER_STATE_MAP_V1,
     FILTER_STATE_MAP_V2,
     SOFTWARE_VERSION_2,
 )
-from tools.mock_coordinator import (
-    MockCoordinator,
+from tools.mock_coordinator import (  # noqa: E402
     HARDWARE_TYPE_MAP_V2,
-    REG_POWER,
     REG_CONTROL_STATE,
+    REG_POWER,
+    MockCoordinator,
     get_registers_for_version,
     load_dump,
 )
@@ -47,8 +46,10 @@ def test_fixture_loads_successfully(self, coordinator: MockCoordinator) -> None:
     def test_fixture_has_metadata(self, fixture_metadata: dict[str, Any]) -> None:
         """Verify fixture has required metadata."""
         assert "register_map_version" in fixture_metadata, "Fixture must have register_map_version"
-        assert "detected_software_version" in fixture_metadata, "Fixture must have detected_software_version"
-        
+        assert "detected_software_version" in fixture_metadata, (
+            "Fixture must have detected_software_version"
+        )
+
     def test_fixture_has_registers(self, fixture_registers: dict[str, Any]) -> None:
         """Verify fixture has register data."""
         assert len(fixture_registers) > 0
@@ -61,7 +62,7 @@ def test_software_version_present(self, coordinator: MockCoordinator) -> None:
         """Software version should be present and valid."""
         sw_ver = coordinator.data.get("software_version")
         assert sw_ver is not None, "Software version should be present"
-        assert isinstance(sw_ver, (int, float)), "Software version should be numeric"
+        assert isinstance(sw_ver, int | float), "Software version should be numeric"
         assert 0.5 <= sw_ver <= 10.0, f"Software version {sw_ver} out of expected range"
 
     def test_hardware_type_present(self, coordinator: MockCoordinator) -> None:
@@ -105,26 +106,22 @@ def test_temperatures_present(self, coordinator: MockCoordinator) -> None:
         assert len(present) >= 3, f"Expected at least 3 temperatures, found: {present}"
 
     @pytest.mark.parametrize("temp_key", TEMP_KEYS)
-    def test_temperature_in_valid_range(
-        self, coordinator: MockCoordinator, temp_key: str
-    ) -> None:
+    def test_temperature_in_valid_range(self, coordinator: MockCoordinator, temp_key: str) -> None:
         """Temperature values should be in a physically reasonable range."""
         if temp_key not in coordinator.data:
             pytest.skip(f"{temp_key} not present in fixture")
-        
+
         value = coordinator.data[temp_key]
         assert value is not None
         # Allow -50°C to +80°C range for ventilation systems
         assert -50 <= value <= 80, f"{temp_key}={value}°C out of valid range"
 
     @pytest.mark.parametrize("setpoint_key", SETPOINT_KEYS)
-    def test_setpoint_in_valid_range(
-        self, coordinator: MockCoordinator, setpoint_key: str
-    ) -> None:
+    def test_setpoint_in_valid_range(self, coordinator: MockCoordinator, setpoint_key: str) -> None:
         """Temperature setpoints should be in a reasonable range."""
         if setpoint_key not in coordinator.data:
             pytest.skip(f"{setpoint_key} not present in fixture")
-        
+
         value = coordinator.data[setpoint_key]
         assert value is not None
         # Setpoints typically 10°C to 30°C
@@ -139,7 +136,7 @@ def test_power_state_valid(self, coordinator: MockCoordinator) -> None:
         power = coordinator.data.get("power")
         if power is None:
             pytest.skip("Power state not present")
-        
+
         # V1: 0=Off, 1=Shutting Down, 2=Starting, 3=Running
         # V2: 0=Off, 1=On
         assert power in (0, 1, 2, 3), f"Invalid power state: {power}"
@@ -149,7 +146,7 @@ def test_control_state_valid(self, coordinator: MockCoordinator) -> None:
         control = coordinator.data.get("control_state")
         if control is None:
             pytest.skip("Control state not present")
-        
+
         # V1: 0=Stop, 1=Away, 2=Home, 3=Boost, 4=Overpressure, 5-8=Timers, 9=Manual
         # V2: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace
         assert 0 <= control <= 10, f"Invalid control state: {control}"
@@ -159,7 +156,7 @@ def test_defrost_state_binary(self, coordinator: MockCoordinator) -> None:
         defrost = coordinator.data.get("defrost_state")
         if defrost is None:
             pytest.skip("Defrost state not present")
-        
+
         assert defrost in (0, 1), f"Invalid defrost state: {defrost}"
 
 
@@ -171,7 +168,7 @@ def test_actual_speed_valid(self, coordinator: MockCoordinator) -> None:
         speed = coordinator.data.get("actual_speed")
         if speed is None:
             pytest.skip("Actual speed not present")
-        
+
         # Speed typically 0-5 or similar
         assert 0 <= speed <= 10, f"Invalid actual speed: {speed}"
 
@@ -181,7 +178,7 @@ def test_fan_speeds_percentage(self, coordinator: MockCoordinator) -> None:
             value = coordinator.data.get(key)
             if value is None:
                 continue
-            
+
             assert 0 <= value <= 100, f"{key}={value}% out of valid range"
 
     def test_preset_speeds_valid(self, coordinator: MockCoordinator) -> None:
@@ -190,7 +187,7 @@ def test_preset_speeds_valid(self, coordinator: MockCoordinator) -> None:
             value = coordinator.data.get(key)
             if value is None:
                 continue
-            
+
             # Preset speeds typically 1-5
             assert 0 <= value <= 10, f"{key}={value} out of valid range"
 
@@ -202,20 +199,20 @@ def test_humidity_valid_if_present(self, coordinator: MockCoordinator) -> None:
         """Humidity should be 0-100% if present and installed."""
         humidity = coordinator.data.get("humidity")
         raw = coordinator.get_raw_value("humidity")
-        
+
         if humidity is None or raw in (0, -1, 65535):
             pytest.skip("Humidity sensor not installed")
-        
+
         assert 0 <= humidity <= 100, f"Invalid humidity: {humidity}%"
 
     def test_co2_valid_if_present(self, coordinator: MockCoordinator) -> None:
         """CO2 should be reasonable ppm if present and installed."""
         co2 = coordinator.data.get("co2")
         raw = coordinator.get_raw_value("co2")
-        
+
         if co2 is None or raw in (0, -1, 65535):
             pytest.skip("CO2 sensor not installed")
-        
+
         # CO2 typically 400-5000 ppm in ventilation scenarios
         assert 200 <= co2 <= 10000, f"Invalid CO2: {co2} ppm"
 
@@ -228,7 +225,7 @@ def test_filter_state_valid(self, coordinator: MockCoordinator) -> None:
         state = coordinator.data.get("filter_state")
         if state is None:
             pytest.skip("Filter state not present")
-        
+
         # V1: 0=Replace, 1=OK
         # V2: 0=OK, 1=Ack, 2=Reminder
         assert state in (0, 1, 2), f"Invalid filter state: {state}"
@@ -238,10 +235,9 @@ def test_filter_state_display_mapping_v2(self) -> None:
         coord = load_dump(PROJECT_ROOT / "tests" / "fixtures" / "MAC120-full-v2.json")
         state = coord.data.get("filter_state")
         assert state is not None, "Fixture must have filter_state"
-        is_v2 = (
-            coord.software_version == SOFTWARE_VERSION_2
-            or str(coord.software_version).startswith("2.")
-        )
+        is_v2 = coord.software_version == SOFTWARE_VERSION_2 or str(
+            coord.software_version
+        ).startswith("2.")
         assert is_v2, "MAC120-full-v2 fixture should be V2"
         mapping = FILTER_STATE_MAP_V2 if is_v2 else FILTER_STATE_MAP_V1
         display = mapping.get(int(state), "Unknown")
@@ -255,10 +251,10 @@ def test_filter_date_valid(self, coordinator: MockCoordinator) -> None:
         day = coordinator.data.get("filter_day")
         month = coordinator.data.get("filter_month")
         year = coordinator.data.get("filter_year")
-        
+
         if day is None or month is None or year is None:
             pytest.skip("Filter date not present")
-        
+
         assert 1 <= day <= 31, f"Invalid filter day: {day}"
         assert 1 <= month <= 12, f"Invalid filter month: {month}"
         assert 2000 <= year <= 3000, f"Invalid filter year: {year}"
@@ -268,7 +264,7 @@ def test_filter_interval_valid(self, coordinator: MockCoordinator) -> None:
         interval = coordinator.data.get("filter_interval")
         if interval is None:
             pytest.skip("Filter interval not present")
-        
+
         # V2: 0=3 months, 1=4 months, 2=6 months
         assert 0 <= interval <= 10, f"Invalid filter interval: {interval}"
 
@@ -281,7 +277,7 @@ def test_heat_recovery_efficiency_valid(self, coordinator: MockCoordinator) -> N
         efficiency = coordinator.data.get("heat_recovery_efficiency")
         if efficiency is None:
             pytest.skip("Heat recovery efficiency not present")
-        
+
         assert 0 <= efficiency <= 100, f"Invalid efficiency: {efficiency}%"
 
     def test_heater_outputs_percentage(self, coordinator: MockCoordinator) -> None:
@@ -290,7 +286,7 @@ def test_heater_outputs_percentage(self, coordinator: MockCoordinator) -> None:
             value = coordinator.data.get(key)
             if value is None:
                 continue
-            
+
             assert 0 <= value <= 100, f"{key}={value}% out of valid range"
 
 
@@ -302,25 +298,29 @@ def test_temperature_scaling(self, coordinator: MockCoordinator) -> None:
         # Check that raw/scaled relationship is correct for a temp register
         raw = coordinator.get_raw_value("supply_temp")
         scaled = coordinator.data.get("supply_temp")
-        
+
         if raw is None or scaled is None:
             pytest.skip("Supply temp not present")
-        
+
         # With 0.1 scaling, raw 174 should give 17.4
         expected = raw * 0.1
-        assert abs(scaled - expected) < 0.01, f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        assert abs(scaled - expected) < 0.01, (
+            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        )
 
     def test_version_scaling(self, coordinator: MockCoordinator) -> None:
         """Version values should be scaled by 0.01."""
         raw = coordinator.get_raw_value("software_version")
         scaled = coordinator.data.get("software_version")
-        
+
         if raw is None or scaled is None:
             pytest.skip("Software version not present")
-        
+
         # With 0.01 scaling, raw 225 should give 2.25
         expected = raw * 0.01
-        assert abs(scaled - expected) < 0.001, f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        assert abs(scaled - expected) < 0.001, (
+            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        )
 
 
 class TestRegisterDefinitions:
@@ -377,9 +377,7 @@ class TestRegisterMap:
     def test_v2_register_addresses_match_documentation(self) -> None:
         """V2 register addresses must match device docs (catches wrong map in writes)."""
         regs = get_registers_for_version(SOFTWARE_VERSION_2)
-        assert regs[REG_POWER].address == 1180, (
-            "V2 POWER should be UNIT_CONTROL_FO at 1180"
-        )
+        assert regs[REG_POWER].address == 1180, "V2 POWER should be UNIT_CONTROL_FO at 1180"
         assert regs[REG_CONTROL_STATE].address == 1181, (
             "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
         )
@@ -394,17 +392,15 @@ def test_power_register_address_varies_by_version(self) -> None:
 class TestV2Specific:
     """Tests specific to V2.x firmware."""
 
-    def test_season_state_v2(
-        self, coordinator: MockCoordinator, is_v2_device: bool
-    ) -> None:
+    def test_season_state_v2(self, coordinator: MockCoordinator, is_v2_device: bool) -> None:
         """V2 devices should have season state."""
         if not is_v2_device:
             pytest.skip("Not a V2 device")
-        
+
         season = coordinator.data.get("season_state")
         if season is None:
             pytest.skip("Season state not present")
-        
+
         # V2: 0=Winter, 1=Transition, 2=Summer
         assert season in (0, 1, 2), f"Invalid V2 season state: {season}"
 
@@ -414,11 +410,11 @@ def test_hardware_type_mapping_v2(
         """V2 hardware type codes should map to correct model (e.g. 112 -> MAC 120)."""
         if not is_v2_device:
             pytest.skip("Not a V2 device")
-        
+
         hw_type = coordinator.data.get("hardware_type")
         if hw_type is None:
             pytest.skip("Hardware type not present")
-        
+
         hw_int = int(hw_type)
         expected_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int)
         expected_model = f"MAC {expected_num}"
@@ -437,7 +433,4 @@ def test_v2_derived_states_binary(
             value = coordinator.data.get(key)
             if value is None:
                 continue
-            assert value in (0, 1), (
-                f"{key} must be 0 or 1 for binary sensor, got {value}"
-            )
-
+            assert value in (0, 1), f"{key} must be 0 or 1 for binary sensor, got {value}"
diff --git a/tools/discover_registers.py b/tools/discover_registers.py
index 4b3bfa2..a71d3ee 100644
--- a/tools/discover_registers.py
+++ b/tools/discover_registers.py
@@ -142,11 +142,11 @@ def read_register(client: ModbusTcpClient, address: int, slave_id: int) -> int |
                 result = client.read_holding_registers(address, 1, unit=slave_id)
             except TypeError:
                 return None
-    
+
     try:
-        if hasattr(result, 'isError') and result.isError():
+        if hasattr(result, "isError") and result.isError():
             return None
-        if hasattr(result, 'registers') and result.registers:
+        if hasattr(result, "registers") and result.registers:
             return result.registers[0]
         return None
     except Exception:
@@ -161,61 +161,61 @@ def main():
     parser.add_argument("--start", type=int, default=1000, help="Start address (default: 1000)")
     parser.add_argument("--end", type=int, default=1300, help="End address (default: 1300)")
     parser.add_argument("--output", type=str, help="Output JSON file")
-    
+
     args = parser.parse_args()
-    
+
     print(f"Connecting to {args.host}:{args.port}...")
     client = ModbusTcpClient(args.host, port=args.port)
-    
+
     if not client.connect():
         print("Failed to connect!")
         sys.exit(1)
-    
+
     print(f"Scanning registers {args.start} to {args.end}...")
     print()
-    
+
     documented = []
     undocumented = []
-    
+
     for addr in range(args.start, args.end + 1):
         value = read_register(client, addr, args.slave)
-        
+
         if value is not None:
             is_documented = addr in V2_DOCUMENTED
             label = V2_DOCUMENTED.get(addr, "???")
             status = "✓" if is_documented else "?"
-            
+
             entry = {
                 "address": addr,
                 "value": value,
                 "label": label,
                 "documented": is_documented,
             }
-            
+
             if is_documented:
                 documented.append(entry)
             else:
                 undocumented.append(entry)
-            
+
             # Print progress
             print(f"  {status} {addr:4d}: {value:6d}  {label}")
-    
+
     client.close()
-    
+
     print()
     print("=" * 60)
-    print(f"SUMMARY")
+    print("SUMMARY")
     print("=" * 60)
     print(f"Documented registers found: {len(documented)}")
     print(f"Undocumented registers found: {len(undocumented)}")
     print()
-    
+
     if undocumented:
         print("UNDOCUMENTED REGISTERS (need investigation):")
         print("-" * 60)
         for entry in undocumented:
             print(f"  Address {entry['address']:4d}: value={entry['value']:6d}")
-    
+
     # Save to file if requested
     if args.output:
         output_data = {
@@ -225,7 +225,7 @@ def main():
             "documented": documented,
             "undocumented": undocumented,
         }
-        
+
         output_path = Path(args.output)
         with open(output_path, "w") as f:
             json.dump(output_data, f, indent=2)
@@ -234,4 +234,3 @@ def main():
 
 if __name__ == "__main__":
     main()
-
diff --git a/tools/dump_registers.py b/tools/dump_registers.py
index f616c08..29044b1 100644
--- a/tools/dump_registers.py
+++ b/tools/dump_registers.py
@@ -19,7 +19,7 @@
 import json
 import sys
 import time
-from dataclasses import asdict, dataclass
+from dataclasses import dataclass
 from datetime import datetime
 from pathlib import Path
 from typing import Any
@@ -75,7 +75,7 @@ def to_json(self) -> str:
         )
 
     @classmethod
-    def from_json(cls, json_str: str) -> "DeviceDump":
+    def from_json(cls, json_str: str) -> DeviceDump:
         """Create from JSON string."""
         data = json.loads(json_str)
         return cls(metadata=data["metadata"], registers=data["registers"])
@@ -106,7 +106,7 @@ def read_single_register(
 
     if hasattr(result, "registers"):
         raw = result.registers[0]
-    elif isinstance(result, (list, tuple)):
+    elif isinstance(result, list | tuple):
         raw = result[0]
     else:
         raw = result
@@ -120,10 +120,7 @@ def read_single_register(
         return raw, None
 
     # Apply scaling
-    if definition.scale == 1:
-        scaled = raw
-    else:
-        scaled = raw * definition.scale
+    scaled = raw if definition.scale == 1 else raw * definition.scale
 
     return raw, scaled
 
@@ -235,10 +232,7 @@ def dump_device(
             success_count += 1
             if verbose:
                 scaled_str = f"{scaled}" if scaled is not None else "N/A"
-                print(
-                    f"  [OK]   {key} (addr {definition.address}): "
-                    f"raw={raw}, scaled={scaled_str}"
-                )
+                print(f"  [OK]   {key} (addr {definition.address}): raw={raw}, scaled={scaled_str}")
             register_dumps[key] = {
                 "address": definition.address,
                 "label": definition.label,
@@ -346,7 +340,9 @@ def main():
             print(f"Software Version: {dump.metadata['detected_software_version']}")
         if dump.metadata.get("detected_hardware_type"):
             print(f"Hardware Type: MAC {dump.metadata['detected_hardware_type']}")
-        print(f"Registers: {dump.metadata['registers_read']} read, {dump.metadata['registers_failed']} failed")
+        print(
+            f"Registers: {dump.metadata['registers_read']} read, {dump.metadata['registers_failed']} failed"
+        )
         print(f"Output: {output_path}")
 
     except ModbusException as e:
@@ -359,4 +355,3 @@ def main():
 
 if __name__ == "__main__":
     main()
-
diff --git a/tools/mock_coordinator.py b/tools/mock_coordinator.py
index e465d73..42d2a54 100644
--- a/tools/mock_coordinator.py
+++ b/tools/mock_coordinator.py
@@ -6,21 +6,20 @@
 
 Usage:
     from mock_coordinator import MockCoordinator
-    
+
     coord = MockCoordinator.from_file("dumps/my_device.json")
     print(coord.data)  # Access parsed register values
 """
 
 from __future__ import annotations
 
+import importlib.util
 import json
+import sys
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Any
 
-import sys
-import importlib.util
-
 # Add parent directory to path to import from custom_components
 sys.path.insert(0, str(Path(__file__).parent.parent))
 
@@ -54,7 +53,7 @@ class MockDeviceInfo:
 
 class MockCoordinator:
     """Mock coordinator that loads data from a JSON dump file.
-    
+
     This provides the same interface as ParmairCoordinator but without
     any Home Assistant dependencies, making it suitable for offline testing.
     """
@@ -67,7 +66,7 @@ def __init__(
         software_version: str = SOFTWARE_VERSION_1,
     ) -> None:
         """Initialize the mock coordinator.
-        
+
         Args:
             data: The processed register data (key -> scaled value)
             metadata: Dump metadata (timestamp, host, etc.)
@@ -109,10 +108,9 @@ def device_info(self) -> dict[str, Any]:
         model = "MAC"
         if hw_type is not None:
             hw_int = int(hw_type)
-            is_v2 = (
-                self._software_version == SOFTWARE_VERSION_2
-                or str(self._software_version).startswith("2.")
-            )
+            is_v2 = self._software_version == SOFTWARE_VERSION_2 or str(
+                self._software_version
+            ).startswith("2.")
             model_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int) if is_v2 else hw_int
             model = f"MAC {model_num}"
 
@@ -124,7 +122,7 @@ def device_info(self) -> dict[str, Any]:
         }
 
         if sw_version is not None:
-            if isinstance(sw_version, (int, float)):
+            if isinstance(sw_version, int | float):
                 device_info["sw_version"] = f"{sw_version:.2f}"
             else:
                 device_info["sw_version"] = str(sw_version)
@@ -142,12 +140,12 @@ def get_raw_value(self, key: str) -> int | None:
         return None
 
     @classmethod
-    def from_file(cls, filepath: str | Path) -> "MockCoordinator":
+    def from_file(cls, filepath: str | Path) -> MockCoordinator:
         """Create a MockCoordinator from a JSON dump file.
-        
+
         Args:
             filepath: Path to the JSON dump file
-            
+
         Returns:
             MockCoordinator instance with loaded data
         """
@@ -155,7 +153,7 @@ def from_file(cls, filepath: str | Path) -> "MockCoordinator":
         if not filepath.exists():
             raise FileNotFoundError(f"Dump file not found: {filepath}")
 
-        with open(filepath, "r", encoding="utf-8") as f:
+        with open(filepath, encoding="utf-8") as f:
             dump = json.load(f)
 
         metadata = dump.get("metadata", {})
@@ -163,14 +161,11 @@ def from_file(cls, filepath: str | Path) -> "MockCoordinator":
 
         # Determine software version from metadata or detect from version register
         software_version = metadata.get("register_map_version", SOFTWARE_VERSION_1)
-        
+
         # Override if we have detected version that suggests different map
         detected_ver = metadata.get("detected_software_version")
         if detected_ver is not None:
-            if detected_ver >= 2.0:
-                software_version = SOFTWARE_VERSION_2
-            else:
-                software_version = SOFTWARE_VERSION_1
+            software_version = SOFTWARE_VERSION_2 if detected_ver >= 2.0 else SOFTWARE_VERSION_1
 
         # Build data dict from scaled values
         data: dict[str, Any] = {}
@@ -183,10 +178,7 @@ def from_file(cls, filepath: str | Path) -> "MockCoordinator":
 
         # v2.x: derive home_state, boost_state, overpressure_state from control_state
         # (USERSTATECONTROL_FO: 0=Off, 1=Away, 2=Home, 3=Boost, 4=Sauna, 5=Fireplace)
-        is_v2 = (
-            software_version == SOFTWARE_VERSION_2
-            or str(software_version).startswith("2.")
-        )
+        is_v2 = software_version == SOFTWARE_VERSION_2 or str(software_version).startswith("2.")
         if is_v2:
             user_state = data.get("control_state")
             if user_state is not None:
@@ -206,22 +198,22 @@ def from_dict(
         cls,
         data: dict[str, Any],
         software_version: str = SOFTWARE_VERSION_1,
-    ) -> "MockCoordinator":
+    ) -> MockCoordinator:
         """Create a MockCoordinator from a data dictionary.
-        
+
         This is useful for creating test fixtures with specific values.
-        
+
         Args:
             data: Dictionary of register key -> scaled value
             software_version: Software version for register map
-            
+
         Returns:
             MockCoordinator instance
         """
         # Build register dict from data
         registers_map = get_registers_for_version(software_version)
         registers: dict[str, dict[str, Any]] = {}
-        
+
         for key, value in data.items():
             if key in registers_map:
                 reg_def = registers_map[key]
@@ -230,7 +222,7 @@ def from_dict(
                     raw = int(value) if value is not None else None
                 else:
                     raw = int(round(value / reg_def.scale)) if value is not None else None
-                    
+
                 registers[key] = {
                     "address": reg_def.address,
                     "label": reg_def.label,
@@ -247,10 +239,7 @@ def from_dict(
         }
 
         # v2.x: derive home_state, boost_state, overpressure_state from control_state
-        is_v2 = (
-            software_version == SOFTWARE_VERSION_2
-            or str(software_version).startswith("2.")
-        )
+        is_v2 = software_version == SOFTWARE_VERSION_2 or str(software_version).startswith("2.")
         if is_v2:
             data = dict(data)  # Copy to avoid mutating user input
             user_state = data.get("control_state")
@@ -275,12 +264,11 @@ def __repr__(self) -> str:
 # Convenience function for quick loading
 def load_dump(filepath: str | Path) -> MockCoordinator:
     """Load a dump file and return a MockCoordinator.
-    
+
     Args:
         filepath: Path to the JSON dump file
-        
+
     Returns:
         MockCoordinator instance
     """
     return MockCoordinator.from_file(filepath)
-
diff --git a/tools/test_interpretation.py b/tools/test_interpretation.py
index 0ee8254..2f8b880 100644
--- a/tools/test_interpretation.py
+++ b/tools/test_interpretation.py
@@ -22,7 +22,7 @@
 import sys
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Any, Callable
+from typing import Any
 
 # Add parent directory to path
 sys.path.insert(0, str(Path(__file__).parent.parent))
@@ -126,6 +126,7 @@
 # Interpretation Functions
 # ============================================================================
 
+
 def interpret_power_state(value: int | None, is_v2: bool = False) -> str:
     """Interpret power state register value."""
     if value is None:
@@ -195,6 +196,7 @@ def format_filter_date(day: int | None, month: int | None, year: int | None) ->
 # Test Result Types
 # ============================================================================
 
+
 @dataclass
 class TestResult:
     """Result of a single interpretation test."""
@@ -215,10 +217,10 @@ def __init__(self, coordinator: MockCoordinator, verbose: bool = False):
         self.coord = coordinator
         self.verbose = verbose
         self.results: list[TestResult] = []
-        
+
         # Detect if this is a V2.x device
         sw_ver = coordinator.data.get("software_version", 0)
-        self.is_v2 = sw_ver >= 2.0 if isinstance(sw_ver, (int, float)) else False
+        self.is_v2 = sw_ver >= 2.0 if isinstance(sw_ver, int | float) else False
 
     def test_all(self) -> list[TestResult]:
         """Run all interpretation tests."""
@@ -262,13 +264,9 @@ def _test_system_info(self):
         sw_ver = self.coord.data.get("software_version")
         raw = self.coord.get_raw_value("software_version")
         if sw_ver is not None:
-            self._add_result(
-                "System", "Software Version", raw, f"{sw_ver:.2f}"
-            )
+            self._add_result("System", "Software Version", raw, f"{sw_ver:.2f}")
         else:
-            self._add_result(
-                "System", "Software Version", raw, "N/A", "warning"
-            )
+            self._add_result("System", "Software Version", raw, "N/A", "warning")
 
         # Hardware type
         hw_type = self.coord.data.get("hardware_type")
@@ -283,17 +281,11 @@ def _test_system_info(self):
                         "System", "Hardware Type", raw, f"MAC {model_num} (type code {hw_type_int})"
                     )
                 else:
-                    self._add_result(
-                        "System", "Hardware Type", raw, f"MAC {hw_type_int}"
-                    )
+                    self._add_result("System", "Hardware Type", raw, f"MAC {hw_type_int}")
             else:
-                self._add_result(
-                    "System", "Hardware Type", raw, f"MAC {hw_type_int}"
-                )
+                self._add_result("System", "Hardware Type", raw, f"MAC {hw_type_int}")
         else:
-            self._add_result(
-                "System", "Hardware Type", raw, "N/A", "warning"
-            )
+            self._add_result("System", "Hardware Type", raw, "N/A", "warning")
 
         # Heater type
         heater = self.coord.data.get("heater_type")
@@ -324,10 +316,9 @@ def _test_temperatures(self):
             # Check for reasonable temperature range
             status = "ok"
             note = ""
-            if value is not None:
-                if value < -50 or value > 80:
-                    status = "warning"
-                    note = "Unusual temperature"
+            if value is not None and (value < -50 or value > 80):
+                status = "warning"
+                note = "Unusual temperature"
 
             self._add_result(
                 "Temperature",
@@ -372,9 +363,7 @@ def _test_states(self):
                 "State",
                 "Home/Away",
                 raw,
-                interpret_binary_state(
-                    int(home) if home is not None else None, HOME_STATE_MAP
-                ),
+                interpret_binary_state(int(home) if home is not None else None, HOME_STATE_MAP),
             )
 
         # Boost state - V2 derives from control_state
@@ -388,9 +377,7 @@ def _test_states(self):
                 "State",
                 "Boost",
                 raw,
-                interpret_binary_state(
-                    int(boost) if boost is not None else None, BINARY_STATE_MAP
-                ),
+                interpret_binary_state(int(boost) if boost is not None else None, BINARY_STATE_MAP),
             )
 
         # Overpressure/Sauna/Fireplace state - V2 has different modes
@@ -409,9 +396,7 @@ def _test_states(self):
                 "State",
                 "Overpressure",
                 raw,
-                interpret_binary_state(
-                    int(overp) if overp is not None else None, BINARY_STATE_MAP
-                ),
+                interpret_binary_state(int(overp) if overp is not None else None, BINARY_STATE_MAP),
             )
 
         # Defrost state
@@ -421,9 +406,7 @@ def _test_states(self):
             "State",
             "Defrost",
             raw,
-            interpret_binary_state(
-                int(defrost) if defrost is not None else None, BINARY_STATE_MAP
-            ),
+            interpret_binary_state(int(defrost) if defrost is not None else None, BINARY_STATE_MAP),
         )
 
     def _test_speeds(self):
@@ -490,9 +473,7 @@ def _test_optional_sensors(self):
         if is_optional_sensor_installed(raw):
             self._add_result("Optional", "Humidity", raw, f"{humidity}%")
         else:
-            self._add_result(
-                "Optional", "Humidity", raw, "Not installed", "ok", "Sensor absent"
-            )
+            self._add_result("Optional", "Humidity", raw, "Not installed", "ok", "Sensor absent")
 
         # Humidity 24h average
         humidity_avg = self.coord.data.get("humidity_24h_avg")
@@ -500,9 +481,7 @@ def _test_optional_sensors(self):
         if humidity_avg is not None and humidity_avg >= 0:
             self._add_result("Optional", "Humidity 24h Avg", raw, f"{humidity_avg:.1f}%")
         else:
-            self._add_result(
-                "Optional", "Humidity 24h Avg", raw, "Not available", "ok"
-            )
+            self._add_result("Optional", "Humidity 24h Avg", raw, "Not available", "ok")
 
         # CO2
         co2 = self.coord.data.get("co2")
@@ -510,9 +489,7 @@ def _test_optional_sensors(self):
         if is_optional_sensor_installed(raw):
             self._add_result("Optional", "CO2", raw, f"{co2} ppm")
         else:
-            self._add_result(
-                "Optional", "CO2", raw, "Not installed", "ok", "Sensor absent"
-            )
+            self._add_result("Optional", "CO2", raw, "Not installed", "ok", "Sensor absent")
 
     def _test_filter_info(self):
         """Test filter information."""
@@ -576,20 +553,26 @@ def _test_switch_states(self):
                 self._add_result("State", "Season", raw, season_val)
             else:
                 self._add_result("State", "Season", raw, "N/A (register not read)")
-            
+
             # Summer cooling setting (0=Off, 1=On, 2=Auto?)
             summer = self.coord.data.get("summer_mode")
             raw = self.coord.get_raw_value("summer_mode")
             summer_cooling_map = {0: "Off", 1: "On", 2: "Auto"}
-            summer_val = summer_cooling_map.get(int(summer) if summer is not None else None, f"Unknown ({summer})")
+            summer_val = summer_cooling_map.get(
+                int(summer) if summer is not None else None, f"Unknown ({summer})"
+            )
             self._add_result("Switch", "Summer Cooling", raw, summer_val)
         else:
             # V1: summer_mode is just on/off
             summer = self.coord.data.get("summer_mode")
             raw = self.coord.get_raw_value("summer_mode")
             self._add_result(
-                "Switch", "Summer Mode", raw,
-                interpret_binary_state(int(summer) if summer is not None else None, BINARY_STATE_MAP),
+                "Switch",
+                "Summer Mode",
+                raw,
+                interpret_binary_state(
+                    int(summer) if summer is not None else None, BINARY_STATE_MAP
+                ),
             )
 
         # Other switches
@@ -605,9 +588,7 @@ def _test_switch_states(self):
                 "Switch",
                 name,
                 raw,
-                interpret_binary_state(
-                    int(value) if value is not None else None, BINARY_STATE_MAP
-                ),
+                interpret_binary_state(int(value) if value is not None else None, BINARY_STATE_MAP),
             )
 
     def _test_timers(self):
@@ -720,7 +701,7 @@ def test_file(filepath: Path, verbose: bool = False) -> bool:
     if coord.metadata.get("detected_software_version"):
         print(f"Software: {coord.metadata['detected_software_version']}")
     if coord.metadata.get("detected_hardware_type"):
-        hw_type = coord.metadata['detected_hardware_type']
+        hw_type = coord.metadata["detected_hardware_type"]
         # For V2, use mapping if available, otherwise use raw value
         if coord.software_version == SOFTWARE_VERSION_2:
             model_num = HARDWARE_TYPE_MAP_V2.get(hw_type, hw_type)
@@ -822,4 +803,3 @@ def main():
 
 if __name__ == "__main__":
     main()
-

From de03e38f9087f987e9b42c59dcd9def8fb044262 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 22:56:31 +0200
Subject: [PATCH 12/15] Add .git-blame-ignore-revs file to exclude Ruff
 lint/format commit from blame

---
 .git-blame-ignore-revs | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 .git-blame-ignore-revs

diff --git a/.git-blame-ignore-revs b/.git-blame-ignore-revs
new file mode 100644
index 0000000..ebee6fe
--- /dev/null
+++ b/.git-blame-ignore-revs
@@ -0,0 +1,3 @@
+# Ignore Ruff lint/format commit so blame shows last real change
+# https://git-scm.com/docs/git-blame#Documentation/git-blame.txt---ignore-revs-fileltfilegt
+4fec4c0f8742c86593598e2cb23f71f83a531bb3

From d84af37b0d3d00f5aacc154dd2ab6ef197969068 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 23:16:00 +0200
Subject: [PATCH 13/15] Replace number entities with select entities for
 settings

---
 .pre-commit-config.yaml             |  10 +
 custom_components/parmair/number.py |  95 --------
 custom_components/parmair/select.py | 350 +++++++++++++++++++++++++++-
 custom_components/parmair/switch.py |   1 +
 pyproject.toml                      |   1 +
 tests/test_interpretation.py        |  42 ++--
 6 files changed, 381 insertions(+), 118 deletions(-)
 create mode 100644 .pre-commit-config.yaml

diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
new file mode 100644
index 0000000..1963be8
--- /dev/null
+++ b/.pre-commit-config.yaml
@@ -0,0 +1,10 @@
+# See https://pre-commit.com for more information
+repos:
+  - repo: https://github.com/astral-sh/ruff-pre-commit
+    rev: v0.8.4
+    hooks:
+      # Run the linter
+      - id: ruff
+        args: [--fix]
+      # Run the formatter
+      - id: ruff-format
diff --git a/custom_components/parmair/number.py b/custom_components/parmair/number.py
index c3a3465..b8cf655 100644
--- a/custom_components/parmair/number.py
+++ b/custom_components/parmair/number.py
@@ -3,7 +3,6 @@
 from __future__ import annotations
 
 import logging
-from typing import Any
 
 from homeassistant.components.number import NumberEntity, NumberMode
 from homeassistant.config_entries import ConfigEntry
@@ -14,14 +13,9 @@
 
 from .const import (
     DOMAIN,
-    REG_AWAY_SPEED,
-    REG_BOOST_SETTING,
     REG_BOOST_TIMER,
     REG_EXHAUST_TEMP_SETPOINT,
-    REG_FILTER_INTERVAL,
-    REG_HOME_SPEED,
     REG_OVERPRESSURE_TIMER,
-    REG_SPEED_CONTROL,
     REG_SUMMER_MODE_TEMP_LIMIT,
     REG_SUPPLY_TEMP_SETPOINT,
 )
@@ -39,10 +33,6 @@ async def async_setup_entry(
     coordinator: ParmairCoordinator = hass.data[DOMAIN][entry.entry_id]
 
     entities: list[NumberEntity] = [
-        ParmairManualSpeedNumber(coordinator, entry, REG_SPEED_CONTROL, "Manual Speed Control"),
-        ParmairSpeedPresetNumber(coordinator, entry, REG_HOME_SPEED, "Home Speed Preset"),
-        ParmairSpeedPresetNumber(coordinator, entry, REG_AWAY_SPEED, "Away Speed Preset"),
-        ParmairSpeedPresetNumber(coordinator, entry, REG_BOOST_SETTING, "Boost Speed Preset"),
         ParmairTemperatureSetpointNumber(
             coordinator, entry, REG_EXHAUST_TEMP_SETPOINT, "Exhaust Temperature Setpoint"
         ),
@@ -52,9 +42,6 @@ async def async_setup_entry(
         ParmairTemperatureSetpointNumber(
             coordinator, entry, REG_SUMMER_MODE_TEMP_LIMIT, "Summer Mode Temperature Limit"
         ),
-        ParmairFilterIntervalNumber(
-            coordinator, entry, REG_FILTER_INTERVAL, "Filter Change Interval"
-        ),
         ParmairTimerNumber(
             coordinator,
             entry,
@@ -110,57 +97,6 @@ async def async_set_native_value(self, value: float) -> None:
             raise
 
 
-class ParmairManualSpeedNumber(ParmairNumberEntity):
-    """Number entity for manual speed control (0-6: Auto, Stop, Speed 1-5)."""
-
-    _attr_mode = NumberMode.BOX
-    _attr_native_min_value = 0
-    _attr_native_max_value = 6
-    _attr_native_step = 1
-    _attr_icon = "mdi:fan-speed-1"
-
-    def __init__(
-        self,
-        coordinator: ParmairCoordinator,
-        entry: ConfigEntry,
-        data_key: str,
-        name: str,
-    ) -> None:
-        """Initialize manual speed control number."""
-        super().__init__(coordinator, entry, data_key, name)
-
-    @property
-    def extra_state_attributes(self) -> dict[str, str]:
-        """Return speed mapping information."""
-        return {
-            "speed_map": "0=Auto, 1=Stop, 2=Speed 1, 3=Speed 2, 4=Speed 3, 5=Speed 4, 6=Speed 5"
-        }
-
-
-class ParmairSpeedPresetNumber(ParmairNumberEntity):
-    """Number entity for fan speed presets (0-4)."""
-
-    _attr_mode = NumberMode.BOX
-    _attr_native_min_value = 0
-    _attr_native_max_value = 4
-    _attr_native_step = 1
-    _attr_icon = "mdi:fan"
-
-    def __init__(
-        self,
-        coordinator: ParmairCoordinator,
-        entry: ConfigEntry,
-        data_key: str,
-        name: str,
-    ) -> None:
-        """Initialize speed preset number."""
-        super().__init__(coordinator, entry, data_key, name)
-
-        # Adjust boost setting range (2-4 per documentation)
-        if data_key == REG_BOOST_SETTING:
-            self._attr_native_min_value = 2
-
-
 class ParmairTemperatureSetpointNumber(ParmairNumberEntity):
     """Number entity for temperature setpoints."""
 
@@ -194,37 +130,6 @@ def __init__(
             self._attr_native_step = 0.5
 
 
-class ParmairFilterIntervalNumber(ParmairNumberEntity):
-    """Number entity for filter change interval (months)."""
-
-    _attr_mode = NumberMode.BOX
-    _attr_native_min_value = 0
-    _attr_native_max_value = 2
-    _attr_native_step = 1
-    _attr_icon = "mdi:air-filter"
-    _attr_native_unit_of_measurement = "setting"
-
-    def __init__(
-        self,
-        coordinator: ParmairCoordinator,
-        entry: ConfigEntry,
-        data_key: str,
-        name: str,
-    ) -> None:
-        """Initialize filter interval number."""
-        super().__init__(coordinator, entry, data_key, name)
-
-    @property
-    def extra_state_attributes(self) -> dict[str, Any]:
-        """Return additional attributes."""
-        attrs = super().extra_state_attributes or {}
-        value = self.native_value
-        if value is not None:
-            interval_map = {0: "3 months", 1: "4 months", 2: "6 months"}
-            attrs["interval_description"] = interval_map.get(int(value), "Unknown")
-        return attrs
-
-
 class ParmairTimerNumber(ParmairNumberEntity):
     """Number entity for boost/overpressure timers (minutes)."""
 
diff --git a/custom_components/parmair/select.py b/custom_components/parmair/select.py
index 50ef64c..38695ec 100644
--- a/custom_components/parmair/select.py
+++ b/custom_components/parmair/select.py
@@ -8,13 +8,83 @@
 from homeassistant.config_entries import ConfigEntry
 from homeassistant.core import HomeAssistant
 from homeassistant.helpers.entity_platform import AddEntitiesCallback
+from homeassistant.helpers.update_coordinator import CoordinatorEntity
+
+from .const import (
+    DOMAIN,
+    REG_AWAY_SPEED,
+    REG_BOOST_SETTING,
+    REG_BOOST_TIME_SETTING,
+    REG_FILTER_INTERVAL,
+    REG_HOME_SPEED,
+    REG_OVERPRESSURE_TIME_SETTING,
+    REG_SPEED_CONTROL,
+    REG_SUMMER_MODE,
+    SOFTWARE_VERSION_2,
+)
+from .coordinator import ParmairCoordinator
 
 _LOGGER = logging.getLogger(__name__)
 
+# Device value -> UI label (single source of truth)
+FILTER_INTERVAL_MAP: dict[int, str] = {0: "3 months", 1: "4 months", 2: "6 months"}
+FILTER_INTERVAL_OPTIONS = list(FILTER_INTERVAL_MAP.values())
+FILTER_INTERVAL_TO_VALUE = {v: k for k, v in FILTER_INTERVAL_MAP.items()}
+
+MANUAL_SPEED_MAP: dict[int, str] = {
+    0: "Auto",
+    1: "Stop",
+    2: "Speed 1",
+    3: "Speed 2",
+    4: "Speed 3",
+    5: "Speed 4",
+    6: "Speed 5",
+}
+MANUAL_SPEED_OPTIONS = list(MANUAL_SPEED_MAP.values())
+MANUAL_SPEED_TO_VALUE = {v: k for k, v in MANUAL_SPEED_MAP.items()}
+
+SPEED_PRESET_MAP: dict[int, str] = {
+    0: "Speed 1",
+    1: "Speed 2",
+    2: "Speed 3",
+    3: "Speed 4",
+    4: "Speed 5",
+}
+SPEED_PRESET_OPTIONS = list(SPEED_PRESET_MAP.values())
+SPEED_PRESET_TO_VALUE = {v: k for k, v in SPEED_PRESET_MAP.items()}
+
+BOOST_SPEED_MAP: dict[int, str] = {2: "Speed 3", 3: "Speed 4", 4: "Speed 5"}
+BOOST_SPEED_OPTIONS = list(BOOST_SPEED_MAP.values())
+BOOST_SPEED_TO_VALUE = {v: k for k, v in BOOST_SPEED_MAP.items()}
+
+SUMMER_MODE_MAP: dict[int, str] = {0: "Off", 1: "On", 2: "Auto"}
+SUMMER_MODE_OPTIONS = list(SUMMER_MODE_MAP.values())
+SUMMER_MODE_TO_VALUE = {v: k for k, v in SUMMER_MODE_MAP.items()}
+
+BOOST_DURATION_MAP: dict[int, str] = {
+    0: "30 min",
+    1: "60 min",
+    2: "90 min",
+    3: "120 min",
+    4: "180 min",
+}
+BOOST_DURATION_OPTIONS = list(BOOST_DURATION_MAP.values())
+BOOST_DURATION_TO_VALUE = {v: k for k, v in BOOST_DURATION_MAP.items()}
+
+OVERPRESSURE_DURATION_MAP: dict[int, str] = {
+    0: "15 min",
+    1: "30 min",
+    2: "45 min",
+    3: "60 min",
+    4: "120 min",
+}
+OVERPRESSURE_DURATION_OPTIONS = list(OVERPRESSURE_DURATION_MAP.values())
+OVERPRESSURE_DURATION_TO_VALUE = {v: k for k, v in OVERPRESSURE_DURATION_MAP.items()}
+
 
 async def async_setup_entry(
-    _hass: HomeAssistant,
-    _entry: ConfigEntry,
+    hass: HomeAssistant,
+    entry: ConfigEntry,
     async_add_entities: AddEntitiesCallback,
 ) -> None:
     """Set up Parmair select platform."""
@@ -36,3 +106,279 @@ async def async_setup_entry(
         entities.append(ParmairSummerModeSelect(coordinator, entry))
 
     async_add_entities(entities)
+
+
+class ParmairFilterIntervalSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for filter change interval (3, 4 or 6 months)."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Filter Change Interval"
+    _attr_icon = "mdi:air-filter"
+    _attr_options = FILTER_INTERVAL_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize filter interval select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_FILTER_INTERVAL}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_FILTER_INTERVAL)
+        if value is None:
+            return None
+        return FILTER_INTERVAL_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the filter change interval."""
+        raw = FILTER_INTERVAL_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_FILTER_INTERVAL, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set filter interval to %s: %s", option, ex)
+            raise
+
+
+class ParmairManualSpeedSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for manual speed control (Auto, Stop, Speed 1-5)."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Manual Speed Control"
+    _attr_icon = "mdi:fan-speed-1"
+    _attr_options = MANUAL_SPEED_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize manual speed select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_SPEED_CONTROL}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_SPEED_CONTROL)
+        if value is None:
+            return None
+        return MANUAL_SPEED_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the manual speed."""
+        raw = MANUAL_SPEED_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_SPEED_CONTROL, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set manual speed to %s: %s", option, ex)
+            raise
+
+
+class ParmairSpeedPresetSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for Home or Away speed preset (Speed 1-5)."""
+
+    _attr_has_entity_name = True
+    _attr_icon = "mdi:fan"
+    _attr_options = SPEED_PRESET_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+        data_key: str,
+        name: str,
+    ) -> None:
+        """Initialize speed preset select."""
+        super().__init__(coordinator)
+        self._data_key = data_key
+        self._attr_name = name
+        self._attr_unique_id = f"{entry.entry_id}_{data_key}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(self._data_key)
+        if value is None:
+            return None
+        return SPEED_PRESET_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the speed preset."""
+        raw = SPEED_PRESET_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(self._data_key, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set %s to %s: %s", self._data_key, option, ex)
+            raise
+
+
+class ParmairBoostSpeedSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for boost speed preset (Speed 3, 4 or 5)."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Boost Speed Preset"
+    _attr_icon = "mdi:fan"
+    _attr_options = BOOST_SPEED_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize boost speed select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_BOOST_SETTING}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_BOOST_SETTING)
+        if value is None:
+            return None
+        return BOOST_SPEED_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the boost speed preset."""
+        raw = BOOST_SPEED_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_BOOST_SETTING, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set boost speed to %s: %s", option, ex)
+            raise
+
+
+class ParmairSummerModeSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for summer mode on V2 (Off, On, Auto)."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Summer Mode"
+    _attr_icon = "mdi:weather-sunny"
+    _attr_options = SUMMER_MODE_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize summer mode select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_SUMMER_MODE}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_SUMMER_MODE)
+        if value is None:
+            return None
+        return SUMMER_MODE_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the summer mode."""
+        raw = SUMMER_MODE_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_SUMMER_MODE, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set summer mode to %s: %s", option, ex)
+            raise
+
+
+class ParmairBoostDurationSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for boost duration preset when activating boost."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Boost Duration Preset"
+    _attr_icon = "mdi:timer"
+    _attr_options = BOOST_DURATION_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize boost duration select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_BOOST_TIME_SETTING}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_BOOST_TIME_SETTING)
+        if value is None:
+            return None
+        return BOOST_DURATION_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the boost duration preset."""
+        raw = BOOST_DURATION_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_BOOST_TIME_SETTING, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set boost duration to %s: %s", option, ex)
+            raise
+
+
+class ParmairOverpressureDurationSelect(CoordinatorEntity[ParmairCoordinator], SelectEntity):
+    """Select entity for overpressure duration preset when activating overpressure."""
+
+    _attr_has_entity_name = True
+    _attr_name = "Overpressure Duration Preset"
+    _attr_icon = "mdi:timer"
+    _attr_options = OVERPRESSURE_DURATION_OPTIONS
+
+    def __init__(
+        self,
+        coordinator: ParmairCoordinator,
+        entry: ConfigEntry,
+    ) -> None:
+        """Initialize overpressure duration select."""
+        super().__init__(coordinator)
+        self._attr_unique_id = f"{entry.entry_id}_{REG_OVERPRESSURE_TIME_SETTING}"
+        self._attr_device_info = coordinator.device_info
+
+    @property
+    def current_option(self) -> str | None:
+        """Return the current selected option."""
+        value = self.coordinator.data.get(REG_OVERPRESSURE_TIME_SETTING)
+        if value is None:
+            return None
+        return OVERPRESSURE_DURATION_MAP.get(int(value))
+
+    async def async_select_option(self, option: str) -> None:
+        """Set the overpressure duration preset."""
+        raw = OVERPRESSURE_DURATION_TO_VALUE.get(option)
+        if raw is None:
+            return
+        try:
+            await self.coordinator.async_write_register(REG_OVERPRESSURE_TIME_SETTING, raw)
+            await self.coordinator.async_request_refresh()
+        except Exception as ex:
+            _LOGGER.error("Failed to set overpressure duration to %s: %s", option, ex)
+            raise
diff --git a/custom_components/parmair/switch.py b/custom_components/parmair/switch.py
index ca183ed..a0f1514 100644
--- a/custom_components/parmair/switch.py
+++ b/custom_components/parmair/switch.py
@@ -25,6 +25,7 @@
     REG_SUMMER_MODE,
     REG_SUMMER_MODE_TEMP_LIMIT,
     REG_TIME_PROGRAM_ENABLE,
+    SOFTWARE_VERSION_1,
     SOFTWARE_VERSION_2,
 )
 from .coordinator import ParmairCoordinator
diff --git a/pyproject.toml b/pyproject.toml
index 3f1c83b..b9b066a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -29,6 +29,7 @@ dev = [
     "ruff>=0.4.0",
     "mypy>=1.10.0",
     "homeassistant-stubs>=2025.5.0",
+    "pre-commit>=3.0.0",
 ]
 
 [project.urls]
diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
index 47a331c..2a7e17b 100644
--- a/tests/test_interpretation.py
+++ b/tests/test_interpretation.py
@@ -46,9 +46,9 @@ def test_fixture_loads_successfully(self, coordinator: MockCoordinator) -> None:
     def test_fixture_has_metadata(self, fixture_metadata: dict[str, Any]) -> None:
         """Verify fixture has required metadata."""
         assert "register_map_version" in fixture_metadata, "Fixture must have register_map_version"
-        assert "detected_software_version" in fixture_metadata, (
-            "Fixture must have detected_software_version"
-        )
+        assert (
+            "detected_software_version" in fixture_metadata
+        ), "Fixture must have detected_software_version"
 
     def test_fixture_has_registers(self, fixture_registers: dict[str, Any]) -> None:
         """Verify fixture has register data."""
@@ -304,9 +304,9 @@ def test_temperature_scaling(self, coordinator: MockCoordinator) -> None:
 
         # With 0.1 scaling, raw 174 should give 17.4
         expected = raw * 0.1
-        assert abs(scaled - expected) < 0.01, (
-            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
-        )
+        assert (
+            abs(scaled - expected) < 0.01
+        ), f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
 
     def test_version_scaling(self, coordinator: MockCoordinator) -> None:
         """Version values should be scaled by 0.01."""
@@ -318,9 +318,9 @@ def test_version_scaling(self, coordinator: MockCoordinator) -> None:
 
         # With 0.01 scaling, raw 225 should give 2.25
         expected = raw * 0.01
-        assert abs(scaled - expected) < 0.001, (
-            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
-        )
+        assert (
+            abs(scaled - expected) < 0.001
+        ), f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
 
 
 class TestRegisterDefinitions:
@@ -356,12 +356,12 @@ def test_get_register_definition(self, coordinator: MockCoordinator) -> None:
             assert definition is not None
             assert definition.key == key
             assert definition.address > 0
-            assert definition.address == expected[key], (
-                f"{key} address should be {expected[key]}, got {definition.address}"
-            )
-            assert definition.label is not None and len(definition.label) > 0, (
-                f"{key} should have non-empty label"
-            )
+            assert (
+                definition.address == expected[key]
+            ), f"{key} address should be {expected[key]}, got {definition.address}"
+            assert (
+                definition.label is not None and len(definition.label) > 0
+            ), f"{key} should have non-empty label"
 
     def test_overpressure_timer_writable(self, coordinator: MockCoordinator) -> None:
         """Overpressure timer register should be writable (was overwritten by duplicate def)."""
@@ -378,9 +378,9 @@ def test_v2_register_addresses_match_documentation(self) -> None:
         """V2 register addresses must match device docs (catches wrong map in writes)."""
         regs = get_registers_for_version(SOFTWARE_VERSION_2)
         assert regs[REG_POWER].address == 1180, "V2 POWER should be UNIT_CONTROL_FO at 1180"
-        assert regs[REG_CONTROL_STATE].address == 1181, (
-            "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
-        )
+        assert (
+            regs[REG_CONTROL_STATE].address == 1181
+        ), "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
 
     def test_power_register_address_varies_by_version(self) -> None:
         """Power register address differs between v1 and v2 (config_flow must use correct one)."""
@@ -419,9 +419,9 @@ def test_hardware_type_mapping_v2(
         expected_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int)
         expected_model = f"MAC {expected_num}"
         device_info = coordinator.device_info
-        assert device_info["model"] == expected_model, (
-            f"V2 hw_type {hw_int} should map to {expected_model}, got {device_info['model']}"
-        )
+        assert (
+            device_info["model"] == expected_model
+        ), f"V2 hw_type {hw_int} should map to {expected_model}, got {device_info['model']}"
 
     def test_v2_derived_states_binary(
         self, coordinator: MockCoordinator, is_v2_device: bool

From 3e7980902479fd913a6e82001b4652256169f9e9 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 23:35:21 +0200
Subject: [PATCH 14/15] Add options flow for reconfiguring integration

---
 custom_components/parmair/__init__.py    |  7 +++
 custom_components/parmair/config_flow.py | 69 ++++++++++++++++++++++++
 custom_components/parmair/coordinator.py | 20 ++++---
 3 files changed, 89 insertions(+), 7 deletions(-)

diff --git a/custom_components/parmair/__init__.py b/custom_components/parmair/__init__.py
index fdcadb1..ae772d3 100644
--- a/custom_components/parmair/__init__.py
+++ b/custom_components/parmair/__init__.py
@@ -42,9 +42,16 @@ async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
 
     await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
 
+    entry.async_on_unload(entry.add_update_listener(_async_options_updated))
+
     return True
 
 
+async def _async_options_updated(hass: HomeAssistant, entry: ConfigEntry) -> None:
+    """Reload the integration when options are updated."""
+    await hass.config_entries.async_reload(entry.entry_id)
+
+
 async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
     """Unload a config entry."""
     if unload_ok := await hass.config_entries.async_unload_platforms(entry, PLATFORMS):
diff --git a/custom_components/parmair/config_flow.py b/custom_components/parmair/config_flow.py
index de85acb..3b28fc0 100644
--- a/custom_components/parmair/config_flow.py
+++ b/custom_components/parmair/config_flow.py
@@ -422,3 +422,72 @@ async def async_step_manual_version(
                 "info": "Auto-detection failed. Please select your device's software version and heater type manually.",
             },
         )
+
+    @staticmethod
+    async def async_get_options_flow(
+        config_entry: config_entries.ConfigEntry,
+    ) -> config_entries.OptionsFlow:
+        """Return the options flow handler."""
+        return ParmairOptionsFlowHandler(config_entry)
+
+
+class ParmairOptionsFlowHandler(config_entries.OptionsFlowWithConfigEntry):
+    """Handle Parmair options (change host, port, name, scan interval, software version, heater type)."""
+
+    async def async_step_init(self, user_input: dict[str, Any] | None = None) -> FlowResult:
+        """Manage the options."""
+        if user_input is not None:
+            return self.async_create_entry(title="", data=user_input)
+
+        data = self.config_entry.data
+        options = self.config_entry.options or {}
+
+        return self.async_show_form(
+            step_id="init",
+            data_schema=vol.Schema(
+                {
+                    vol.Required(
+                        CONF_HOST,
+                        default=options.get(CONF_HOST, data.get(CONF_HOST, "")),
+                    ): cv.string,
+                    vol.Required(
+                        CONF_PORT,
+                        default=options.get(CONF_PORT, data.get(CONF_PORT, DEFAULT_PORT)),
+                    ): cv.port,
+                    vol.Optional(
+                        CONF_NAME,
+                        default=options.get(CONF_NAME, data.get(CONF_NAME, DEFAULT_NAME)),
+                    ): cv.string,
+                    vol.Optional(
+                        CONF_SCAN_INTERVAL,
+                        default=options.get(
+                            CONF_SCAN_INTERVAL, data.get(CONF_SCAN_INTERVAL, DEFAULT_SCAN_INTERVAL)
+                        ),
+                    ): vol.All(vol.Coerce(int), vol.Range(min=5, max=300)),
+                    vol.Required(
+                        CONF_SOFTWARE_VERSION,
+                        default=options.get(
+                            CONF_SOFTWARE_VERSION,
+                            data.get(CONF_SOFTWARE_VERSION, SOFTWARE_VERSION_1),
+                        ),
+                    ): vol.In(
+                        {
+                            SOFTWARE_VERSION_1: "Software 1.xx",
+                            SOFTWARE_VERSION_2: "Software 2.xx",
+                        }
+                    ),
+                    vol.Required(
+                        CONF_HEATER_TYPE,
+                        default=options.get(
+                            CONF_HEATER_TYPE, data.get(CONF_HEATER_TYPE, HEATER_TYPE_NONE)
+                        ),
+                    ): vol.In(
+                        {
+                            HEATER_TYPE_NONE: "None",
+                            HEATER_TYPE_WATER: "Water",
+                            HEATER_TYPE_ELECTRIC: "Electric",
+                        }
+                    ),
+                }
+            ),
+        )
diff --git a/custom_components/parmair/coordinator.py b/custom_components/parmair/coordinator.py
index e745355..24254aa 100644
--- a/custom_components/parmair/coordinator.py
+++ b/custom_components/parmair/coordinator.py
@@ -11,7 +11,7 @@
 from typing import Any
 
 from homeassistant.config_entries import ConfigEntry
-from homeassistant.const import CONF_HOST, CONF_PORT
+from homeassistant.const import CONF_HOST, CONF_NAME, CONF_PORT
 from homeassistant.core import HomeAssistant
 from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed
 from pymodbus.client import ModbusTcpClient
@@ -87,11 +87,16 @@ def _build_read_ranges(
 class ParmairCoordinator(DataUpdateCoordinator[dict[str, Any]]):
     """Class to manage fetching Parmair data from Modbus."""
 
+    def _opt(self, key: str, default: Any) -> Any:
+        """Get config value from options with fallback to entry data."""
+        opts = self.entry.options or {}
+        return opts.get(key, self.entry.data.get(key, default))
+
     def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
         """Initialize the coordinator."""
         self.entry = entry
-        self.host = entry.data[CONF_HOST]
-        self.port = entry.data.get(CONF_PORT, DEFAULT_PORT)
+        self.host = self._opt(CONF_HOST, entry.data.get(CONF_HOST, ""))
+        self.port = self._opt(CONF_PORT, DEFAULT_PORT)
         # Parmair devices use unit 0; default to 0 and treat legacy slave_id=1 as 0
         raw_slave_id = entry.data.get(CONF_SLAVE_ID, DEFAULT_SLAVE_ID)
         if raw_slave_id == 1:
@@ -102,10 +107,11 @@ def __init__(self, hass: HomeAssistant, entry: ConfigEntry) -> None:
             self.slave_id = 0
         else:
             self.slave_id = raw_slave_id
-        self.software_version = entry.data.get(CONF_SOFTWARE_VERSION, SOFTWARE_VERSION_1)
-        self.heater_type = entry.data.get(CONF_HEATER_TYPE, HEATER_TYPE_UNKNOWN)
+        # Prefer options (user-configured) over initial config
+        self.software_version = self._opt(CONF_SOFTWARE_VERSION, SOFTWARE_VERSION_1)
+        self.heater_type = self._opt(CONF_HEATER_TYPE, HEATER_TYPE_UNKNOWN)
 
-        scan_interval = entry.data.get(CONF_SCAN_INTERVAL, DEFAULT_SCAN_INTERVAL)
+        scan_interval = self._opt(CONF_SCAN_INTERVAL, DEFAULT_SCAN_INTERVAL)
 
         # Get version-specific register map
         self._registers = get_registers_for_version(self.software_version)
@@ -342,7 +348,7 @@ def device_info(self) -> dict[str, Any]:
 
         device_info = {
             "identifiers": {(DOMAIN, self.entry.entry_id)},
-            "name": self.entry.data.get("name", DEFAULT_NAME),
+            "name": self._opt(CONF_NAME, DEFAULT_NAME),
             "manufacturer": "Parmair",
             "model": model,
         }

From a99cbaf5349a2984394d2ffd731f10ee209b63b8 Mon Sep 17 00:00:00 2001
From: Oskari Kantoniemi <oskari.kantoniemi@gmail.com>
Date: Fri, 13 Feb 2026 23:47:08 +0200
Subject: [PATCH 15/15] Fix versions and ruff formatting

---
 .pre-commit-config.yaml      |  2 +-
 pyproject.toml               |  6 +++---
 requirements-test.txt        |  6 +++---
 requirements.txt             |  6 +++---
 tests/test_interpretation.py | 42 ++++++++++++++++++------------------
 5 files changed, 31 insertions(+), 31 deletions(-)

diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index 1963be8..cc16e9e 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -1,7 +1,7 @@
 # See https://pre-commit.com for more information
 repos:
   - repo: https://github.com/astral-sh/ruff-pre-commit
-    rev: v0.8.4
+    rev: v0.15.0  # latest ruff-pre-commit; use ruff 0.15.x locally
     hooks:
       # Run the linter
       - id: ruff
diff --git a/pyproject.toml b/pyproject.toml
index b9b066a..df08c86 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -24,9 +24,9 @@ dependencies = [
 
 [project.optional-dependencies]
 dev = [
-    "pytest>=8.0.0",
-    "pytest-cov>=4.0.0",
-    "ruff>=0.4.0",
+    "pytest>=9.0.0",
+    "pytest-cov>=7.0.0",
+    "ruff==0.15.1",  # match .pre-commit-config.yaml rev so local format matches hook
     "mypy>=1.10.0",
     "homeassistant-stubs>=2025.5.0",
     "pre-commit>=3.0.0",
diff --git a/requirements-test.txt b/requirements-test.txt
index d929ffd..278c3ea 100644
--- a/requirements-test.txt
+++ b/requirements-test.txt
@@ -4,11 +4,11 @@
 pymodbus>=3.11.2
 
 # Testing
-pytest>=8.0.0
-pytest-cov>=4.0.0
+pytest>=9.0.0
+pytest-cov>=7.0.0
 
 # Linting
-ruff>=0.4.0
+ruff==0.15.1
 
 # Type checking
 mypy>=1.10.0
diff --git a/requirements.txt b/requirements.txt
index 9c49338..75295a4 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -7,6 +7,6 @@ pymodbus>=3.7.4
 homeassistant>=2025.1.0
 
 # Development tools
-ruff>=0.4.0
-pytest>=8.0.0
-pytest-cov>=4.0.0
+ruff==0.15.1
+pytest>=9.0.0
+pytest-cov>=7.0.0
diff --git a/tests/test_interpretation.py b/tests/test_interpretation.py
index 2a7e17b..47a331c 100644
--- a/tests/test_interpretation.py
+++ b/tests/test_interpretation.py
@@ -46,9 +46,9 @@ def test_fixture_loads_successfully(self, coordinator: MockCoordinator) -> None:
     def test_fixture_has_metadata(self, fixture_metadata: dict[str, Any]) -> None:
         """Verify fixture has required metadata."""
         assert "register_map_version" in fixture_metadata, "Fixture must have register_map_version"
-        assert (
-            "detected_software_version" in fixture_metadata
-        ), "Fixture must have detected_software_version"
+        assert "detected_software_version" in fixture_metadata, (
+            "Fixture must have detected_software_version"
+        )
 
     def test_fixture_has_registers(self, fixture_registers: dict[str, Any]) -> None:
         """Verify fixture has register data."""
@@ -304,9 +304,9 @@ def test_temperature_scaling(self, coordinator: MockCoordinator) -> None:
 
         # With 0.1 scaling, raw 174 should give 17.4
         expected = raw * 0.1
-        assert (
-            abs(scaled - expected) < 0.01
-        ), f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        assert abs(scaled - expected) < 0.01, (
+            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        )
 
     def test_version_scaling(self, coordinator: MockCoordinator) -> None:
         """Version values should be scaled by 0.01."""
@@ -318,9 +318,9 @@ def test_version_scaling(self, coordinator: MockCoordinator) -> None:
 
         # With 0.01 scaling, raw 225 should give 2.25
         expected = raw * 0.01
-        assert (
-            abs(scaled - expected) < 0.001
-        ), f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        assert abs(scaled - expected) < 0.001, (
+            f"Scaling error: raw={raw}, scaled={scaled}, expected={expected}"
+        )
 
 
 class TestRegisterDefinitions:
@@ -356,12 +356,12 @@ def test_get_register_definition(self, coordinator: MockCoordinator) -> None:
             assert definition is not None
             assert definition.key == key
             assert definition.address > 0
-            assert (
-                definition.address == expected[key]
-            ), f"{key} address should be {expected[key]}, got {definition.address}"
-            assert (
-                definition.label is not None and len(definition.label) > 0
-            ), f"{key} should have non-empty label"
+            assert definition.address == expected[key], (
+                f"{key} address should be {expected[key]}, got {definition.address}"
+            )
+            assert definition.label is not None and len(definition.label) > 0, (
+                f"{key} should have non-empty label"
+            )
 
     def test_overpressure_timer_writable(self, coordinator: MockCoordinator) -> None:
         """Overpressure timer register should be writable (was overwritten by duplicate def)."""
@@ -378,9 +378,9 @@ def test_v2_register_addresses_match_documentation(self) -> None:
         """V2 register addresses must match device docs (catches wrong map in writes)."""
         regs = get_registers_for_version(SOFTWARE_VERSION_2)
         assert regs[REG_POWER].address == 1180, "V2 POWER should be UNIT_CONTROL_FO at 1180"
-        assert (
-            regs[REG_CONTROL_STATE].address == 1181
-        ), "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
+        assert regs[REG_CONTROL_STATE].address == 1181, (
+            "V2 CONTROL_STATE should be USERSTATECONTROL at 1181"
+        )
 
     def test_power_register_address_varies_by_version(self) -> None:
         """Power register address differs between v1 and v2 (config_flow must use correct one)."""
@@ -419,9 +419,9 @@ def test_hardware_type_mapping_v2(
         expected_num = HARDWARE_TYPE_MAP_V2.get(hw_int, hw_int)
         expected_model = f"MAC {expected_num}"
         device_info = coordinator.device_info
-        assert (
-            device_info["model"] == expected_model
-        ), f"V2 hw_type {hw_int} should map to {expected_model}, got {device_info['model']}"
+        assert device_info["model"] == expected_model, (
+            f"V2 hw_type {hw_int} should map to {expected_model}, got {device_info['model']}"
+        )
 
     def test_v2_derived_states_binary(
         self, coordinator: MockCoordinator, is_v2_device: bool
